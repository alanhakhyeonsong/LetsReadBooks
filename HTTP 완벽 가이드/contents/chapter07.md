# 7장. 캐시
웹 캐시는 자주 쓰이는 문서와 사본을 자동으로 보관하는 HTTP 장치다. 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 서버가 아니라 그 캐시로부터 제공한다.

- 캐시는 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다.
- 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러 올 수 있게 된다.
- 캐시는 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.
- 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.

## 적중과 부적중
그러나 캐시가 세상 모든 문서의 사본을 저장하지는 않는다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/94ba5b13-6e6d-4be2-82f4-a52da6af1b05)

### 재검사(Revalidation)
원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다. 이러한 '신선도 검사'를 HTTP 재검사라 한다. 효과적인 재검사를 위해, HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청을 정의했다.

대부분의 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 한다.

- 적중: 그냥 캐시서버에 있는거 쓰면 된다.
- 부적중: 캐시서버에 없으면 본래 서버에서 꺼내와서 캐시서버에 저장하면 된다.
- 재검사: `If-Modified-Since` 헤더를 활용해서 캐시된 시간 이후에 변경되었는지 확인하는 방법이다.
  - 만일 여기서 적중시, Client에게 304(Not Modified)를 반환
  - 부적중시, 서버는 콘텐츠와 함께 200(Ok)를 반환
  - 객체가 삭제시, 404(Not Found)를 반환

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/a8744115-b987-4156-8c8b-043c931a81eb)

### 캐시 토폴로지
- 개인 전용 캐시: 흔히 웹 브라우저에서 일반적인 사용자가 사용하는 임시 파일로 불리는 것들이다.
- 공용 프락시 캐시: 프락시 캐시라고 하며, 여러 사용자가 접근하여 사용하는 공용 파일이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/4e136388-a831-47b1-abb5-f739f185885f)

### 캐시 처리 단계
1. 요청 받기 : 네트워크로부터 받은 요청 메세지를 읽는다.
2. 파싱 : 캐시는 메세지를 파싱하여 URL과 헤더들을 추출한다.
3. 검색 : 캐시는 로컬 복사본이 있는지 검사하고, 없다면 가져온다.
4. 신선도 검사 : 캐시된 사본이 신선한지 물어보고, 아니라면 변경사항을 서버에게 물어본다.
5. 응답 생성 : 캐시는 새로운 헤더와 캐시된 본문으로 응답메세지를 받는다.
6. 발송 : 네트워크를 통해 응답을 클라이언트에게 돌려준다.
7. 로깅 : 선택적으로, 이러한 트랜잭션 과정을 로그로 남긴다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/b6f80e99-2563-45e8-b7bc-bfb617e1b1ae)

### 사본을 신선하게 유지하기
- 문서 만료: `Cache-Control`과 `Expires`라는 특별한 헤더들을 이용해 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.
  - `Cache-Control: max-age` : 문서의 최대 나이를 정의한다.
  - `Expires` : 절대 유효기간을 명시한다.
- 서버 재검사: 캐시된 문서가 만료되었음을 서버에게 물어보는 것
  - 검사 결과 콘텐츠 변경되었으면 서버로부터 가져오면 된다.
  - 콘텐츠 변경이 없다면 새 만료일을 포함한 새로운 헤더만 가져오면 된다.

재검사를 할 때, 가장 흔히 쓰이는 것은 `If-Modified-Since` 인데, 주어진 날짜로부터 수정되었다면 서버는 요청을 처리한다. 만약 수정이 안되었으면 304(Not Modified) 를 응답한다. 다음으로는 `If-None-Match`이다. 일종의 버전정보(ETag)를 바탕으로 최신 데이터인지 확인하는 방식이다.