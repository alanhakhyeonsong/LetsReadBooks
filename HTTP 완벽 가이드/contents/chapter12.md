# 12장. 기본 인증
## 인증
**인증은 당신이 누구인지 증명하는 것이다.** 여권이나 운전 면허증 같은 신분증을 보여주는 것은, 당신이 누구인지 증명해 보이는 것이다. 완벽한 인증은 없다. 인증 수단은 도둑맞거나 위조될 수 있다. 하지만 당신에 대한 여러 데이터는 당신이 누구인지 판단하는데 도움이 된다.

### HTTP의 인증요구/응답 프레임워크
HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다. 웹 애플리케이션이 HTTP 요청 메시지를 받으면, 서버는 요청을 처리하는 대신에 현재 사용자가 누구인지를 알 수 있게 비밀번호 같이 개인 정보를 요구하는 '인증 요구'로 응답할 수 있다.

### 인증 프로토콜과 헤더
HTTP는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다. 아래 표에 나열된 헤더의 형식과 내용은 인증 프로토콜에 따라 달라진다. 인증 프로토콜은 HTTP 인증 헤더에 기술되어 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/1659c4ee-2464-49e8-b5a7-4f73bea87c73)

좀 더 구체적으로 살펴보자.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/7befae64-f9d3-424e-8fcb-90803246cd21)

- 요청을 보냄
- 서버가 사용자에게 인증요구를 보냄. 401 Unauthorized + WWW-Authenticate 헤더(어디서 어떻게 인증할지 설명)
- 클라이언트는 Authorization 헤더에 인코딩된 비밀번호와 그 외 인증 파라미터(주로 base-64 인코딩)를 담아서 요청을 보냄 -> ...이라고 하지만 당연히 비밀번호를 바로 인코딩해서 이렇게 보내는 경우는 없음. 로그인에서 많이 쓰는 JWT 로그인의 경우는 JWT를 여기에 담기도 함.
- 응답. 추가적으로 인증 알고리즘에 대한 정보를 Authentication-Info 헤더에 기술할 수도 있음

### 보안 영역
웹 서버는 보안 영역(realm) 그룹으로 나눈다. 보안 영역은 저마다 다른 사용자 권한을 요구한다.

```
HTTP/1.0 401 Unauthorized
WWW-Authenticate: Basic realm="Corporate Financials"
```

## 기본 인증
기본 인증은 가장 잘 알려진 HTTP 인증 규약이다. 거의 모든 주요 클라이언트와 서버에 기본 인증이 구현되어 있다. 기본 인증은 원래 HTTP/1.0에 기술되어 있었지만, HTTP 인증의 상세 내용을 다루는 RFC 2617로 옮겨졌다.

기본 인증에서, 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있다. 서버는 200 대신 401 상태 코드와 함께, 클라이언트가 접근하려고 했던 보안 영역을 WWW-Authenticate에 기술해서 응답하여 인증요구를 시작한다. 인증 정보를 포함하여 요청하라는 응답을 받은 브라우저는, 사용자에게 계정과 비밀번호를 입력할 수 있는 대화상자를 연다. 여기서 계정과 비밀번호는 사용자가 해당 영역에 접근 권한이 있는지 검사하는데 사용된다. 브라우저는 사용자가 입력한 사용자 이름과 비밀번호를 Authorization 요청 헤더 안에 암호화해서 서버로 다시 보낸다.

### 기본 인증의 예
- 인증요구 (서버에서 클라이언트): realm 은 요청받은 문서 집합의 이름을 따옴표로 감싼 것으로, 이 정보를 보고 어떤 비밀번호를 사용해야하는지 알 수 있다. `WWW-Authenticate" Basic realm=따옴표로 감싼 문서 집합 정보`
- 응답 (클라이언트에서 서버로): 사용자 이름과 비밀번호는 콜론으로 잇고, base-64 로 인코딩해서 사용자 이름과 비밀번호에 쉽게 구게문자를 포함할 수 있게 하고, 네트워크 트래픽에 사용자 이름과 비밀번호가 노출되지 않게한다. `Authorization: Basic base-64 로 인코딩한 사용자 이름과 비밀번호`

### Base-64 사용자 이름/비밀번호 인코딩
HTTP 기본 인증은 사용자 이름과 비밀번호를 콜론으로 이어서 합치고, base-64 인코딩 메서드를 사용해 인코딩 한다. base-64 인코딩은 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환한다. 각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 64개의 문자 중에서 선택된다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/2c794cd2-938d-4c8c-8fb2-2d25a501a36c)

base-64 인코딩은 바이너리, 텍스트, 국제 문자 데이터 문자열을 받아서 전송할 수 있게, 그 문자열을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명됐다. 전송 중 원본 문자열이 변질될 걱정 없이 원격에서 디코딩할 수 있다.

base-64 인코딩은 국제 문자나 HTTP 헤더에서 사용할 수 없는 문자(큰따옴표, 콜론, 캐리지 리턴)를 포함한 사용자 이름이나 비밀번호 문자를 섞을 수 있기 때문에, 서버나 네트워크를 관리하면서 뜻하지 않게 사용자 이름과 비밀번호가 노출되는 문제를 예방하는 데 도움이 된다.

### 프락시 인증
중개 프락시 서버를 통해 인증할 수도 있다. 어떤 회사는 사용자들이 회사의 서버나 LAN이나 무선 네트워크에 접근하기 전에 프락시 서버를 거치게 하여 사용자를 인증한다. 프락시 서버에서 접근 정책을 중앙 관리 할 수 있기 때문에, 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해 프락시 서버를 사용하면 좋다. 이 절차의 첫 번째 단계는 프락시 인증으로 사용자를 식별하는 것이다.

웹 서버와 프락시 인증에서 쓰이는 상태 코드와 헤더들의 대조표는 아래와 같다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/bb166fe1-4519-4b21-b0e0-c4a71522e4eb)

## 기본 인증의 보안 결함
기본 인증은 단순하고 편리하지만 안심할 수는 없다. 기본 인증은 악의적이지 않은 누군가가 의도치 않게 리소스에 접근하는 것을 막는데 사용하거나, SSL 같은 암호 기술과 혼용한다.

1. 기본 인증은 사용자 이름과 비밀번호를 쉽게 디코딩할 수 있는 형식으로 네트워크에 전송한다. base-64로 인코딩된 비밀번호는 사실상 '비밀번호 그대로' 보내는 것과 다름없다. 어떤 좋지 않은 의도를 가진 외부 업자가 기본 인증으로 보낸 사용자 이름과 비밀번호를 가로채는 상황을 생각해보자. 이게 문제가 된다면, **모든 HTTP 트랜잭션을 SSL 암호화 채널을 통해 보내거나, 보안이 더 강화된 다이제스트 인증 같은 프로토콜을 사용하는 것이 좋다.**
2. 보안 비밀번호가 디코딩하기 더 복잡한 방식으로 인코딩되어 있다 하더라도, 여전히 제삼자는 읽기 힘든 사용자 이름과 비밀번호를 캡쳐한 다음, 그것을 그대로 원 서버에 보내 인증에 성공하고 서버에 접근할 수 있다. **기본 인증은 이러한 재전송 공격을 예방하기 위한 어떤 일도 하지 않는다.**
3. 기본 인증이 회사의 인트라넷 접근 제어나 개인화된 콘텐츠 같이 보안이 뚫리더라도 치명적이지 않은 애플리케이션에 사용된다 하더라도, 일반 사용자들의 웹 사이트들을 사용하는 행태에 비추어 이것은 굉장히 위험한 것이 된다.
4. 메시지의 인증 헤더를 건드리진 않지만, **그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않는다.**
5. **기본 인증은 가짜 서버의 위장에 취약하다.** 사용자가 가짜 서버나 가짜 게이트에 연결되어 있는데도, 사용자는 기본 인증을 수행하는 검증된 서버에 연결되어 있다고 믿고 있다면, 공격자는 사용자에게 비밀번호를 요청하고 그것을 나중에 사용할 목적으로 저장한 다음 에러가 난 척을 할 것이다.

기본 인증은 사용자 이름과 비밀번호를 악의적인 개인들에게 숨기려고 암호화된 데이터 전송(SSL 같은)과 함께 연계해서 사용할 수 있다. 이는 널리 사용하는 기술이다.