# 11장. 클라이언트 식별과 쿠키
웹 서버는 서로 다른 수천 개의 클라이언트들과 동시에 통신한다. 이 서버들은 익명의 클라이언트로부터 받는 모든 요청을 처리하는 것뿐만 아니라 서버와 통신하고 있는 클라이언트를 추적해야 할 수도 있다.

## 개별 접촉
**HTTP는 익명으로 사용하며 상태가 없고 요청과 응답으로 통신하는 프로토콜이다.** 서버는 클라이언트가 보낸 요청을 처리하고 나서 그 응답을 클라이언트로 전송한다. 웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.

- 개별 인사: 온라인 쇼핑이 개인에게 맞춰져 있는 것처럼 느끼게 하려고 사용자에게 특화된 환영 메시지나 페이지 내용을 만든다.
- 사용자 맞춤 추천: 고객의 흥미를 학습하여 좋아할 것으로 예상되는 제품을 추천할 수 있다.
- 저장된 사용자 정보: 쇼핑을 편하게 할 수 있게 저장된 사용자 정보를 사용할 수 있다.
- 세션 추적: 위와 같은 사이트와의 상호작용을 위해서는 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요하다.
  - 사용자 식별 관련 정보를 전달하는 HTTP 헤더
  - IP 주소로 사용자를 식별
  - 사용자 로그인 인증을 통한 사용자 식별
  - URL에 식별자를 포함하는 기술인 뚱뚱한 URL
  - 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술인 쿠키

## HTTP 헤더
다음은 사용자에 대한 정보를 전달하는 가장 일반적인 HTTP 요청 헤더다.

|헤더 이름|헤더 타입|설명|
|--|--|--|
|Form|요청|사용자의 이메일 주소|
|User-Agent|요청|사용자의 브라우저|
|Referer|요청|사용자가 현재 링크를 타고 온 근원 페이지|
|Authorization|요청|사용자 이름과 비밀번호|
|Client-ip|확장|클라이언트의 IP 주소|
|X-Forwarded-For|확장|클라이언트의 IP 주소|
|Cookie|확장|서버가 생성한 ID 라벨|

- Form 헤더에는 사용자 이메일 주소를 포함한다. 악용될 여지가 있어 Form 헤더를 보내는 브라우저는 많지 않다. 로봇이나 스파이더는 웹 사이트에 항의메일을 보낼 수 있도록 Form 헤더에 이메일 주소를 기술한다.
- User-Agent 헤더는 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 운영체제에 대한 정보를 포함한다.
- Referer 헤더는 유입하게 한 웹페이지의 URL을 가리킨다. 사용자 자체 식별은 불가하지만 사용자의 취향을 파악하는데 도움을 준다.

## 클라이언트 IP 주소
클라이언트 IP 주소로 사용자를 식별하는 방식은 다음과 같은 약점을 가지고 있다.

- 클라이언트 IP는 사용자가 아닌, 사용자가 사용하는 컴퓨터를 가리킨다.
- 동적으로 IP 주소를 할당 받을 경우 사용자는 매번 새로운 IP 주소를 할당 받는다.
- 보안을 강화하고 부족한 주소들을 관리하기 위해 많은 사용자가 네트워크 주소 변환(NAT) 방화벽을 통해 인터넷을 사용한다. 이 장비들은 클라이언트의 실제 IP 주소를 방화벽 뒤로 숨기고, 클라이언트의 실제 IP 주소를 내부에서 사용하는 하나의 방화벽 IP 주소로 변환한다.
- HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 한다. 웹 서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP 주소를 본다. 일부 프락시는 원본 IP 주소를 보존하려고 Client-ip나 X-Forwarded-For HTTP 같은 확장 헤더를 추가하여 이 문제를 해결하려 했으나, 모든 프락시가 이런 식으로 동작하진 않는다.

## 사용자 로그인
웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다. 웹 사이트 로그인이 더 쉽도록 HTTP는 WWW-Authenticate 와 Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다. 한번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 웹 서버는 그 로그인 정보는 항상 확인할 수 있다.

서버에서 사용자가 사이트에 접근하기 전에 로그인을 시키고자 한다면 401 Login Required 응답 코드를 브라우저에 보낼 수 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/5d2fbe6d-2219-49fa-8da8-41725fb9a6f5)

## 뚱뚱한 URL
보통 URL은 URL 경로의 처음이나 끝에 어떤 상태 정보를 추가해 확장한다. 사용자가 그 사이트를 돌아다니면, 웹 서버는 URL에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성한다.

사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL이라 한다. 웹 서버와 통신하는 독립적인 HTTP 트랜잭션을 하나의 '세션' 혹은 '방문'으로 묶는 용도로 뚱뚱한 URL을 사용할 수 있다. 사용자가 웹 사이트에 처음 방문하면 유일한 ID가 생성되고, 그 값은 서버가 인식할 수 있는 방식으로 URL에 추가되며, 서버는 클라이언트를 이 뚱뚱한 URL로 리다이렉트 시킨다. 서버가 뚱뚱한 URL을 포함한 요청을 받으면, 사용자 아이다와 관련된 추가적인 정보를 찾아 밖으로 향하는 모든 하이퍼링크를 뚱뚱한 URL로 바꾼다.

이 URL은 사이트를 브라우징하는 사용자를 식별하는데 사용할 수 있지만, 뚱뚱한 URL은 다음과 같은 문제점이 있다.

- 못생긴 URL: 뚱뚱한 URL은 사용자에게 혼란을 준다.
- 공유하지 못하는 URL: 뚱뚱한 URL은 사용자와 세션에 대한 상태 정보를 포함한다. 공유시 정보 노출에 위험이 있다.
- 캐시를 사용할 수 없음: URL이 달라지기 때문에 기존 캐시에 접근할 수 없다.
- 서버 부하 가중: 서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 한다.
- 이탈: 의도치 않게 뚱뚱한 URL 세션에서 이탈했을때 이전 정보가 초기화된다.
- 세션 간 지속성의 부재: URL을 북마킹하지 않는 이상 로그아웃하면 모든 정보를 잃는다.

## 쿠키
