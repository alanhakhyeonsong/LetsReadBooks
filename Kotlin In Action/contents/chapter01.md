# 1장. 코틀린이란 무엇이며, 왜 필요한가?
Kotlin은 Java 플랫폼에서 돌아가는 새로운 프로그래밍 언어다.

- 간결하고 실용적이며, Java 코드와의 상호운용성을 중시한다.
- Java가 사용 중인 곳이라면 거의 대부분 Kotlin을 활용할 수 있다.
  - ex) 서버 개발, 안드로이드 앱 개발 등

## 코틀린 맛보기
```kotlin
data class Person(val name: String, // 데이터 클래스
                  val age: Int? = null) // null이 될 수 있는 타입과 파라미터 디폴드 값

fun main(args: Array<String>) {
    val persons = listOf(Person("영희"),
                         Person("철수", age = 29)) // 이름 붙인 파라미터
    
    val oldest = persons.maxBy { it.age ?: 0 } // 람다 식과 앨비스 연산자
    println("나이가 가장 많은 사람: $oldest") // 문자열 템플릿
}

// 결과: 나이가 가장 많은 사람: Person(name=철수, age=29) // toString 자동 생성
```

## 코틀린의 주요 특성
### 대상 플랫폼: 서버, 안드로이드 등 자바가 실행되는 모든 곳
Kotlin의 주 목적은 **현재 Java가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생상적이며 안전한 대체 언어를 제공하는 것**이다.

Kotlin을 도입하면 **더 적은 코드로 더 편하게** 프로그래머의 목표를 달성할 수 있을 것이다.

- 서버 상의 코드 (웹 애플리케이션의 백엔드)
- 안드로이드 디바이스에서 실행되는 모바일 애플리케이션

참고로 Kotlin은 JavaScript로도 컴파일할 수 있다. Kotlin 1.1 부터는 JavaScript를 공식적으로 지원한다.

### 정적 타입 지정 언어
Java와 마찬가지로 Kotlin도 정적 타입 지정 언어다.

- 정적 타입 지정 언어?
  - 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증해준다는 뜻이다.
  - Java와 달리 Kotlin에서는 모든 변수의 타입을 프로그래머가 직접 명시할 필요가 없다. 대부분의 경우 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추할 수 있기 때문에 프로그래머는 타입 선언을 생략해도 된다. (ex. `val num = 1`)
    - 이런 기능을 **타입 추론**이라 부른다.
- 동적 타입 지정 언어?
  - 타입에 관계없이 모든 값을 변수에 넣을 수 있다.
  - 메서드나 필드 접근에 대한 검증이 실행 시점에 일어난다. 그 결과 코드가 더 짧아지고 데이터 구조를 더 유연하게 생성하고 사용할 수 있다.
  - 이름을 잘못 입력하는 등의 실수를 컴파일 시 걸러내지 못하고 실행 시점에 오류가 발생한다.

정적 타입 지정의 장점은 다음과 같다.

- 성능: 실행 시점에 어떤 메서드를 호출할지 알아내는 과정이 필요 없으므로 메서드 호출이 더 빠르다.
- 신뢰성: 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 적어진다.
- 유지 보수성: 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때도 더 쉽다.
- 도구 지원: 정적 타입 지정을 활용하면 더 안전하게 리팩토링 할 수 있고, 도구는 더 정확한 코드 완성 기능을 제공할 수 있으며, IDE의 다른 지원 기능도 더 잘 만들 수 있다.

Kotlin의 타입 시스템을 더 자세히 살펴보면 class, interface, generics는 모두 Java와 비슷하게 작동한다는 사실을 발견할 수 있다. 하지만 몇 가지 새로운 점이 있다.

- **nullable type을 지원한다.**
  - 컴파일 시점에 널 포인터 예외가 발생할 수 있는지 여부를 검사할 수 있어 좀 더 프로그램의 신뢰성을 높일 수 있다.
- **function type을 지원한다.**

### 함수형 프로그래밍과 객체지향 프로그래밍
함수형 프로그래밍의 핵심 개념은 다음과 같다.

- 일급 시민(first-class) 함수: 함수를 일반 값처럼 다룰 수 있다.
  - 함수를 변수에 저장,
  - 함수를 인자로 다른 함수에 전달
  - 함수에서 새로운 함수를 만들어서 반환
- 불변성(immutability): 함수형 프로그래밍에서는 불변 객체를 사용해 프로그램을 작성한다.
- 부수 효과(side effect) 없음
  - 입력이 같으면 항상 같은 출력
  - 다른 객체의 상태를 변경하지 않는다.
  - 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용

함수형 스타일로 프로그램을 작성하면 어떤 유익이 있을까?

- 간결성
  - 함수를 값처럼 활용할 수 있으면 더 강력한 추상화를 할 수 있고 이를 사용해 코드 중복을 막을 수 있다.
  - 공통부분을 따로 함수로 뽑아내고 서로 다른 세부 사항을 인자로 전달할 수 있다. 이런 인자는 그 자체가 함수다.

```kotlin
fun findAlice() = findPerson { it.name == "Alice" }
fun findBob() = findPerson { it.name == "Bob" }
```

- 다중 스레드에서 안전하다.
  - 불변 데이터 구조를 사용하고 순수 함수를 그 데이터 구조에 적용한다면 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없다. 따라서 복잡한 동기화를 적용하지 않아도 된다.
- 테스트하기 쉽다.
  - 순수 함수는 준비 코드(setup code)없이 독립적으로 테스트할 수 있다.

Java 8 이전의 Java에는 함수형 프로그래밍을 지원할 수 있는 기능이 거의 없었다. 반면 Kotlin은 처음부터 함수형 프로그래밍을 풍부하게 지원해왔다.

- 함수 타입을 지원함에 따라 어떤 함수가 다른 함수를 파라미터로 받거나 함수가 새로운 함수를 반환할 수 있다.
- 람다 식을 지원함에 따라 번거로운 준비 코드를 작성하지 않아도 코드 블록을 쉽게 정의하고 여기저기 전달할 수 있다.
- 데이터 클래스는 불변적인 값 객체(value object)를 간편하게 만들 수 있는 구문을 제공한다.
- Kotlin 표준 라이브러리는 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API를 제공한다.

## 코틀린 응용
- Java 코드와 매끄럽게 상호운용할 수 있다는 점이 Kotlin의 큰 장점이다.
  - Java 클래스를 Kotlin으로 확장해도 아무 문제가 없으며 Kotlin 클래스 안의 메서드나 필드에 특정 Java 애노테이션을 붙어야 하는 경우에도 아무 문제가 없다.
- Kotlin의 빌더 패턴을 활용하면 간결한 구문을 사용해 객체가 이뤄진 그래프를 쉽게 구축하면서도 Kotlin이 제공하는 완전한 추상화와 코드 재활용을 지속적으로 누릴 수 있다.
- DSL 기능

## 코틀린의 철학
Kotlin은 Java와의 상호운용성에 초점을 맞춘 실용적이고 간결하며 안전한 언어다.

- 실용성: 실제 문제를 해결하기 위해 만들어진 실용적인 언어
  - Kotlin은 연구를 위한 언어가 아니다. 최신 프로그래밍 언어 설계를 앞서 채택하거나 전산학계에서 연구 중인 혁신적인 아이디어를 Kotlin을 통해 탐구하려고 하지 않는다. 대신 Kotlin은 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존한다. 언어의 복잡도가 줄어들고 이미 알고 있는 기존 개념을 통해 Kotlin을 더 쉽게 배울 수 있다.
  - Kotlin은 다른 프로그래밍 언어가 채택한 검증된 해법과 기능에 의존하기 때문에 언어의 복잡도가 줄어들고 언어를 쉽게 배울 수 있다.
  - 패러다임을 사용할 것을 강제로 요구하지 않는다. Java에서 사용해 온 익숙한 프로그래밍 스타일이나 기법을 활용할 수 있다
- 간결성: 어떤 언어가 간결하다는 말은 그 언어로 작성된 코드를 읽을 때 의도를 쉽게 파악할 수 있는 구문 구조를 제공하고, 그 의도를 달성하는 방법을 이해할 때 방해가 될 수 있는 부가적인 준비 코드가 적다는 뜻이다.
  - 게터, 세터, 생성자 파라미터를 필드에 대입하기 위한 로직 등 Java에 존재하는 여러 가지 번거로운 준비 코드를 Kotlin은 묵시적으로 제공한다. Kotlin 소스 코드는 그런 준비 코드로 인해 지저분해지는 일이 없다.
  - Kotlin은 람다를 지원하기 때문에 작은 코드 블록을 라이브러리 함수에 쉽게 전달할 수 있다.
  - 코드가 더 간결하면 쓰는 데 시간이 덜 걸린다. 더 중요한 것은 읽는 데도 시간이 덜 걸린다는 점이다.
- 안정성: 프로그래밍 언어가 안전하다는 말은 프로그램에서 발생할 수 있는 오류 중에서 일부 유형의 오류를 프로그램 설계가 원천적으로 방지해준다는 뜻
  - 안정성과 생산성 사이에는 트레이드오프 관계가 성립 (안정성을 높이면 생산성이 떨어지고, 생산성을 높이면 안정성이 떨어짐)
  - Kotlin을 JVM에서 실행 → 상당한 안정성 보장
    - JVM을 사용하면 메모리 안정성 보장, 버퍼 오버플로를 방지, 동적으로 할당한 메모리를 잘못 사용함으로써 발생할 수 있는 다양한 문제 예방
    - Kotlin은 타입 안정성을 보장
  - Kotlin은 프로그램의 NullPointerException 없애기 위해 노력함
    - Kotlin의 타입 시스템은 null이 될 수 없는 값을 추적하며, 실행 시점에 NullPointerException이 발생할 수 있는 연산을 사용하는 코드를 금지한다.
  - Kotlin은 ClassCastException을 방지해준다.
    - 어떤 객체의 타입을 검사했고 그 객체가 그 타입에 속한다면 해당 타입의 메서드나 필드 등의 멤버를 별도의 캐스트 없이 사용할 수 있다.

```kotlin
val s: String? = null // null이 될 수 있음
val s2: String = "" // null이 될 수 없음

if (value is String) // 타입을 검사한다.
    println(value.toUpperCase()) // 해당 타입의 메서드를 사용한다.
```

- 상호운용성
  - Java 코드에서 Kotlin 코드를 호출할 때도 아무런 노력이 필요 없다.
  - 기존 Java 라이브러리를 가능하면 최대한 활용한다.
  - Kotlin은 자체 컬렉션 라이브러리를 제공하지 않고, Java 표준 라이브러리 클래스에 의존한다.

## 코틀린 도구 사용
Java와 마찬가지로 Kotlin도 컴파일 언어다. 따라서 Kotlin 코드를 실행하기 전에 먼저 코드를 컴파일해야만 한다.

### 코틀린 코드 컴파일
Kotlin 소스코드를 저장할 때는 보통 `.kt`라는 확장자를 파일에 붙인다. 코틀린 컴파일러는 자바 컴파일러가 Java 소스코드를 컴파일할 때와 마찬가지로 Kotlin 소스코드를 분석해서 `.class` 파일을 만들어낸다. 만들어진 `.class` 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 패키징 과정을 거쳐 실행될 수 있다.

가장 간단한 방식은 커맨드라인에서 `kotlinc` 명령을 통해 Kotlin 코드를 컴파일한 다음 `java` 명령으로 그 코드를 실행하는 것이다.

```bash
kotlinc <소스파일 또는 디렉터리> -include-runtime -d <jar 이름>
java -jar <jar 이름>
```

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/e6f52d9e-248f-4ec0-9a9f-d4a11c3ea326)

코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리에 의존한다. 런타임 라이브러리는 Kotlin 자체 표준 라이브러리 클래스와 Kotlin에서 Java API의 기능을 확장한 내용이 들어있다. Kotlin으로 컴파일한 애플리케이션을 배포할 때는 런타임 라이브러리도 함께 배포해야 한다.