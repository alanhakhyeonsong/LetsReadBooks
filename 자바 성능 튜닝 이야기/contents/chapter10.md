# Story 10. 로그는 반드시 필요한 내용만 찍자.
어떤 시스템을 개발하든 코딩을 하면 반드시 로그를 남겨야 한다. 로그를 남기는 방법에는 여러 가지가 있겠지만, 일반적으로 시스템 로그(`System.out.println`)나 Log4j 혹은 JDK 로거를 많이 사용한다. 어떤 로거를 사용하든 모두 성능상 이슈가 발생할 수 있다. 그 이유를 알아보자.

## System.out.println()의 문제점
대부분의 개발자들은 로그를 찍기 위해 `System.out.println()`을 사용한 시스템 로그를 많이 사용한다. 가장 편하고, 확인하기 좋은 방법이지만 성능에 영향을 많이 주는 경우가 빈번히 발생한다.

부하 상황에서 해당 메서드로 로그를 출력하다 보면, 특히 커널 CPU를 많이 사용하게 된다. 해당 메서드를 사용하는 라인만 지워도 응답 시간에 대해 상당한 개선이 이루어진다. 왜 그럴까?

파일이나 콘솔에 로그를 남길 경우를 생각해보면, 내용이 완전히 프린트되거나 저장될 때까지, 뒤에 프린트하려는 부분은 대기할 수 밖에 없다. 특히 콘솔에 로그를 남길 경우에는 더더욱 그렇다. 그렇게 되면 애플리케이션에선 대기 시간이 발생한다. 이 대기 시간은 시스템의 속도에 의존적이다. 만약 디스크에 로그를 남긴다면 서버 디스크의 RPM이 높을수록 로그의 처리 속도는 빨라질 것이다.

더 큰 문제는 `System.out.println()`으로 출력하는 로그가 개발할 때만 사용된다는 것이다. 운영할 때는 전혀 사용되지 않고, 볼 수도 없는 디버그용 로그를 운영 서버에서 고스란히 처리하고 있는 셈이다. 즉, 의미 없는 디버그용 로그를 프린트하기 위해 아까운 서버의 리소스와 디스크가 낭비된다는 것이다. 또한 많은 서비스들이 통계성 데이터를 로그에 쌓고 처리하려 한다. 적절한 로거를 사용해서 데이터를 쌓는 것이 훨씬 좋은 방법이다.

## System.out.format() 메서드
JDK 5.0의 `System` 클래스에서 사용하는 `out` 객체 클래스인 `PrintStream`에 새로 추가된 메서드가 하나 있다. 바로 `format()`인데, 이는 C에서 프린트하던 방식으로 처리할 수 있어 소스가 더 간결해진다.

- `format(String format, Object... args)`: 지정된 포맷으로 프린트를 한다. 뒤에 있는 매개변수를 쉼표로 나열하도록 되어 있다.
- `format(Locale l, String format, Object... args)`: 위와 동일하되 가장 앞에 지역 정보를 포함한다. 지역에 따라 다른 형태의 데이터를 프린트할 수 있다.

`String`을 더해서 처리하는 것과 `Formatter`를 사용하는 것을 비교해보면, 후자가 훨씬 느리다. 해당 코드를 컴파일한 뒤 역컴파일 해보면 이해할 수 있다.

`String`을 더하는 문장은 `StringBuilder`의 `append()`를 사용한다. 한편 `format()`을 사용하는 문장은 새로운 `Object` 배열을 생성하여 그 값을 배열에 포함 시키도록 되어 있다. 게다가 primitive 타입을 `Object` 형태로 나타내기 위해 각 `Wrapper` 타입의 `valueOf()`를 사용한다.

실제 `String.format()`의 내부를 보면 `java.util` 패키지에 있는 `Formatter` 클래스를 호출한다. 이는 `%`가 들어가 있는 format 문자열을 항상 파싱하기 때문에 문자열을 그냥 더하는 것보다 성능이 좋을 수 없다.

## 로거 사용 시의 문제점
컴파일 시에 로그를 제거하는 방법을 사용하지 않는 한, 로그를 프린트하든 하지 않든, 로그를 삭제하기 위한 한 줄을 처리하기 위해서는 어차피 객체를 생성해야 한다. 즉 운영 시 로그 레벨을 올려 놓는다고 해도, 디버그용 로그 메시지는 간단한 문자든 간단한 쿼리든 상관 없이 하나 이상의 객체가 필요하다. 그러면 그 객체를 생성하는 데 메모리와 시간이 소요된다. 또한 메모리에서 제거하기 위해선 GC를 수행해야 하고, GC 수행 시간이 또 소요된다.

가장 좋은 방법은 디버그용 로그를 제거하는 것이다. 로그 처리 여부를 처리하는 것이 좋다.

```java
if (logger.isLoggable(Level.INFO)) {
    // 로그 처리
}
```

위와 같이 조건문으로 처리하면 로그를 위한 불필요한 메모리 사용을 줄일 수 있어, 더 효율적으로 메시지를 처리할 수 있다.

또한 로그를 처리하는 데 발생할 수 있는 문제점을 해결하는 데 도움을 주는 slf4j라는 로거가 있다.

## 로그를 깔끔하게 처리해주는 slf4j와 LogBack
> Simple Logging Facade for Java (SLF4J)

즉, 간단히 로그를 처리해 주는 프레임워크라 보면 된다.

기존의 로거들은 출력을 위해 문자열을 더해 전달해 줘야만 했다. 하지만 slf4j는 format 문자열에 중괄호를 넣고, 그 순서대로 출력하고자 하는 데이터들을 콤마로 구분하여 전달해준다. 이렇게 전달해주면 로그를 출력하지 않을 경우 필요 없는 문자열 더하기 연산이 발생하지 않는다.

게다가 slf4j는 Java의 기본 로거를 비롯하여 Log4j, Apache commons logging 등과 연계하여 사용할 수 있도록 되어 있다. 추가로 LogBack은 예외의 스택 정보를 출력할 때 해당 클래스가 어떤 라이브러리를 참고하고 있는지도 포함하여 제공하기 때문에 쉽게 관련된 클래스를 확인할 수 있다.

## 예외 처리는 이렇게
예외 처리할 때도 성능에 많은 영향을 줄 수 있다. 일반적으론 다음과 같이 처리한다.

```java
try {
    // ...
} catch (Exception e) {
    e.printStackTrace();
}
```

예외가 발생하여 `e.printStackTrace()`를 호출하게 되면 스택 정보를 확인하고, 확인된 정보를 콘솔에 프린트한다. 이 로그는 알아보기 힘들다. 왜냐하면 여러 스레드에서 콘솔에 로그를 프린트하면 데이터가 섞이기 때문이다. Java의 예외 스택 정보는 로그를 최대 100개까지 프린트하기 때문에 서버의 성능에도 많은 부하를 준다. 스택 정보를 가져오는 부분에서는 거의 90% 이상이 CPU를 사용하는 시간이고, 나머지 프린트하는 부분에선 대기 시간이 소요된다.

차라리 `logger.severe()`를 적절하게 조합해서 사용하던지, 임의로 만든 예외 클래스에서 원하는 스택 정보를 가공하여 메시지 처리를 하는 것이 좋다.

참고로 `StackTraceElement` 배열의 0번째에는 예외가 발생한 클래스 정보가 있으며, 마지막에는 최초 호출된 클래스의 정보가 있다. 일반적인 WAS에선 WAS 관련 클래스 정보가 포함될 것이므로, 우리들이 만든 프로그램만 필터링 되게 하면 더 깔끔하게 에러 로그를 정리할 수 있을 것이다.