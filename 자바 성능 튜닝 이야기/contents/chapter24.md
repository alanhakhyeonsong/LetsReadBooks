# Story 24. 애플리케이션에서 점검해야 할 대상들
## 패턴과 아키텍처는 잘 구성되어 있는가?
- 너무 많은 패턴을 사용하지 않았는가?  
  패턴은 애플리케이션을 구성할 때 반드시 적용해야 한다. 하지만, 너무 많은 패턴을 적용하면 유지보수성이 떨어지고, 문제가 발생했을 때 추적하기가 어려워진다. 좋은 패턴이라고 무작정 적용하기보단 꼭 필요한 패턴만을 사용해야 한다.
- 데이터를 리턴할 때 TO(or VO) 패턴을 사용했는가? 아니면 Collection 관련 클래스를 사용했는가?  
  데이터를 주고 받는 시간을 절약하기 위해 일반적으로 TO 패턴을 사용한다. 때에 따라선 Collection 관련 클래스를 사용하기도 한다. 패턴을 적용하지 않거나 관련 표준을 정하지 않고 개발할 경우 시스템의 응답 시간도 영향이 있겠지만, 유지 보수성이 떨어진다. `HashMap`으로 데이터를 주고 받으면, 소스를 완전히 뜯어 보지 않는 이상 개발자만 어떤 키와 값이 들어 있는지 알게 된다.
- 서비스 로케이터 패턴은 적용이 되어 있는가?  
  서비스 로케이터 패턴을 사용하면 애플리케이션에서 필요한 대상을 찾는 lookup 작업 시 소요되는 대기 시간을 줄일 수 있다. 만약 서버의 CPU 사용량이 높지 않을 때 응답 속도가 느리다면 이 패턴을 적용해야 하는 부분이 있지 않은가 한 번쯤 확인을 해봐야 한다.

## 기본적인 애플리케이션 코딩은 잘 되어 있는가?
- 명명 규칙은 잘 지켰는가?
- 필요한 부분에 예외 처리는 되어 있는가?
- 예외 화면은 지정되어 있는가?
- 예외 정보를 `e.printStackTrace()`로만 처리하고 있지 않은가?
  - 서버에서 스택 정보를 취합하여야 하기 때문에 서버에 많은 부하가 발생하게 된다.
- `System.gc()` 메서드가 소스에 포함되어 있지 않은가?
- `System.exit()` 메서드가 소스에 포함되어 있지 않은가?
- 문자열을 계속 더하도록 코딩하진 않았는가?
- `StringBuffer`나 `StringBuilder` 클래스도 제대로 사용했는가?
- 무한 루프가 작동할 만한 코드는 없는가?
- `static`을 남발하진 않았는가?
- 필요한 부분에 `synchronized` 블록을 사용하였는가?
- I/O가 계속 발생하도록 개발되어 있진 않은가?
- 필요 없는 로그는 다 제거했는가?
  - '로그 레벨이 DEBUG가 아니니 괜찮겠지' 하는 생각은 버려라. 프린트하지도 않을 로그 데이터를 문자열로 만들기 위해 아까운 메모리를 사용하고, 그 메모리를 청소하기 위해 GC를 해야 하는 불쌍한 JVM을 생각하자.
- 디버그용 `System.out.println()`은 다 제거했는가?

## 웹 관련 코딩은 잘 되어 있는가?
- JSP의 `include`는 동적으로 했는가? 아니면 정적으로 했는가?
- 자바 빈즈는 너무 많이 사용하지 않았나?
- 태그 라이브러리는 적절하게 사용했나?
- EJB는 적절하게 사용했나?
- 이미지 서버를 사용할 수 있는 환경인가?
- 사용 중인 프레임워크는 검증되었는가?

## DB 관련 코딩은 잘 되어 있는가?
- 적절한 JDBC 드라이버를 사용하는가?
- DB Connection, `Statement`, `ResultSet`는 잘 닫았는가?
- DB Connection Pool은 잘 사용하고 있는가?
- 자동 커밋 모드에 대한 고려는 하였는가?
  - 기본 커밋 모드는 자동 커밋으로 되어 있다. 조회성 프로그램도 자동 커밋 여부를 지정하게 되면, 약간의 응답 시간 저하가 발생하게 된다.
- `ResultSet.last()`를 사용하였는가?
- `PreparedStatements`를 사용하였는가?

## 서버의 설정은 잘 되어 있는가?
- Java VM 관련 옵션들은 제대로 설정되어 있는가?
  - 64bit 기반의 시스템을 사용하면서 `-d64` 옵션을 사용하지 않는다면, 그냥 32bit로 시스템이 운영된다.
  - 클래스 패스는 순차적으로 인식된다. 여러 JAR 파일 중 만약 같은 패키지명에 같은 클래스가 존재할 경우 앞에 명시한 클래스 패스에 우선권이 있다.
- 메모리는 몇 MB로 설정해 놓았는가?
  - 설정하지 않으면 서버는 기본 64MB로 시작한다는 사실을 반드시 기억하자.
- GC 설정은 어떻게 되어 있는가?
  - `-client`로 설정되어 있는지 확인해보자.
  - GC 방식에 따라 서버의 성능이 엄청난 차이가 발생할 수 있다.
- 서버가 운영 모드인지, 개발 모드인지 확인하였는가?
  - 서버가 개발 모드라면, WAS는 주기적으로 변경된 클래스가 있는지 확인할 것이다. 이 작업은 서버에 많은 부하를 주게 된다.
- WAS의 인스턴스가 몇 개 기동되고 있는가?
- JSP Precompile 옵션을 지정해 놓았는가?
- DB Connection Pool 개수와 스레드 개수는 적절한가?
- 세션 타임아웃 시간은 적절한가?
- 검색 서버가 있다면, 검색 서버에 대한 설정 및 성능 테스트를 하였는가?
  - 일반적으로 검색 서버에서 주기적으로 데이터를 모으기 위해 서버의 리소스를 많이 사용하게 된다.
  - 검색 서버의 세팅을 점검하고, 성능 테스트를 지속적으로 해보자.

## 모니터링은 어떻게 하고 있는가?
- 웹 로그는 남기고 있는가?
- `verbosegc` 옵션은 남기고 있는가?
  - GC가 어떤 형태로 발생하는지를 확인하고자 한다면, 반드시 이 옵션을 사용하여 로그를 남기자.
  - 메모리의 크기를 지정하기 위해서나 GC 옵션을 변경하기 위해 매우 유용하게 활용될 것이다.
  - GC 튜닝을 하지 않을 시스템에 이 옵션을 남기는 것은 리소스 낭비다.
- 각종 로그 파일에 대한 규칙은 있는가?
  - 로그 파일이 그냥 몇 기가바이트씩 쌓이고 있지 않은가?
  - 일별로 로그를 쌓도록 옵션을 지정하면, 특정 이슈가 발생한 날짜의 데이터를 분석하기에도 좋고 백업을 하기에도 편리하다.
- 서버의 시스템 사용률은 로그로 남기고 있는가?
  - WAS나 DB가 얼마나 사용을 하고 있는지 로그를 남겨야 한다.
  - SMS나 APM을 사용하지 않은 사이트에선 서버의 사용량을 유닉스의 `vmstat`이나 `sar` 명령어를 사용해서 남겨야 시간대별 서버 사용량을 구할 수 있다. 이 데이터는 나중에 서버를 증설할 때도 매우 유용하게 사용된다.
- 모니터링 툴은 사용 중인가?
- 모니터링 툴에 대한 설정은 적절하게 되어 있는가?
- 서버에 갑자기 코어 덤프를 발생시키지 않는가?
  - 10,000건 이상 조회하는 것이 있나 확인해야 한다. 한꺼번에 많은 양의 데이터를 처리하려면 많은 메모리가 필요한데, 이 때 코어 덤프가 발생할 수 있다. 데이터를 처리하는데 필요한 메모리가 지정된 메모리 크기보다 클 수도 있기 때문이다.
  - 메모리 릭이 있는지 확인해야 한다. 메모리를 점유하고 해제하지 않는 로직이 있으면 서버를 매일 재기동해도 메모리는 점차적으로 부족해진다. 서버가 기동된 후 힙 덤프를 받아 놓은 뒤, 운영 중과 운영 후에 각각 덤프를 받아서 메모리 사용량의 추이를 확인해야 한다.
- 응답 시간이 너무 느리지 않은가?
  - WAS단 이후에서 느린 것인지?
  - 그 이전 단계인 네트워크나 웹 서버에서 느린 것인지?