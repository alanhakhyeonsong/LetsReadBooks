# Story 14. 서버를 어떻게 세팅해야 할까?
## 설정해야 하는 대상
개발하는 것만큼 중요한 것이 서버의 세팅이다. 개발된 프로그램이 0.1초 걸린다고 해도 서버 세팅을 잘못하면 1초가 걸릴 수도 있고, 10초가 걸릴 수 있다. 이러한 문제를 진단하는 가장 좋은 방법은 성능 테스트를 통해 병목 지점을 미리 파악하는 것이다. 애플리케이션 위주로 무작정 병목을 찾는 것보다, 일단 문제가 될만한 세팅 값을 먼저 진단하도록 하자.

- 웹 서버 세팅
- WAS 서버 세팅
- DB 서버 세팅
- 장비 세팅

## 아파치 웹 서버의 설정
**WAS를 웹 서버로 사용하면 안 된다. 웹 서버는 반드시 WAS 앞에 두어야 한다. 왜냐하면 WAS는 Web Application Server이기 때문이다.** 웹에서 사용하는 서버지 웹 서버가 아니다. 정적인 부분은 웹 서버에서 처리해야 한다. 그렇지 않으면 WAS 서버에서 웹 서버의 역할까지 수행해야 해서 WAS 서버의 스레드를 점유하게 되기 때문이다. 반드시 상용 웹 서버나 아파치 웹 서버를 WAS 앞 단에 두고 운영해야 한다.

아파치 웹 서버에서 성능에 영향을 줄 수 있는 세팅을 살펴보자.

아파치 웹 서버는 MPM(Multi-Processing Module)을 사용하는데, 여러 개의 프로세싱 모듈 기반의 서비스를 제공한다는 의미다. 가장 쉽게 아파치 웹 서버의 설정을 바꾸는 방법은, 설치 폴더 하단의 `conf` 디렉터리에 있는 `httpd.conf` 파일을 수정하는 것이다.

```
...
ThreadsPerChild 250
MaxRequestsPerChild 0
...
```

- **`ThreadsPerChild`는 웹 서버가 사용하는 스레드의 개수를 지정한다.** 이 수치를 늘리면 서버가 더 많은 사용자의 요청을 처리할 수 있게 된다.
- **`MaxRequestsPerChild`는 최대 요청 개수를 지정하는 부분이다.** 0이면 그 수에 제한을 두지 않겠다는 의미이며 이 값을 10으로 둔다면, 그 이상의 처리는 하지 않게 된다. 가급적 기본값인 0으로 사용하자.

스레드와 관련된 내용을 보다 세밀하게 지정하려면 `httpd.conf` 파일에서 `#`으로 주석 처리된 `include conf/extra/httpd-mpm.conf`를 찾아 주석을 해제한다. 이렇게 하면 세밀한 스레드 설정 정보를 `httpd-mpm.conf`를 통해 지정할 수 있게 된다. 스레드 방식을 사용하기 위해선 `worker` 부분을 수정해 주어야 한다.

```
...
<IfModule mpm_worker_module>
StartServers 2
MaxClients 150
MinSpareThreads 25
MaxSpareThreads 75
ThreadsPerChild 25
MaxRequestsPerChild 0
</IfModule>
...
```

- `StartServers`: 서버를 띄울 때 프로세스의 개수를 지정한다. 보통 이야기하는 child 프로세스의 개수를 말한다.
- `MaxClients`: 최대 처리 가능한 클라이언트의 수를 지정한다.
- `MinSpareThreads`: 최소 여유 스레드 수를 지정한다.
- `MaxSpareThreads`: 최대 여유 스레드 수를 지정한다.
- `ThreadsPerChild`: 프로세스당 스레드 수를 지정한다.
- `MaxRequestsPerChild`: 앞서 이야기한 `MaxRequestsPerChild`와 같은 의미다.

```
최대 가능한 요청 = 프로세스 수 * 프로세스 당 스레드 수
최대 사용 가능한 클라이언트 수 = 프로세스 수 * 최대 여유 스레드
```

위 예시에선 최대 150명의 요청을 처리할 수 있고 그 이상의 요청은 서버 리소스에 여유가 있어도 처리를 하지 않는다.

만약 이 설정 상 사용자가 늘어나거나 WAS가 멈추면 어떻게 될까?  
초당 150명 요청을 웹 서버에서 받고, 그 요청을 전달받은 WAS도 150명의 요청을 받는다. 자바는 GC를 할 때 JVM 자체가 멈춘다. 만약 GC가 2초 걸리면 아파치 웹 서버에 총 300명의 요청이 기다리게 될 것이다. **GC를 하는 동안 WAS가 멈추기 때문에 새로운 연결을 할 수 없다.** 이 경우 Tomcat에선 AJP Connector라는 웹 서버와 WAS 사이의 커넥터에 설정한 backlog라는 값의 영향을 받는다. 만약 이 값을 설정하지 않으면 기본 값은 100이다.

즉, WAS가 응답하지 않을 때 100개의 요청까지 큐에 담아둔다. 이 100개를 넘는 요청들은 503 HTTP Status를 리턴받게 된다. 이러한 값을 받지 않으려면 다음과 같은 조치를 취하는 것이 좋다.

1. 서버를 늘린다: 가장 편한 방법이다. 비용의 여유가 있을 때 적용하자.
2. 서비스를 튜닝한다: 서비스가 응답이 안 되는 원인을 찾고 튜닝한다.
3. GC 튜닝을 한다: 만약 GC가 오래 소요되어 응답이 안될 경우 GC 튜닝을 한다.
4. 각종 옵션값을 튜닝한다: 가장 간단한 방법일 수도 있다. 하지만, 잘못 설정할 경우 오히려 더 큰 문제가 야기될 수 있기 때문에 해당 웹 서버 및 WAS의 전문가나 엔지니어와 같이 이야기하며 설정하자.

만약 서버가 매우 좋아 더 많은 요청을 처리해야 할 필요가 있다면 `httpd.conf`, `httpd-mpm.conf` 파일을 수정하여 서버가 최대한의 자원을 사용하도록 변경해야 한다.

## 웹 서버의 Keep Alive
아파치 웹 서버의 경우, `httpd.conf` 파일에 다음의 설정이 없으면 간단하게 한 줄을 추가하자.

```
KeepAlive On
```

웹 서버와 브라우저가 연결되었을 때 `KeepAlive` 기능이 켜져 있지 않으면, 매번 HTTP 연결을 맺었다 끊었다 하는 작업을 반복한다. 초기 화면이 매우 간단한 구글과 같은 사이트는 해당 사이트에 연결할 때 `KeepAlive`가 적용되지 않더라도 그리 느리진 않다. 하지만 네이버 같이 엄청나게 많은 이미지와 CSS, JS 등의 파일을 받아야 하는 사이트에서 이 옵션이 적용되어 있지 않다면, 초기 화면을 띄우는 데 몇 분씩 소요될지도 모른다.

이미지와 같은 모든 개체들도 서버에 매번 접속을 해야 하는 상황이 발생하게 되는데, 이 기능이 켜져 있으면 두 개 정도의 연결을 열어서 끊지 않고, 연결을 계속 재사용한다. 그 결과 연결을 하기 위한 대기 시간이 짧아지기 때문에 사용자가 느끼는 응답 속도도 엄청나게 빨라진다.

> 📌 참고  
> 사용자의 접근이 많은 사이트에서 이미지나 CSS 같이 정적인 파일들을 일반적인 웹 서버에서 처리하지 않고, CDN을 사용한다. 별도의 URL에서 해당 컨텐츠들을 내려받도록 설정하고, 동적인 컨텐츠들은 WAS에서 처리하도록 해 놓으면 Web-WAS 서버의 부담도 줄어들게 된다.

`KeepAlive` 설정을 할 때 반드시 같이 해야 하는 설정은 바로 `KeepAliveTimeout` 설정이다. 이는 초 단위로 `KeepAlive`가 끊기는 시간을 설정하기 위한 부분이다. **마지막 연결이 끝난 이후에 다음 연결이 될 때까지 얼마나 기다릴지를 지정한다.**

```
KeepAliveTimeout 15
```

만약 사용자가 너무 많아 접속이 잘 안될 경우, 이 설정을 5초 정도로 짧게 주는 것도 서버의 리소스를 보다 효율적으로 사용할 수 있는 방법이다. 항상 `KeepAlive` 옵션을 켜야 좋은 성능이 나오는 것은 아니니 상황에 맞게 사용하자.

## DB Connection Pool 및 스레드 개수 설정
WAS 성능에 가장 많은 영향을 주는 것은 DB Connection Pool과 스레드 개수다. 이 두 항목의 개수는 메모리와 관련이 있다. 많이 사용할수록 메모리를 많이 점유하게 된다. 그렇다고 너무 적게 지정하면 서버에서는 많은 요청을 처리하지 못하고 대기할 수 밖에 없다.

대부분의 WAS에선 DB Connection Pool의 개수를 최소치, 증가치, 최대치 등으로 자세하게 지정할 수 있다.

최소치는 말 그대로 서버가 기동될 때 연결을 수행하는 개수다. 최소 개수가 많으면 많을수록 서버를 기동하는 시간이 오래 소요되므로, 개발자가 디버그를 하기 위해서 여러 번 재기동을 할 때는 좋지 않다. 하지만, **운영 중에는 최소 및 최대 값을 동일하게 하는 것이 좋다.** 사용자 수가 갑자기 증가하면 DB Connection Pool의 개수도 증가되어야 하고, 증가할 때 대기 시간이 발생할 확률이 크기 때문이다. 만약 DB 서버의 리소스가 부족하다면 최소값을 적게 해 놓는 것도 한 방법이 될 수 있다.

대부분 WAS에서 두 설정 값의 기본 개수가 10~20개 정도다. 이 값으로 서비스를 오픈하면 원하는 요청량을 처리하지 못하게 된다. **DB Connection Pool은 보통 40~50개로 지정하며, 스레드 개수는 이보다 10개 저도 더 지정한다.** 이렇게 지정하는 이유는, 스레드 개수가 DB Connection Pool의 개수보다 적으면 적은 수만큼의 연결은 필요 없기 때문이다. 쉽게 비유하면 스레드는 입구, DB Connection Pool은 출구라고 생각하면 된다.

**스레드의 개수가 DB 연결 개수보다 많아야 하는 이유는 모든 애플리케이션이나 화면이 DB에 접속하는 것도 아니고 관리자 콘솔을 사용해서 서버에 접속할 수도 있기 때문에 그만큼 여유분을 갖도록 지정하는 것이 보통이다.** 이 수치도 상황에 따라 다르며 완벽한 값도 없다. 따라서 성능 테스트를 통해 가장 적절한 값을 구해서 적용하자.

### DB Connection Pool 전부를 사용하면서 DB의 CPU 사용량이 100%에 도달하는 경우
DB의 CPU를 점유하는 쿼리를 찾아 튜닝을 수행해야 한다. 인덱스가 없거나 테이블을 풀 스캔하는 쿼리가 있는 것은 아닌지 쿼리의 플랜을 떠서 확인해야 한다. 커넥션 풀을 전부 사용한다 해서 이 개수를 늘리면 모든 DB와의 연결을 전부 사용하고 응답 시간은 엄청나게 느려질 뿐이다.

### DB의 CPU 사용량은 50%정도인 상황에서 WAS의 CPU 사용량이 100%에 도달하는 경우
DB Connection Pool이 40개라면 20개 정도 밖에 상요하지 않는다. 이때는 WAS의 애플리케이션을 튜닝해야 한다. 하지만 이미 튜닝이 된 상태라면 이 서버의 DB Connection Pool의 개수는 약간 여유를 두기 위해 25~30개 정도로 지정하는 것이 좋다. 서버를 늘리는 것은 가장 마지막에 해야 한다는 사실은 잊지 말자.

### 대기 시간과 관련된 설정
MyBatis와 같이 DB와 자바 프로그램을 매핑해주는 프레임워크에는 각종 설정 값들이 있는데, 이 중 대기 시간을 나타내는 wait time과 관련된 값을 조절하자.

- [MyBatis 매퍼 설정](https://mybatis.org/mybatis-3/ko/configuration.html)
- [JPA Hibernate 설정](https://www.mastertheboss.com/hibernate-jpa/hibernate-configuration/configure-a-connection-pool-with-hibernate/?expand_article=1)

DB Connection Pool의 개수를 넘어 섰을 때 애플리케이션에선 남는 커넥션이 없나 찾으며 기다린다. 이 기다리는 시간이 바로 대기 시간이다. MyBatis에선 `poolTimeToWait`이라는 값으로 이 대기 시간을 결정하며, 기본은 20초다. 이 값을 그냥 둘 경우 DB 연결을 못해 기다리는 사용자들이 적어도 20초는 대기해야 한다는 뜻이다.

100ms 정도로 대기 시간을 아주 짧게 준다면 메모리를 1GB로 할당한 WAS를 기준으로 300ms 이하의 Full GC 시간을 만들기 매우 어렵기에 만약 DB 연결을 하려고 대기하는 순간 Full GC가 발생하면 그 순간 대기하고 있는 모든 스레드는 DB와 연결을 못했다고 timeout을 내뿜을 수도 있다.

## WAS 인스턴스 개수 설정
하나의 장비에 WAS 인스턴스 개수를 몇 개로 해야한다는 절대적인 규칙과 값은 없다. 그렇다고 무한정 인스턴스를 늘리는 것이 답이 될 순 없다.

서버의 WAS 인스턴스 개수를 늘리면 늘릴수록 CPU가 처리해야 하는 양이 많아진다. 하나의 장비에 20개 이상의 인스턴스를 운영중인데, CPU 코어의 개수가 4~8개라면 여러 개의 인스턴스에서 경합을 하며 CPU를 차지하려 하기 때문에 성능이 잘 나오지 않는다. 보통은 1~2개의 CPU당 하나의 인스턴스를 지정하는 것이 좋다고 이야기한다. 하지만, 장비 하나당 인스턴스 개수는 성능 테스트를 통해 구하는 것이 가장 바람직하다.

CPU 코어의 개수가 36개인 장비에 인스턴스가 1개일 때 500 TPS가 나오고, 2개일 때 700 TPS, 3개일 때 720 TPS, 4개일 때 730 TPS가 나온다고 가정하면, 저자는 인스턴스를 2~3개 정도만 띄울 것이라 한다. 인스턴스를 더 늘린다고 해서 TPS가 드라마틱하게 증가하지 않는 상황에선 오히려 유지보수성만 떨어지기 때문이다. 인스턴스의 개수가 많을 수록 배포도 어렵고, 모니터링 및 장애 상황 시 문제를 찾고 해결하기도 어려워진다.

만약 WAS 장비에 4GB의 여유 메모리가 있다 하더라도 하나의 인스턴스에 4GB의 메모리를 지정하여 사용하는 것 역시 굉장히 좋지 않은 방법이다. Full GC가 발생할 때마다 많은 시간이 소요될 확률이 커지기 때문이다. 가급적이면 512MB~2GB 사이에서 메모리를 지정하는 것이 좋다. 다른 애플리케이션이나 OS에서도 메모리를 사용하게 되므로 어느 정도 여유를 주는 것이 좋다.

단독 인스턴스를 구성하여 사용하는 것은 서버에 문제가 발생했을 때 서비스가 불가능해지므로 장비가 한 대여도, 두 개 이상의 인스턴스가 서로 클러스터링하도록 지정하여 사용자의 세션 정보를 공유하도록 하는 것이 좋다. 또한 스레드나 DB Connection Pool의 개수를 100개 이상으로 설정하려 할 때는 보통 인스턴스를 두 개로 분리한다.

## Session Timeout 시간 설정
서버의 활성 세션 개수는 일반적으로 시간이 지남에 따라 증가했다가 감소했다가 한다. 만약 시간에 따라 이 개수가 감소하지않고 증가만 하는 경우, 세션 종료 시간을 확인해보자.

책에 나온 사례로는, 정상적인 서버의 경우 세션 종료 시간을 4분으로 해놓은 반면 문제가 되는 서버는 5,256,000분으로 설정을 해 놓았다. 가장 간과하기 쉬운 것이 세션의 종료 시간 설정 부분이다. WAS에 종속적인 설정이 아닌 `WEB-INF` 폴더 하단의 `web.xml` 파일에서 설정하며 서블릿 스펙에 정의된 표준 설정 값이다.

```
...
<session-timeout>30</session-timeout>
...
```

세션 종료 시간 설정 값은 분 단위다. 설정되어 있는 시간만큼 요청이 없으면 세션을 메모리에서 제거한다. 이 설정을 하지 않은 상태에서 WAS에서 따로 설정한 바가 없거나 세션 객체의 `invalidate()` 메서드가 수행되지 않으면 세션은 삭제되지 않으므로 유의하자.