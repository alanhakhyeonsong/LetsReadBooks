# Chapter 19 - 함수형 프로그래밍 기법
이 장에서는 좀 더 고급적인 함수형 프로그래밍 기법을 소개한다. 고차원 함수, 커링, 영구 자료구조, 게으른 리스트, 패턴 매칭, 참조 투명성을 이용한 캐싱, 콤비네이터 등을 살펴본다.

## 함수는 모든 곳에 존재한다
함수형 언어 프로그래머는 함수형 프로그래밍이라는 용어를 좀 더 폭넓게 사용한다. 즉, 함수를 마치 일반값처럼 사용해서 인수로 전달하거나, 결과로 반환받거나, 자료 구조에 저장할 수 있음을 의미한다. **일반값처럼 취급할 수 있는 함수를 일급 함수(first-class function)라고 한다.**  
Java 8에서는 `::` 연산자로 **메서드 참조**를 만들거나 `(int x) -> x + 1` 같은 람다 표현식으로 직접 함숫값을 표현해서 메서드를 함숫값으로 사용할 수 있다.

### 고차원 함수
다음 중 하나 이상의 동작을 수행하는 함수를 고차원 함수라 부른다.

- 하나 이상의 함수를 인수로 받음
- 함수를 결과로 반환

스트림과 마찬가지로 고차원 함수나 메서드를 구현할 때 어떤 인수가 전달될지 알 수 없으므로 인수가 부작용을 포함할 가능성을 염두에 두어야 한다. 따라서 인수로 전달된 함수가 어떤 부작용을 포함하게 될 지 정확하게 문서화하는 것이 좋다.

### 커링
커링은 x와 y라는 두 인수를 받는 함수 f를 한 개의 인수를 받는 g라는 함수로 대체하는 기법이다. 이때 g라는 함수 역시 하나의 인수를 받는 함수를 반환한다. 함수 g와 원래 함수 f가 최종적으로 반환하는 값은 같다. 즉, `f(x, y) = (g(x))(y)`가 성립한다.

## 영속 자료구조
함수형 프로그램에서 사용하는 자료구조는 영속 자료구조이다.  
함수형 메서드에선 전역 자료구조나 인수로 전달된 구조를 갱신할 수 없다. 자료구조를 바꾼다면 같은 메서드를 두 번 호출했을 때 결과가 달라지면서 참조 투명성에 위배되고 인수를 결과로 단순하게 매핑할 수 있는 능력이 상실되기 때문이다.

함수형에선 이 같은 부작용을 수반하는 메서드를 제한하는 방식으로 문제를 해결한다. 계산 결과를 표현할 자료구조가 필요하면 기존의 자료구조를 갱신하지 않도록 새로운 자료구조를 만들어야 한다.

함수형은 **인수를 이용해서 가능한 한 많은 정보를 공유한다.** 이와 같은 함수형 자료구조를 영속(저장된 값이 다른 누군가에 의해 영향을 받지 않는 상태)이라 하며 따라서 프로그래머는 함수가 인수로 전달된 자료구조를 변화시키지 않을 것이라는 사실을 확신할 수 있다.

## 스트림과 게으른 평가
스트림은 단 한 번만 소비할 수 있다는 제약이 있어서 재귀적으로 정의할 수 없다.

### 게으른 평가 (lazy evaluation)
Java에선 메서드를 호출하면 모든 인수가 즉시 평가된다. 하지만 스트림에선 연산을 적용하면 바로 수행되지 않고 일단 저장된다. 최종 연산을 적용해서 실제 계산을 해야 하는 상황에서만 실제 연산이 이루어진다. 이는 스트림의 인자가 함수이기 때문이다.

Java 8 이후 함수가 일급 시민이 되면서 함수를 자료구조 내부로 추가할 수 있으며, 이런 함수는 자료구조를 만드는 시점이 아니라 요청 시점에 실행된다. 게으른 리스트는 또한 Java 8의 기능 스트림과의 연결고리를 제공한다. 함수형 인터페이스인 `Supplier`를 사용하여 게으른 자료구조를 만들 수 있다. `Supplier` 함수를 호출함으로 자료구조의 요소를 생성하는 것이다.

## 패턴 매칭
일반적으로 함수형 프로그래밍을 구분하는 또 하나의 중요한 특징으로 (구조적인) **패턴 매칭**을 들 수 있다. 이는 정규 표현식, 정규 표현식과 관련된 패턴 매칭과는 다르다. 여기서의 패턴 매칭은 한 개 이상의 파라미터에 대한 멀티 매칭을 의미한다.

Java에선 `if-then-else`나 `switch` 문을 사용해야 하지만, 스칼라에선 이미 패턴 매칭을 지원하고 있다. 다시 말해 다수준의 `switch` 문이라 설명할 수 있겠다.

```scala
def simplifyExpression(expr: Expr): Expr = expr match {
	case BinOp("+", e, Number(0)) => e  // 0 더하기
	case BinOp("*", e, Number(1)) => e  // 1 곱하기
	case BinOp("/", e, Number(1)) => e  // 1 나누기
	case _ => expr  // expr을 단순화할 수 없다
}
```

Java에서 함수형 프로그래밍을 통해 이와 유사하게 흉내낼 수 있다.

## 기타 정보
### 캐싱 또는 기억화
참조 투명성이 유지되는 상황이라면 기억화를 이용하여 추가 오버헤드를 피할 수 있다. 기억화는 메서드에 래퍼로 캐시(`HashMap` 같은)를 추가하는 기법이다. 래퍼가 호출되면 인수, 겨로가 쌍이 캐시에 존재하는지 먼저 확인한다. 캐시에 값이 존재하면 캐시에 저장된 값을 즉시 반환한다. 캐시에 값이 존재하지 않으면 결과를 계산한 다음 새로운 인수, 결과 쌍을 캐시에 저장하고 결과를 반환한다.

엄밀히 따져서 캐싱, 즉 다수의 호출자가 공유하는 자료구조를 갱신하는 기법이므로 이는 순수 함수형 해결방식은 아니지만 감싼 버전의 코드는 참조 투명성을 유지할 수 있다.

### '같은 객체를 반환함'은 무엇을 의미하는가?
참조 투명성은 '인수가 같다면 결과도 같아야 한다'라는 규칙을 만족함을 의미한다. 일반적으로 함수형 프로그래밍에서는 데이터가 변경되지 않으므로 같다는 의미는 참조가 같다는 `==` 연산이 성립되지 않고 구조적인 값이 같다는 것을 의미한다. 그러나 자료구조를 변경하지 않는 상황에서 참조가 다르다는 것은 큰 의미가 없으며 논리적으로 같기에, 함수형 프로그래밍에서는 구조적인 값이 같다면 둘은 같은 객체라고 할 수 있다.

### 콤비네이터
함수형 프로그래밍에선 두 함수를 인수로 받아 다른 함수를 반환하는 등 함수를 조합하는 고차원 함수를 많이 사용하게 된다. 이처럼 함수를 조합하는 기능을 콤비네이터라 부른다. Java 8 API에 추가된 많은 기능은 콤비네이터의 영향을 받았다.

- `CompletableFuture` 클래스의 `thenCombine` 메서드

## 📌정리
- 일급 함수란 인수로 전달하거나, 결과로 반환하거나, 자료구조에 저장할 수 있는 함수다.
- 고차원 함수란 한 개 이상의 함수를 인수로 받아서 다른 함수를 반환하는 함수다. Java에선 `comparing`, `andThen`, `compose` 등의 고차원 함수를 제공한다.
- 커링은 함수를 모듈화하고 코드를 재사용할 수 있도록 지원하는 기법이다.
- 영속 자료구조는 갱신될 때 기존 버전의 자신을 보존한다. 결과적으로 자신을 복사하는 과정이 따로 필요하지 않다.
- Java의 스트림은 스스로 정의할 수 없다.
- 게으른 리스트는 Java 스트림보다 비싼 버전으로 간주할 수 있다. 게으른 리스트는 데이터를 요청했을 때 `Supplier`를 이용해서 요소를 생성한다. `Supplier`는 자료구조의 요소를 생성하는 역할을 수행한다.
- 패턴 매칭은 자료형을 언랩하는 함수형 기능이다. Java의 `switch` 문을 일반화할 수 있다.
- 참조 투명성을 유지하는 상황에서는 계산 결과를 캐시할 수 있다.
- 콤비네이터는 둘 이상의 함수나 자료구조를 조합하는 함수형 개념이다.