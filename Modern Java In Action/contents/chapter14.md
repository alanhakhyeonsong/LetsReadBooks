# Chapter 14 - 자바 모듈 시스템
Java 9에서 가장 많이 거론되는 새로운 기능은 바로 모듈 시스템이다. 모듈 시스템은 직소(jigsaw) 프로젝트 내부에서 개발된 기능으로 완성까지 거의 십 년이 걸렸다. 이렇게 오랜 시간이 걸렸다는 사실에서 모듈화가 얼마나 중요한 기능 추가며 이 기능을 구현하는 것이 얼마나 어려운 일인지 알 수 있다.

## 압력: 소프트웨어 유추
Java 모듈 시스템을 자세히 살펴보기 전에 어떤 동기와 배경으로 Java 언어 설계자들이 목표를 정했는지 이해해보자. 궁극적으로 소프트웨어 아키텍처 즉 고수준에서는 기반 코드를 바꿔야 할 때 유추하기 쉬우므로 생산성을 높일 수 있는 소프트웨어 프로젝트가 필요하다. 추론하기 쉬운 소프트웨어를 만드는 데 도움을 주는 **관심사 분리**와 **정보 은닉**을 살펴보자.

### 관심사 분리(SoC, Separation of concerns)
**관심사 분리는 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙이다.** SoC를 적용하면 서로 거의 겹치지 않는 코드 그룹으로 분리할 수 있다. 다시 말해 클래스를 그룹화한 모듈을 이용해 애플리케이션의 클래스 간의 관계를 시각적으로 보여줄 수 있다.

Java 9 모듈은 클래스가 어떤 다른 클래스를 볼 수 있는지를 컴파일 시간에 정교하게 제어할 수 있다. 특히 Java 패키지는 모듈성을 지원하지 않는다.

SoC 원칙은 MVC 같은 아키텍처 관점 그리고 복구 기법을 비즈니스 로직과 분리하는 등의 하위 수준 접근 등의 상황에 유용하다. SoC 원칙은 다음과 같은 장점을 제공한다.

- 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업할 수 있다.
- 개별 부분을 재사용하기 쉽다.
- 전체 시스템을 쉽게 유지보수할 수 있다.

### 정보 은닉
**정보 은닉은 세부 구현을 숨기도록 장려하는 원칙이다.** 소프트웨어를 개발할 때 요구사항은 자주 바뀐다. 세부 구현을 숨김으로 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있다. 즉 코드를 관리하고 보호하는 데 유용한 원칙이다.

캡슐화는 특정 코드 조각이 애플리케이션의 다른 부분과 고립되어 있음을 의미한다. 캡슐화된 코드의 내부적인 변화가 의도치 않게 외부에 영향을 미칠 가능성이 줄어든다. Java에선 클래스 내의 컴포넌트에 적절하게 `private` 키워드를 사용했는지를 기준으로 컴파일러를 이용해 캡슐화를 확인할 수 있다. 하지만 Java 9 이전까지는 **클래스와 패키지가 의도된 대로 공개되었는지**를 컴파일러로 확인할 수 있는 기능이 없었다.

## 자바 모듈 시스템을 설계한 이유
### 모듈화의 한계
Java 9 이전까지는 모듈화된 소프트웨어 프로젝트를 만드는 데 한계가 있었다. Java는 클래스, 패키지, JAR 세 가지 수준의 코드 그룹화를 제공한다. 클래스와 관련해 Java는 접근 제한자와 캡슐화를 지원했다. 하지만 패키지와 JAR 수준에서는 캡슐화를 거의 지원하지 않았다.

제한된 가시성 제어  
패키지 간의 가시성 제어 기능은 유명무실한 수준이다. 한 패키지의 클래스와 인터페이스를 다른 패키지로 공개하려면 `public`으로 이들을 선언해야 한다. 이런 상황에서 보통 패키지 내부의 접근자가 `public` 이므로 사용자가 이 내부 구현을 마음대로 사용할 수 있다. 보안 측면에서 볼 때 코드가 노출되었으므로 코드를 임의로 조작하는 위협에 더 많이 노출될 수 있다.


클래스 경로  
애플리케이션을 번들하고 실행하는 기능과 관련해 Java는 태생적으로 약점을 갖고 있다. 클래스를 모두 컴파일한 다음 보통 한 개의 평범한 JAR 파일에 넣고 클래스 경로에 이 JAR 파일을 추가해 사용할 수 있다. 그러면 JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 읽는다. 하지만 클래스 경로와 JAR 조합에는 몇 가지 약점이 존재한다.
- 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없다.
- 클래스 경로는 명시적인 의존성을 지원하지 않는다.

Maven이나 Gradle 같은 빌드 도구는 이런 문제를 해결하는 데 도움을 준다. Java 9 모듈 시스템을 이용하면 컴파일 타임에 `ClassNotFoundException` 같은 에러를 모두 검출할 수 있다.

### 거대한 JDK
JDK는 Java 프로그램을 만들고 실행하는 데 도움을 주는 도구의 집합이다. 초기엔 CORBA를 애플리케이션에 사용하는지와 관계없이 CORBA의 클래스는 JDK에 포함되었는데, 이는 JDK 전부를 필요로 하지 않는 애플리케이션에서 문제가 되었다. Java 8에선 컴팩트 프로파일이라는 기법으로 관련 분야에 따라 JDK 라이브러리가 세 가지 프로파일로 나뉘어 각각 다른 메모리 풋프린트를 제공했다. 하지만 이는 땜질식 처방일 뿐이었다.

JDK 라이브러리의 많은 내부 API는 공개되지 않아야 한다. 안타깝게도 Java의 낮은 캡슐화 지원 때문에 내부 API가 외부에 공개되었다. 예를 들어 Spring, Netty, Mockito 등 여러 라이브러리에서 `sun.misc.Unsafe`라는 클래스를 사용했는데 이 클래스는 JDK 내부에서만 사용하도록 만든 클래스다. **결과적으로 호환성을 깨지 않고는 관련 API를 바꾸기가 아주 어려운 상황이 되었다.** 이런 문제들 때문에 JDK 자체도 모듈화할 수 있는 Java 모듈 시스템 설계의 필요성이 제기되었다. **즉 JDK에서 필요한 부분만 골라 사용하고, 클래스 경로를 쉽게 유추할 수 있으며, 플랫폼을 진화시킬 수 있는 강력한 캡슐화를 제공할 새로운 건축 구조가 필요했다.**

## 자바 모듈 : 큰그림
Java 8은 **모듈**이라는 새로운 Java 프로그램 구조 단위를 제공한다. 모듈은 `module`이라는 새 키워드에 이름과 바디를 추가해서 정의한다. **모듈 디스크럽터**는 `module-info.java` 라는 특별한 파일에 저장된다.

모듈 디스크럽터는 보통 패키지와 같은 폴더에 위치하며 한 개 이사으이 패키지를 서술하고 캡슐화할 수 있지만 단순한 상황에서는 이들 패키지 중 한 개만 외부로 노출시킨다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/ba2b2c0d-235c-4036-b8de-57cb94d479fe)

- `exports`: 한 패키지를 노출시키는 간단한 형식
- `requires`: 0개 이상의 모듈

## 여러 모듈 활용하기
### exports 구문
`exports`는 다른 모듈에서 사용할 수 있도록 특정 패키지를 공개 형식으로 만든다. 기본적으로 모듈 내의 모든 것은 캡슐화된다. 모듈 시스템은 화이트 리스트 기법을 이용해 강력한 캡슐화를 제공하므로 다른 모듈에서 사용할 수 있는 기능이 무엇인지 명시적으로 결정해야 한다.

```java
module expense.readers {
    // exports 패키지명
    exports com.example.expenses.readers;
    exports com.example.expenses.readers.file;
    exports com.example.expenses.readers.http;
}
```

### requires 구문
`requires`는 의존하고 있는 모듈을 지정한다.

```java
module expense.readers {
    // requires 모듈명
    requires java.base;
}
```

기본적으로 모든 모듈은 `java.base`라는 플랫폼 모듈에 의존하는데 이 플랫폼 모듈은 `net`, `io`, `util` 등의 Java 메인 패키지를 포함한다. 항상 기본적으로 필요한 모듈이므로 명시적으로 정의할 필요가 없다. 따라서 `java.base` 외의 모듈을 임포트할 때 `requires`를 사용한다.

### 이름 정하기
Oracle에선 패키지명처럼 인터넷 도메인명을 역순으로 모듈의 이름을 정하도록 권고한다. 더욱이 모듈명은 노출된 주요 API 패키지와 이름이 같아야 한다는 규칙도 따라야 한다. 모듈이 패키지를 포함하지 않거나 어떤 다른 이유로 노출된 패키지 중 하나와 이름이 일치하지 않는 상황을 제외하면 모듈명은 작성자의 인터넷 도메인 명을 역순으로 시작해야 한다.

## 컴파일과 패키징
Maven을 이용해 컴파일한다면, 먼저 각 모듈에 `pom.xml`을 추가해야 한다. 또한 전체 프로젝트 빌드를 조정할 수 있도록 모든 모듈의 부모 모듈에도 `pom.xml`을 추가하고 의존성을 정의해야 한다.

자세한 예시는 책을 참고하자.

## 자동 모듈
외부 라이브러리도 의존성을 기술하여 모듈로 사용할 수 있다. 모듈화가 되어있지 않은 라이브러리도 Java는 JAR를 자동 모듈이라는 형태로 적절하게 변환한다. 모듈 경로상에 있으나 `module-info` 파일을 가지지 않은 모든 JAR는 자동 모듈이 된다. 자동 모듈은 암묵적으로 자신의 모든 패키지를 노출시킨다.

## 모듈의 정의와 구문들
### requires
`requires` 구문은 컴파일 타임과 런타임에 한 모듈이 다른 모듈에 의존함을 정의한다.

```java
module com.iteratrlearning.application {
    requires com.iteratrlearning.ui;
}
```

`com.iteratrlearning.ui`에서 외부로 노출한 공개 형식을 `com.iteratrlearning.application`에서 사용할 수 있다.

### exports
`exports` 구문은 지정한 패키지를 다른 모듈에서 이용할 수 있도록 공개 형식으로 만든다. 아무 패키지로 공개하지 않는 것이 기본 설정이다. 어떤 패키지를 공개할 것인지를 명시적으로 지정함으로 캡슐화를 높일 수 있다.

```java
module com.iteratrlearning.ui {
   requires com.iteratrlearning.core;
   exports com.iteratrlearning.ui.panels;
   exports com.iteratrlearning.ui.widgets;
}
```

### requires transitive
다른 모듈이 제공하는 공개 형식을 한 모듈에서 사용할 수 있다고 지정할 수 있다. 필요로 하는 모듈이 다른 모듈의 형식을 반환하는 상황에서 전이성 선언을 유용하게 사용할 수 있다.

```java
module com.iteratrlearning.uui {
   requires transitive com.iteratrlearning.core;
   
   exports com.iteratrlearning.ui.panels;
   exports com.iteratrlearning.ui.widgets;
}

module com.iteratrlearning.application {
   requires com.iteratrlearning.ui;
}
```

### exports to
`exports to` 구문을 이용해 사용자에게 공개할 기능을 제한함으로 가시성을 좀 더 정교하게 제어할 수 있다.

```java
module com.iteratrlearning.ui {
   requires com.iteratrlearning.core;
   
   exports com.iteratrlearning.ui.panels;
   exports com.iteratrlearning.ui.widgets to
      com.iteratrlearning.ui.widgetuser;
}
```

### open과 opens
모듈 선언에 `open` 한정자를 이용하면 모든 패키지를 다른 모듈에 반사적으로 접근을 허용할 수 있다. 반사적인 접근 권한을 주는 것 이외에 `open` 한정자는 모듈의 가시성에 다른 영향을 미치지 않는다.

```java
open module com.iteratrlearning.ui {

}
```

Java 9 이전에는 리플렉션으로 객체의 비공개 상태를 확인할 수 있었다. 즉 진정한 캡슐화는 존재하지 않았다. Hibernate 같은 ORM 도구에선 이런 기능을 이용해 상태를 직접 고치곤 한다. Java 9에선 기본적으로 리플렉션이 이런 기능을 허용하지 않는다. 그런 기능이 필요하면 이전 코드에서 설명한 `open` 구문을 명시적으로 사용해야 한다.

리플랙션 때문에 전체 모듈을 개방하지 않고도 `opens` 구문을 모듈 선언에 이용해 필요한 개별 패키지만 개방할 수 있다. `exports-to`로 노출한 패키지를 사용할 수 있는 모듈을 한정했던 것처럼, `open`에 `to`를 붙여 반사적인 접근을 특정 모듈에만 허용할 수 있다.

### uses와 provides
Java 모듈 시스템은 `provides` 구문으로 서비스 제공자를 `uses` 구문으로 서비스 소비자를 지정할 수 있는 기능을 제공하는데 서비스와 `ServiceLocator`를 알고 있는 독자라면 친숙한 내용일 것이다. 하지만 이는 고급 주제에 해당하며 이 장에선 다루지 않는다.

## 📌 정리
- 관심사분리와 정보 은닉은 추론하기 쉬운 소프트웨어를 만드는 중요한 두 가지 원칙이다.
- Java 9 이전에는 각각의 기능을 담당하는 패키지, 클래스, 인터페이스로 모듈화를 구현했는데 효과적인 캡슐화를 달성하기에는 역부족이었다.
- 클래스 경로 지옥 문제는 애플리케이션의 의존성을 추론하기 더욱 어렵게 만들었다.
- Java 9 이전의 JDK는 거대했으며 높은 유지 비용과 진화를 방해하는 문제가 존재했다.
- Java 9에서는 새로운 모듈 시스템을 제공하는데 `module-info.java` 파일은 모듈의 이름을 지정하며 필요한 의존성(`requires`)과 공개 API(`exports`)를 정의한다.
- `requires` 구문으로 필요한 다른 모듈을 정의할 수 있다.
- `exports` 구문으로 특정 패키지를 다른 모듈에서 사용할 수 있는 공개 형식으로 지정할 수 있다.
- 인터넷 도메인명을 역순으로 사용하는 것이 권장 모듈 이름 규칙이다.
- 모듈 경로에 포함된 JAR 중에 `module-info` 파일을 포함하지 않는 모든 JAR는 자동 모듈이 된다.
- 자동 모듈은 암묵적으로 모든 패키지를 공개한다.
- Maven은 Java 9 모듈 시스템으로 구조화된 애플리케이션을 지원한다.