# Chapter 17 - 리액티브 프로그래밍
리액티브 프로그래밍 패러다임의 중요성이 증가하는 이유를 먼저 확인할 필요가 있다. 수년 전까지 대규모 애플리케이션은 수십 대의 서버, 기가바이트의 데이터, 수초의 응답 시간, 당연히 여겨졌던 몇 시간의 유지보수 시간 등의 특징을 가졌다. 오늘날에는 다음과 같은 적어도 세 가지 이유로 상황이 변하고 있다.

- 빅데이터: 보통 빅데이터는 페타바이트 단위로 구성되며 매일 증가한다.
- 다양한 환경: 모바일 디바이스에서 수천 개의 멀티 코어 프로세서로 실행되는 클라우드 기반 클러스터에 이르기까지 다양한 환경에 애플리케이션이 배포된다.
- 사용 패턴: 사용자는 1년 내내 항상 서비스를 이용할 수 있으며 밀리초 단위의 응답 시간을 기대한다.

리액티브 프로그래밍에선 다양한 시스템과 소스에서 들어오는 데이터 항목 스트림을 비동기적으로 처리하고 합쳐서 이런 문제를 해결한다. 실제로 이런 패러다임에 맞게 설계된 애플리케이션은 발생한 데이터 항목을 바로 처리함으로 사용자에게 높은 응답성을 제공한다. 게다가 한 개의 컴포넌트나 애플리케이션뿐 아니라 전체의 리액티브 시스템을 구성하는 여러 컴포넌트를 조절하는 데도 리액티브 기법을 사용할 수 있다.

이런 방식으로 구성된 시스템에서는 고장, 정전 같은 상태에 대처할 뿐 아니라 다양한 네트워크 상태에서 메시지를 교환하고 전달할 수 있으며 무거운 작업을 하고 있는 상황에서도 가용성을 제공한다.

## 리액티브 매니패스토
[리액티브 선언문](https://www.reactivemanifesto.org/ko)의 리액티브 매니패스토는 리액티브 애플리케이션과 시스템 개발의 핵심 원칙을 공식적으로 정의한다.

- 반응성(Responsive): 리액티브 시스템은 빠를 뿐 아니라 더 중요한 특징으로 일정하고 예상할 수 있는 반응 시간을 제공한다.
- 회복성(Resilient): 장애가 발생해도 시스템은 반응해야 한다.
- 탄력성(Elastic): 무서운 작업 부하가 발생하면 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다.
- 메시지 주도(Message-driven): 비동기 메시지를 전달해 컴포넌트 끼리의 느슨한 통신이 이루어진다.

### 애플리케이션 수준의 리액티브
주요 기능은 비동기로 작업을 수행하여 최신 멀티코어 CPU 사용률을 극대화한다. 스레드보다 가벼울 뿐 아니라 개발자 입장에선 동시, 비동기 애플리케이션 구현의 추상 수준을 높일 수 있으므로 동기 블록, 경쟁 조건, 데드락 같은 저 수준의 멀티스레드 문제를 직접 처리할 필요가 없어지면서 비즈니스 요구사항을 구현하는 데 더 집중할 수 있다.

RxJava, Akka 같은 리액티브 프레임워크는 별도로 지정된 스레드 풀에서 블록 동작을 실행시켜 메인 풀의 모든 스레드는 방해받지 않고 실행되므로 모든 CPU 코어가 가장 최적의 상황에서 동작할 수 있다. CPU 작업과 I/O 관련 작업을 분리하면 조금 더 정밀하게 풀의 크기 등을 설정할 수 있고 두 종류의 작업의 성능을 관찰할 수 있다.

### 시스템 수준의 리액티브
리액티브 시스템은 여러 애플리케이션이 한 개의 일관적인, 회복할 수 있는 플랫폼을 구성할 수 있게 해줄 뿐 아니라 이들 애플리케이션 중 하나가 실패해도 전체 시스템은 계속 운영될 수 있도록 도와주는 소프트웨어 아키텍처다. 리액티브 시스템은 애플리케이션을 조립하고 상호소통을 조절한다. 주요 속성으로 메시지 주도를 꼽을 수 있다.

리액티브 아키텍처에서는 컴포넌트에서 발생한 장애를 고립시킴으로 문제가 주변의 다른 컴포넌트로 전파되면서 전체 시스템 장애로 이어지는 것을 막음으로 회복성을 제공한다. 시스템에 장애가 발생했을 때 서서히 성능이 저하되는 것이 아니라 문제를 격리함으로 장애에서 완전 복구되어 건강한 상태로 시스템이 돌아온다.

위치 투명성은 리액티브 시스템의 모든 컴포넌트가 수신자의 위치에 상관없이 다른 모든 서비스와 통신할 수 있음을 의미한다. 위치 투명성 덕분에 시스템을 복제할 수 있으며 현재 작업 부하에 따라 애플리케이션을 확장할 수 있다.

## 리액티브 스트림과 플로 API
리액티브 프로그래밍은 리액티브 스트림을 사용하는 프로그래밍이다. **리액티브 스트림은 잠재적으로 무한의 비동기 데이터를 순서대로 그리고 블록하지 않는 역압력을 전제해 처리하는 표준 기술이다.** 역압력은 발행-구독 프로토콜에서 이벤트 스트림의 구독자가 발행자가 이벤트를 제공하는 속도보다 느린 속도로 이벤트를 소비하면서 문제가 발생하지 않도록 보장하는 장치다. 이런 상황이 발생했을 때 부하가 발생한 컴포넌트가 완전 불능이 되거나 예기치 않는 방식으로 이벤트를 잃어버리는 등의 문제가 발생하지 않는다.

넷플릭스, 레드햇, 트위터, 라이트밴드 및 기타 회사들이 참여한 리액티브 스트림 프로젝트에서 모든 리액티브 스트림 구현이 제공해야 하는 최소 기능 집합을 네 개의 관련 인터페이스로 정의했다. Java 9의 새로운 `java.util.concurrent.Flow` 클래스 뿐 아니라 Akka 스트림(Lightbend), 리액터(Pivotal), RxJava(Netflix), Vert.x(Redhat) 등 많은 서드 파티 라이브러리에서 이들 인터페이스를 구현한다.

### Flow 클래스 소개
Java 9에서는 리액티브 프로그래밍을 제공하는 클래스 `java.util.concurrent.Flow`를 추가했다. 이 클래스는 정적 컴포넌트 하나를 포함하고 있으며 인스턴스화할 수 없다. 리액티브 스트림 프로젝트의 표준에 따라 프로그래밍 발행-구독 모델을 지원할 수 있도록 `Flow` 클래스는 중첩된 인터페이스 네 개를 포함한다.

```java
// 함수형 인터페이스로 구독자를 등록할 수 있다.
@FunctionalInterface
public interface Publisher<T> {
    void subscribe(Subscriber<? super T> s);
}

// 구독자이며 프로토콜에서 정의한 순서로 지정된 메서드 호출을 통해 발행되어야 한다.
public interface Subscriber<T> {
    void onSubscribe(Subscription s);
    void onNext(T t);
    void onError(Throwable t);
    void onComplete();
}

// 구독자와 발행자 사이 관계를 조절하기 위한 인터페이스다.
// request는 처리할 수 있는 이벤트의 개수를 전달하며, cancel은 더 이상 이벤트를 받지 않음을 통지한다.
public interface Subscription {
    void request(long n);
    void cancel();
}

// 구독자이며 발행자다. 주로 구독자로써 전달받은 이벤트를 변환하여 발행하는, 이벤트를 변환하는 역할을 수행한다.
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> { }
```

### Flow 클래스가 갖는 중첩 인터페이스들의 규칙
- `Publisher`는 반드시 `Subscription`의 `request` 메서드에 정의된 개수 이하의 요소만 `Subscriber`에게 전달해야 한다. 하지만 `Publisher`는 지정된 개수보다 적은 수의 요소를 `onNext`로 전달할 수 있으며 동작이 성공적으로 끝났으면 `onComplete`를 호출하고 문제가 발생하면 `onError`를 호출해 `Subscription`을 종료할 수 있다.
- `Subscriber`는 요소를 받아 처리할 수 있음을 `Publisher`에게 알려야 한다. 이런 방식으로 `Subscriber`는 `Publisher`에게 역압력을 행사할 수 있고 `Subscriber`가 관리할 수 없이 너무 많은 요소를 받는 일을 피할 수 있다. 더욱이 `onComplete`나 `onError` 신호를 처리하는 상황에서 `Subscriber`는 `Publisher`나 `Subscription`의 어떤 메서드도 호출할 수 없으며 `Subscription`이 취소되었다고 가정해야 한다. 마지막으로 `Subscriber`는 `Subscription.request()` 메서드 호출이 없어도 언제든 종료 시그널을 받을 준비가 되어있어야 하며 `Subscription.cancel()`이 호출된 이후에라도 한 개 이상의 `onNext`를 받을 준비가 되어 있어야 한다.
- `Publisher`와 `Subscriber`는 정확하게 `Subscription`을 공유해야 하며 각각이 고유한 역할을 수행해야 한다. 그러려면 `onSubscribe`와 `onNext` 메서드에서 `Subscriber`는 `request` 메서드를 동기적으로 호출할 수 있어야 한다. 표준에서는 `Subscription.cancel()` 메서드는 몇 번을 호출해도 한 번 호출한 것과 같은 효과를 가져야 하며, 여러 번 이 메서드를 호출해도 다른 추가 호출에 별 영향이 없도록 스레드에 안전해야 한다고 명시한다. 같은 `Subscriber` 객체에 다시 가입하는 것은 권장하지 않지만 이런 상황에서 예외가 발생해야 한다고 명세서가 강제하진 않는다. 이전의 취소된 가입이 영구적으로 적용되었다면 이후의 기능에 영향을 주지 않을 가능성도 있기 때문이다.

## 📌 정리
- 리액티브 프로그래밍의 기초 사상은 이미 20에서 30년 전에 수립되었지만 데이터 처리량과 샤용자 기대치 덕분에 최근에서야 인기를 얻고 있다.
- 리액티브 소프트웨어가 지녀야 할 네 가지 관련 특징(반응성, 회복성, 탄력성, 메시지 주도)을 서술하는 리액티브 매니페스토가 리액티브 프로그래밍 사상을 공식화한다.
- 여러 애플리케이션을 통합하는 리액티브 시스템과 한 개의 애플리케이션을 구현할 때에 각각 다른 접근 방식으로 리액티브 프로그래밍 원칙을 적용할 수 있다.
- 리액티브 애플리케이션은 리액티브 스트림이 전달하는 한 개 이상의 이벤트를 비동기로 처리함을 기본으로 전제한다. 리액티브 애플리케이션 개발에서 리액티브 스트림의 역할이 핵심적이므로 넷플릭스, 피보탈, 라이트벤드, 레드햇 등은 다양한 구현의 상호 운용성을 극대화할 수 있도록 컨소시엄을 구성해 개념을 표준화한다.
- 리액티브 스트림은 비동기적으로 처리되므로 역압력 기법이 기본적으로 탑재되어 있다. 역압력은 발행자가 구독자보다 빠른 속도로 아이템을 발행하므로 발생하는 문제를 방지한다.
- 설계와 표준화 절차 결과가 Java에 반영되었다. Java 9 플로 API는 `Publisher`, `Subscriber`, `Subscription`, `Processor` 네 개의 핵심 인터페이스를 정의한다.
- 대부분의 상황에서는 이들 인터페이스를 직접 구현할 필요가 없으며 실제 이들 인터페이스는 리액티브 패러다임을 구현하는 다양한 라이브러리의 공용어 역할을 한다.
- 가장 흔한 리액티브 프로그래밍 도구로 RxJava를 꼽을 수 있으며 이 라이브러리는 Java 9 플로 API의 기본 기능에 더해 다양한 강력한 연산자를 제공한다. 예를 들어 한 스트림에서 방출한 요소를 변환하거나, 거를 수 있으며 여러 스트림의 데이터를 일부 합치거나 전체를 모을 수 있다.