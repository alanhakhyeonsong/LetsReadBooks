# Chapter 18 - 함수형 관점으로 생각하기
## 시스템 구현과 유지보수
### 공유된 가변 데이터
변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다. 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기 어려워진다.

어떤 자료구조도 바꾸지 않는 시스템이 있다면 문제가 일어날 일이 없어 유지보수하기 쉽다. 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 **순수 메서드** 또는 **부작용 없는 메서드**라고 한다. 이때 말하는 부작용은 다음과 같다.

- 자료구조를 고치거나 필드에 값을 할당 (setter 메서드 같은 생성자 이외의 초기화 동작)
- 예외 발생
- 파일에 쓰기 등의 I/O 동작 수행

불변 객체를 이용해 부작용을 없애는 방법도 있다. 불변 객체는 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체이므로 함수 동작에 영향을 받지 않는다. 불변 객체는 복사하지 않고 공유할 수 있으며, 객체의 상태를 바꿀 수 없으므로 스레드 안전성을 제공한다.

### 선언형 프로그래밍
**선언형 프로그래밍**은 어떻게가 아닌 **무엇을**에 집중하는 프로그래밍 방식이다. 질의문 자체로 문제를 어떻게 푸는지 명확하게 보여준다는 것이 명령형 프로그래밍과의 차이점이다. (내부 반복 프로그래밍)

선언형 프로그래밍에선 우리가 원하는 것이 무엇이고 시스템이 어떻게 그 목표를 달성할 것인지 등의 규칙을 정한다. 문제 자체가 코드로 명확하게 드러난다는 점이 선언형 프로그래밍의 강점이다.

함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, 부작용이 없는 계산을 지향한다. 선언형 프로그래밍과 부작용을 멀리한다는 두 가지 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.

- 람다 표현식: 작업을 조합하거나 동작을 전달하는 등의 언어 기능은 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 코드를 구현하는 데 많은 도움을 줌
- 스트림: 여러 연산을 연결해서 복잡한 질의를 표현할 수 있음

## 함수형 프로그래밍이란 무엇인가?
함수형 프로그래밍은 말 그대로 함수를 이용하는 프로그래밍이다. 여기서 말하는 함수는 수학적인 함수와 같다. 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 **부작용이 없어야 한다.**

Java에서 이야기하는 수학적인 함수냐 아니냐가 메서드와 함수를 구분하는 핵심이다. **함수형이라는 말은 '수학의 함수처럼 부작용이 없는'을 의미한다.** 함수는 시스템의 다른 부분에 영향을 미치지 않아야 하며 이런 특징을 **참조 투명성**이라 한다. 반면, 공유된 가변 데이터를 수정하여 시스템의 다른 부분에 영향을 미친다면 이는 함수형 메서드가 아니다. 특히 인수가 같다면 수학적 함수를 반복적으로 호출했을 때 항상 같은 결과가 반환돼야 한다.

### 함수형 자바
Java로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 하지만 시스템의 컴포넌트가 순수한 함수형인 것처럼 동작하도록 코드를 구현할 수 있다. Java에선 순수 함수형이 아니라 **함수형 프로그램**을 구현할 것이다. 실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 함수형을 달성할 수 있다.

부작용을 일으키지 않는 어떤 함수나 메서드가 있는데, 다만 진입할 때 어떤 필드의 값을 증가시켰다가 빠져나올 때 필드의 값을 돌려놓는다고 가정하자. 단일 스레드로 실행되는 프로그램의 입장에선 이 메서드가 아무 부작용을 일으키지 않으므로 이 메서드는 함수형이라 간주할 수 있다. 하지만 다른 스레드가 필드의 값을 확인한다던지 동시에 이 메서드를 호출하는 상황이 발생할 수 있다면 이 메서드는 함수형이 아니다.  
메서드의 바디를 잠금으로써 이 문제를 해결할 수 있으며 따라서 이 메서드는 함수형이라 할 수 있다. 하지만 이런 식으로 문제를 해결하면 멀티코어 프로세서의 두 코어를 활용해서 메서드를 병렬로 호출할 수 없게 된다. 프로그램 입장에서 부작용이 사라졌지만 프로그래머 관점에선 프로그램의 실행 속도가 느려지게 된 것이다.

함수나 메서드는 지역 변수만을 변경해야 함수형이라 할 수 있다. 그리고 함수나 메서드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야 한다. 또한 함수형이라면 **함수나 메서드가 어떤 예외도 일으키지 않아야 한다.** 예외가 발생할 수 있는 경우엔 `Optional<T>`를 사용하면 해결할 수 있다.

### 참조 투명성
**부작용을 감춰야 한다라는 제약은 참조 투명성 개념으로 귀결된다.** 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다. 참조 투명성은 다음과 같은 장점이 있다.

- 프로그램 이해에 큰 도움을 준다.
- 비싸거나 오랜 시간이 걸리는 연산을 기억화(memorization) 또는 캐싱(caching)을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다.

### 객체지향 프로그래밍과 함수형 프로그래밍
객체지향 프로그래밍과 함수형 프로그래밍은 반대되는 속성을 가진다.

객체지향 프로그래밍은 모든 것을 객체로 간주하고 프로그램이 객체의 필드를 갱신하고, 메서드를 호출하고, 관련 객체를 갱신하는 방식으로 동작한다.  
반대로, 함수형 프로그래밍은 참조적 투명성을 중시한다. 즉, 변화를 허용하지 않는 방식이다.

실제로 Java 프로그래머는 이 두 가지 프로그래밍 형식을 혼합한다.

## 재귀와 반복
순수 함수형 프로그래밍 언어에선 `while`, `for` 같은 반복문을 포함하지 않는다. 루프 내부에서 프로그램이 공유된 가변 데이터의 상태를 변화시킬 수 있기 때문이다.

모든 반복은 재귀로 구현할 수 있다. 재귀를 이용하면 변화가 일어나지 않는다. 또한 루프 단계마다 갱신되는 반복 변수를 제거할 수 있다. 하지만, 일반적으로 반복 코드보다 재귀 코드가 더 비싸다. 재귀 함수를 호출할 때마다 호출 스택에 각 호출시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어지기 때문에 메모리 사용량이 증가하며 계속되는 경우 `StackOverflowError`가 발생한다.

함수형 언어에선 꼬리 호출 최적화(tail-call optimization)라는 해결책을 제공한다.

```java
static long factorialTailRecursive(long n) {
    return factorialHelper(1, n);
}

static long factorialHelper(long acc, long n) {
    return n == 1 ? acc : factorialHelper(acc * n, n - 1);
}
```

꼬리 호출 최적화는 컴파일 시 하나의 스택 프레임을 재활용하도록 하는 최적화이며, 속도의 손실 또한 없다. 하지만 현재 Java에선 꼬리 호출 최적화를 지원하지 않는다. 그럼에도 여저닣 고전적인 재귀보다는 여러 컴파일러 최적화 여지를 남겨둘 수 있는 꼬리 재귀를 적용하는 것이 좋다. (스칼라, 그루비 같은 최신 JVM 언어는 이를 지원한다.)

## 📌정리
- 공유된 가변 자료구조를 줄이는 것은 장기적으로 프로그램을 유지보수하고 디버깅하는데 도움이 된다.
- 함수형 프로그래밍은 부작용이 없는 메서드와 선언형 프로그래밍 방식을 지향한다.
- 함수형 메서드는 입력 인수와 출력 결과만을 갖는다.
- 같은 인수값으로 함수를 호출했을 때 항상 같은 값을 반환하면 참조 투명성을 갖는 함수다. `while` 루프 같은 반복문은 재귀로 대체할 수 있다.
- Java에선 고전 방식의 재귀보다는 꼬리 재귀를 사용해야 추가적인 컴파일러 최적화를 기대할 수 있다.