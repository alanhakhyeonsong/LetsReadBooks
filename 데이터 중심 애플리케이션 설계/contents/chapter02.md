# 2장. 데이터 모델과 질의 언어
데이터 모델은 소프트웨어 개발에서 아마 제일 중요한 부분일 것이다. **소프트웨어가 어떻게 작성됐는지 뿐만 아니라 해결하려는 문제를 어떻게 생각해야 하는지에 대해서도 지대한 영향을 미치기 때문이다.**

대부분의 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만든다. 각 계층의 핵심적인 문제는 다음 하위 계층 관점에서 데이터 모델을 표현하는 방법이다.

- 애플리케이션 개발자는 현실을 보고 객체나 데이터 구조, 그리고 이러한 데이터 구조를 다루는 API를 모델링한다. 이런 구조는 보통 애플리케이션에 특화돼 있다.
- 데이터 구조를 저장할 때는 JSON과 XML, 문서, 관계형 데이터베이스 테이블이나 그래프 모델 같은 범용 데이터 모델로 표현한다.
- 데이터베이스 소프트웨어를 개발하는 엔지니어는 JSON/XML/관계형/그래프 데이터를 메모리나 디스크 또는 네트워크 상의 바이트 단위로 표현하는 방법을 결정한다. 이 표현은 다양한 방법으로 데이터를 질의, 탐색, 조작, 처리할 수 있게 한다.
- 더 낮은 수준에서 하드웨어 엔지니어는 전류, 빛의 파동, 자기장 등의 관점에서 바이트를 표현하는 방법을 알아냈다.

복잡한 애플리케이션에선 여러 API를 기반으로 만든 API처럼 중간 단계를 더 둘 수 있지만 기본 개념은 여전히 동일하다. 각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨긴다.

다양한 데이터 모델이 있고 각 데이터 모델은 사용 방법에 대한 가정을 나타낸다. 어떤 종류의 사용법은 쉽고 어떤 동작은 지원하지 않는다. 어떤 연산은 빠르지만 또 어떤 연산은 매우 느리게 작동한다. 어떤 데이터 변환은 자연스럽지만 다른 어떤 데이터 변환은 부자연스럽다.

## 관계형 모델과 문서 모델
관계형 모델을 기반으로 한 SQL

- 데이터는 관계로 구성되고 각 관계는 순서 없는 튜플 모음이다.
- RDBMS와 SQL은 정규화된 구조로 데이터를 저장하고 질의할 필요가 있는 사람들 대부분이 선택하는 도구가 됐다.
- 비즈니스 데이터 처리에 근원이 있다. 보통 트랜잭션 처리와 일괄 처리.
- 오늘날 웹에서 볼 수 있는 대부분의 서비스는 여전히 관계형 데이터베이스를 통해 제공된다.

### NoSQL의 탄생
2010년대에 NoSQL은 관계형 모델의 우위를 뒤집으려는 가장 최신 시도다. NoSQL 데이터베이스를 채택한 데는 다음과 같은 다양한 원동력이 있다.

- 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요
- 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
- 관계형 모델에서 지원하지 않는 특수 질의 동작
- 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람

관계형 데이터베이스는 폭넓은 다양함을 가진 비관계형 데이터스토어와 함께 사용되곤 한다. 이런 개념을 종종 다중 저장소 지속성이라 한다.

### 객체 관계형 불일치
오늘날 대부분의 애플리케이션은 OOP 언어로 개발한다. 이는 SQL 데이터 모델을 향한 공통된 비판을 불러온다. 데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객체 사이에 거추장스러운 전환 계층이 필요하다.

<img width="734" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/4a1eed66-3d41-4c20-a26f-595412288994">

- 전통적인 SQL 모델에서 가장 일반적인 정규화 표현은 직위, 학력, 연락처 정보를 개별 테이블에 넣고, 외래 키로 위 그림과 같이 `users` 테이블을 참조하는 방식이다.
- SQL 표준의 마지막 버전에서 구조화된 데이터타입과 XML 데이터에 대한 지원을 추가했다. 이 지원으로 단일 로우에 다중 값을 저장할 수 있고 문서 내 질의와 색인이 가능해졌다.
- 직업, 학력, 연락처 정보를 JSON이나 XML 문서로 부호화해 데이터베이스의 텍스트 칼럼에 저장한 뒤 애플리케이션이 구조와 내용을 해석하게 하는 방식을 사용할 수도 있다. 이는 일반적으로 부호화된 칼럼의 값을 질의하는 데 데이터베이스를 사용할 수 없다.

이력서 같은 데이터 구조는 모든 내용을 갖추고 있는 문서라서 JSON 표현에 매우 적합하다. MongoDB 같은 document oriented 데이터베이스는 JSON 데이터 모델을 지원한다.

```json
{
  "user_id": 251,
  "first_name": "Bill",
  "last_name": "Gates",
  "summary": "Co-chair of the Bill & Melinda Gates... Active blogger.",
  "region_id": "us:91",
  "industry_id": "131",
  "photo_url": "",
  "positions": [
    {"job_title": "Co-chair", "organization": "Bill & Melinda Gates Foundation"},
    {"job_title": "Co-founder, Chairman", "organization": "Microsoft"}
  ],
  "education": [
    {"school_name": "Harvard University", "start": 1973, "end": 1975},
    {"school_name": "Lakeside School, Seattle", "start": null, "end": null}
  ],
  "contact_info": {
    "blog": "http://thegatesnotes.com",
    "twitter": "http://twitter.com/BillGates"
  }
}
```

일부 개발자는 JSON 모델이 애플리케이션 코드와 저장 계층 간 임피던스 불일치를 줄인다고 생각한다. 하지만 데이터 부호화 형식으로서 JSON이 가진 문제도 있다. 스키마의 부족을 장점으로 종종 인용하기도 하는데 이에 대해선 추 후 언급하자.

**JSON 표현은 다중 테이블 스키마보다 더 나은 지역성(locality)을 갖는다.** 관계형 예제에서 프로필을 가져오려면 다중 질의를 수행하거나 `users` 테이블과 그 하위 테이블 간에 난잡한 다중 조인을 수행해야 한다. **JSON 표현에선 모든 관련 정보가 한 곳에 있어 질의 하나로 충분하다.**

사용자 프로필에서 사용자에서 직위, 학력 기록, 연락처 정보로 대응되는 일대다 관계는 의미상 데이터 트리 구조와 같다. 이는 JSON 표현에서 명시적으로 드러난다.

### 다대일과 다대다 관계
앞서 JSON 데이터 모델에서 `region_id`와 `industry_id`는 평문이 아닌 ID로 주어졌다. 왜 그럴까? 사용자 인터페이스에 지역과 업계를 입력할 수 있는 자유 텍스트 필드가 있다면 평문으로 저장하는 것이 합리적이지만 지리적 지역과 업계의 표준 목록으로 드롭다운 리스트나 자동 완성 기능을 만들어 사용자가 선택하게 하는 데는 다음과 같은 장점이 있다.

- 프로필 간 일관된 스타일과 철자
- 모호함 회피
- 갱신의 편의성. 이름이 한 곳에만 저장되므로 이름을 변경해야 하는 경우 전반적으로 갱신하기 쉽다.
- 현지화 지원. 사이트를 다른 언어로 번역할 때 표준 목록을 현지화해 지역과 업계를 사이트를 보는 사람의 언어로 표시할 수 있다.
- 더 나은 검색.

**ID나 텍스트 문자열의 저장 여부는 중복의 문제다.**
- ID를 사용하는 경우 사람에게 의미 있는 정보는 한 곳에만 저장하고 그것을 참조하는 모든 것은 ID를 사용한다.
- 텍스트를 직접 저장한다면 그것을 사용하는 모든 레코드에서 사람을 의미하는 정보를 중복해서 저장하게 된다.

**ID를 사용하는 장점으론 ID 자체는 아무런 의미가 없기 때문에 변경할 필요가 없다.** 즉 식별 정보를 변경해도 ID는 동일하게 유지할 수 있다. 하지만 의미를 가지는 경우라면 미래에 언젠가는 ID를 변경해야 할 수도 있다. 만약 정보가 중복돼 있으면 모든 중복 항목을 변경해야 한다. 이런 중복을 제거하는 일이 데이터베이스의 정규화 이면에 놓인 핵심 개념이다.

중복된 데이터를 정규화 하려면 **다대일** 관계가 필요한데 이는 문서 모델에 적합하지 않다. 관계형 데이터베이스에선 조인이 쉽기 때문에 ID로 다른 테이블의 로우를 참조하는 방식은 일반적이다. 문서 데이터베이스에선 일대다 트리 구조를 위해 조인이 필요하진 않지만 조인에 대한 지원이 보통 약하다. DB 자체가 조인을 지원하지 않으면 DB에 대한 다중 질의를 만들어 애플리케이션 코드에서 조인을 흉내내야 한다. 더욱이 애플리케이션의 초기 버전이 조인 없는 문서 모델에 적합하더라도 애플리케이션에 기능을 추가하면서 데이터는 점차 상호 연결되는 경향이 있다.

추천서와 같은 새로운 기능이 다대다 관계를 어떻게 필요로 하는지 다음 그림을 보자.

<img width="586" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/6ef09549-1e84-423e-9ac2-87d098231df3">

각 점선 내 데이터는 하나의 문서로 묶을 수 있지만 조직, 학교, 기타 사용자는 참조로 표현해야 하고 질의할 때는 조인이 필요하다.

### 문서 데이터베이스는 역사를 반복하고 있나?
관계형 데이터 베이스는 일상적으로 다대다 관계와 조인을 사용하지만 문서 데이터베이스와 NoSQL은 데이터베이스에서 다대다 관계를 표현하는 제일 좋은 방법에 대한 논쟁을 다시 열었다.

- IBM의 정보 관리 시스템(IMS) → 계층 모델. 문서 데이터베이스에서 사용하는 JSON 모델과 비슷함. 일대다 관계에선 잘 동작하지만, 다대다 관계 표현은 어렵고 조인은 지원하지 않음.
- 관계형 모델
- 네트워크 모델(코다실 모델) → 다대일과 다대다 관계를 모델링할 수 있다. 레코드 간 연결은 외래 키 보단 프로그래밍 언어의 포인터와 더 비슷함. 레코드에 접근하는 유일한 방법은 최상위 레코드에서부터 연속된 연결 경로르 따르는 방법.

#### 관계형 모델
관계형 모델이 하는 일은 알려져 있는 모든 데이터를 배치하는 것. 얽히고 설킨 중첩 구조와 데이터를 보고 싶을 때 따라가야 할 복잡한 접근 경로가 없다. 임의 조건과 일치하는 테이블의 일부 또는 모든 로우를 선택해서 읽을 수 있고 일부 칼럼을 키로 지정해 칼럼과 일치하는 특정 로우를 읽을 수 있다. 다른 테이블과의 외래 키 관계에 대해 신경 쓰지 않고 임의의 테이블에 새 로우를 삽입할 수 있다.

관계형 데이터베이스에서 query optimizer는 질의의 어느 부분을 어떤 순서로 실행할지를 결정하고 사용할 색인을 자동으로 결정한다. 이 선택은 실제로 접근 경로다. 하지만 **큰 차이점은 접근 경로를 애플리케이션 개발자가 아니라 query optimizer가 자동으로 만든다는 점이다.** 따라서 접근 경로를 따로 생각할 필요가 없다.

새로운 방식으로 데이터를 질의하고 싶은 경우 새로운 색인을 선언하기만 하면 질의는 자동으로 가장 적합한 색인을 사용한다. 따라서 관계형 모델은 애플리케이션에 새로운 기능을 추가하는 작업이 훨씬 쉽다.

#### 문서 데이터베이스와의 비교
문서 데이터베이스는 한 가지 측면에서 계층 모델로 되돌아갔다. **별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다.** 하지만 다대일과 다대다 관계를 표현할 때 관계형 데이터베이스와 문서 데이터베이스는 근본적으로 다르지 않다. 둘 다 관련 항목은 고유한 식별자로 참조한다. 관계형 모델에선 **외래 키**라 부르고 문서 모델에선 **문서 참조(document reference)** 라 부른다. 이 식별자는 조인이나 후속 질의를 사용해 읽기 시점에 확인한다.

### 관계형 데이터베이스와 오늘날의 문서 데이터베이스
두 가지를 비교하는 경우 내결함성과 동시성 처리를 포함해 고려해야 할 차이점이 많지만, 이번 장에선 데이터 모델의 차이점에만 집중한다.

**문서 데이터 모델을 선호하는 주요 이유는 스키마 유연성, 지역성에 기인한 더 나은 성능 때문이고 일부 애플리케이션의 경우 애플리케이션에서 사용하는 데이터 구조와 더 가깝기 때문이다.** 관계형 모델은 조인, 다대일, 다대다 관계를 더 잘 지원함으로써 문서 데이터 모델에 대항한다.

#### 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?
**애플리케이션에서 데이터가 문서와 비슷한 구조(일대다 관계 트리로 보통 한 번에 전체 트리를 적재)라면 문서 모델을 사용하는 것이 좋다.** 문서와 비슷한 구조를 여러 테이블로 나누어 찢는 관계형 기법은 다루기 힘든 스키마와 불필요하게 복잡한 애플리케이션 코드를 발생시킨다.

문서 모델에는 제한이 있다. 문서 내 중첩 항목을 바로 참조할 수는 없다. 하지만 문서가 너무 깊게 중첩되지 않으면 일반적으로 문제가 되지 않는다. 문서 데이터베이스의 미흡한 조인 지원은 애플리케이션에 따라 문제일 수도 있고 아닐 수도 있다.

하지만 애플리케이션에서 다대다 관계를 사용한다면 문서 모델은 매력이 떨어진다. 비정규화로 조인의 필요성 줄이기가 가능하지만 애플리케이션 코드는 비정규화된 데이터의 일관성을 유지하기 위해 추가 작업을 해야 한다. 조인은 애플리케이션 코드에서 데이터베이스에 다중 요청을 만들어 흉내낼 수 있지만 복잡도가 애플리케이션으로 이동할 뿐만 아니라 보통 데이터베이스 내 특화된 코드로 수행되는 조인보다 더 느리다. 이런 경우 문서 모델을 사용하는 것은 훨씬 더 복잡한 애플리케이션 코드와 나쁜 성능으로 이어질 수 있다.

#### 문서 모델에서의 스키마 유연성
대부분의 문서 데이터베이스와 관계형 데이터베이스에서 지원하는 JSON은 문서의 데이터에 어떤 스키마를 강요하지 않는다. 스키마가 없다는 뜻은 임의의 키와 값을 문서에 추가할 수 있고 읽을 때 클라이언트는 문서에 포함된 필드의 존재 여부를 보장하지 않는다는 의미다.

**문서 데이터베이스는 종종 스키마리스로 불리지만 이는 오해의 소지가 있다. 데이터를 읽는 코드는 보통 구조의 유형을 어느 정도 가정한다. 즉, 암묵적인 스키마가 있지만 데이터베이스는 이를 강요하지 않는다.**

- 쓰기 스키마
  - 관계형 데이터베이스의 전통적인 접근 방식으로 스키마는 명시적이고 데이터베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장한다.
  - 정적(컴파일 타임) 타입 확인과 비슷하다.
- 읽기 스키마
  - 데이터 구조는 암묵적이고 데이터를 읽을 때만 해석한다.
  - 동적(런타임) 타입 확인과 유사하다.

접근 방식 간 차이는 애플리케이션이 데이터 타입을 변경하고자 할 때 특히 뚜렷하다. 문서 데이터베이스는 새로운 필드를 가진 새로운 문서를 작성하기 시작하고 애플리케이션에선 예전 문서를 읽은 경우를 처리하는 코드만 있으면 된다. 반면, 정적 타입의 데이터베이스 스키마에선 보통 마이그레이션을 수행한다. (`ALTER TABLE`, `UPDATE ... SET`)

스키마 변경은 느리고 중단 시간을 요구하기 때문에 평판이 나쁘다.

읽기 스키마 접근 방식은 컬렉션 안의 항목이 어떤 이유로 모두 동일한 구조가 아닐 때(즉 데이터가 여러 다른 유형으로 구성돼 있음) 유리하다.

- 다른 여러 유형의 오브젝트가 있고 각 유형의 오브젝트별로 자체 테이블에 넣는 방법은 실용적이지 않다.
- 사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정된다.

이 같은 상황에서 스키마는 득보다 실이 많다. 오히려 스키마리스 문서가 더 자연스로운 데이터 모델이다. 하지만 모든 레코드가 동일한 구조라서 예상 가능하다면 스키마가 문서화와 구조를 강제하기 위한 유용한 메커니즘이다.

#### 질의를 위한 데이터 지역성
문서는 보통 JSON, XML로 부호화된 단일 연속 문자열이나 JSON 또는 XML의 이진 변형으로 저장된다. 웹 페이지 상에 문서를 보여주는 동작처럼 애플리케이션이 자주 전체 문서에 접근해야 할 때 저장소 지역성을 활용하면 성능 이점이 있다.

**지역성의 이점은 한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용된다.** 데이터베이스는 대개 문서의 작은 부분에만 접근해도 전체 문서를 적재해야 하기 때문에 큰 문서에선 낭비일 수 있다. 문서를 갱신할 때도 보통 전체 문서를 재작성해야 한다. 부호화된 문서의 크기를 바꾸지 않는 수정은 쉽게 수행할 수 있다. **이런 이유로 일반적으로 문서를 아주 작게 유지하며 문서의 크기가 증가하는 쓰기를 피하라고 권장한다.**

#### 문서 데이터베이스와 관계형 데이터베이스의 통합
관계형 데이터베이스와 문서 데이터베이스는 시간이 지남에 따라 점점 더 비슷해지고 있다. 이 둘의 혼합 모델은 앞으로 가야할 올바른 길이다.

## 데이터를 위한 질의 언어
SQL은 **선언형** 질의 언어인 반면 IMS와 코다실은 **명령형** 코드를 사용해 데이터베이스에 질의한다. 이것은 무엇을 의미할까?

명령형 언어는 특정 순서로 특정 연산을 수행하게끔 컴퓨터에 지시한다. 지시의 예로 코들르 한 줄씩 단계별로 실행하고 조건을 평가하고 변수를 갱신하고 루프를 한 번 더 실행할지의 여부를 결정하는 것을 들 수 있다.

**SQL이나 관계 대수 같은 선언형 질의 언어에선 목표를 달성하기 위한 방법이 아니라 알고자 하는 데이터의 패턴, 즉 결과가 충족해야 하는 조건과 데이터를 어떻게 변환할지를 지정하기만 하면 된다.** 어떤 색인과 어떤 조인 함수를 사용할지, 질의의 다양한 부분을 어떤 순서로 실행할지를 결정하는 일은 데이터베이스 시스템의 쿼리 옵티마이저가 할 일이다.

선언형 질의 언어는 일반적으로 명령형 API보다 더 간결하고 쉽게 작업할 수 있기 때문에 매력적이다. 더 중요한 점은 데이터베이스 엔진의 상세 구현이 숨겨져 있어 질의를 변경하지 않고도 데이터베이스 시스템의 성능을 향상시킬 수 있다는 점이다. SQL은 특정 순서를 보장하지 않으므로 순서가 바뀌어도 상관 없다. 하지만 질의가 명령형 코드로 작성됐다면 데이터베이스는 코드에 순서가 의존하는지 여부를 확신할 수 없다. SQL이 기능적으로 더 제한적이란 사실은 데이터베이스에게 자동으로 최적화할 수 있는 여지를 더 많이 준다는 의미다.

마지막으로 선언형 언어는 종종 **병렬 실행에 적합하다.** 명령형 코드는 명령어를 특정 순서로 수행하게끔 지정하기 때문에 다중 코어나 다중 장비에서 병렬 처리가 매우 어렵다. 선언형 언어는 결과를 결정하기 위한 알고리즘을 지정하는 게 아니라 결과의 패턴만 지정하기 때문에 병렬 실행으로 더 빨라질 가능성이 있다.

### 맵리듀스 질의
**`MapReduce`는 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델이다.** MongoDB를 포함한 일부 NoSQL 데이터 저장소는 제한된 형태의 맵리듀스를 지원한다. 이는 많은 문서를 대상으로 읽기 전용 질의를 수행할 때 사용한다.

**맵리듀스는 선언형 질의 언어도 완전한 명령형 질의 API도 아닌 그 중간 정도에 있다.** 질의 로직은 처리 프레임워크가 반복적으로 호출하는 조각 코드로 표현한다. 맵리듀스는 여러 함수형 프로그래밍 언어에 있는 `map`, `reduce` 함수를 기반으로 한다.

```sql
# PostgreSQL
SELECT date_trunc('month', observation_timestamp) AS observation_month,
  sum(num_animals) AS total_animals
FROM observations
WHERE family = 'Sharks'
GROUP BY observation_month;
```

이 질의를 MongoDB의 맵리듀스 기능을 이용하면 다음과 같이 표현할 수 있다.

```bash
# MongoDB
db.observations.mapReduce(
  function map() {
    var year = this.observationTimestamp.getFullYear();
    var month = this.observationTimestamp.getMonth() + 1;
    emit(year + "-" + month, this.numAnimals);
  },
  function reduce(key, values) {
    return Array.sum(values);
  },
  {
    query: { family: "Sharks" },
    out: "monthlySharkReport"
  }
);
```

MongoDB의 `map`과 `reduce` 함수는 수행할 때 약간 제약 사항이 있다. 두 함수는 **순수 함수**여야 한다. 즉 입력으로 전달된 데이터만 사용하고 추가적인 데이터베이스 질의를 수행할 수 없어야 하며 부수 효과가 없어야 한다. 이런 제약 사항 때문에 데이터베이스가 임의 순서로 어디서나 이 함수를 실행할 수 있고 장애가 발생해도 함수를 재실행할 수 있다.

클러스터 환경에서 분산 실행을 위한 프로그래밍 모델인 맵리듀스는 상당히 저수준 프로그래밍 모델이다. SQL 같은 고수준 질의 언어도 맵리듀스 연산의 파이프라인으로 구현할 수 있지만 맵리듀스를 사용하지 않은 분산 SQL 구현도 많다. SQL에 단일 장비에서 수행되도록 제한하는 것은 없으며 맵리듀스가 분산 질의 실행에 대한 독점권을 가진 것도 아니다.

**질의 중간에 javascript 코드를 사용할 수 있다는 점은 고급 질의가 가능한 훌륭한 기능이지만 맵리듀스에만 해당하는 것은 아니다.**

맵리듀스의 사용성 문제는 연계된 javascript 함수 두 개를 신중하게 작성해야 한다는 점인데 이는 종종 하나의 질의를 작성하는 것보다 어렵다. 더욱이 선언형 질의 언어는 쿼리 옵티마이저가 질의 성능을 높일 수 있는 기회를 제공한다. 이런 이유로 MongoDB는 집계 파이프라인(aggregation pipeline)이라 부르는 선언형 질의 언어 지원을 추가했다.

```bash
db.observation.aggregate([
  { $match: { family: "Sharks" } },
  { $group: {
    _id: {
      year: { $year: "$observationTimestamp" },
      month: { $month: "$observationTimestamp" }
    },
    totalAnimals: { $sum: "$numAnimals" }
  } }
]);
```

집계 파이프라인 언어는 표현 측면에선 SQL의 부분 집합과 유사하지만 SQL의 영어 문장 스타일 구문보단 JSON 기반 구문을 사용한다.

## 정리
데이터 모델은 광범위한 주제다.

- 문서 데이터베이스는 데이터가 문서 자체에 포함돼 있으면서 하나의 문서와 다른 문서 간 관계가 거의 없는 사용 사례를 대상으로 한다.
- 그래프 데이터베이스는 문서 데이터베이스와는 정반대로 모든 것이 잠재적으로 관련 있다는 사용 사례를 대상으로 한다.

이 두 데이터베이스는 일반적으로 저장할 데이터를 위한 스키마를 강제하지 않아 변화하는 요구사항에 맞춰 애플리케이션을 쉽게 변경할 수 있다. 하지만 애플리케이션은 데이터가 특정 구조를 갖는다고 가정할 가능성이 높다. 이는 스키마가 명시적인지 암시적인지의 문제일 뿐이다.