# 6장. 파티셔닝
앞장에선 동일한 데이터의 복사본 여러 개를 다른 노드에 저장하는 개념인 복제를 다뤘다. 데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으론 부족하고 데이터를 **파티션**으로 쪼갤 필요가 있다. 이 작업을 **샤딩**이라고도 한다.

파티션을 나눌 때는 보통 각 데이터 단위(레코드, 로우, 문서)가 하나의 파티션에 속하게 한다. 데이터베이스가 여러 파티션을 동시에 건드리는 연산을 지원할 수도 있지만 결과적으로 각 파티션은 그 자체로 작은 데이터베이스가 된다.

**데이터 파티셔닝을 원하는 주된 이유는 확장성이다.** 비공유 클러스터에서 다른 파티션은 다른 노드에 저장될 수 있다. 따라서 대용량 데이터셋이 여러 디스크에 분산될 수 있고 질의 부하는 여러 프로세서에 분산될 수 있다.

단일 파티션에 실행되는 질의를 생각해보면 각 노드에서 자신의 파티션에 해당하는 질의를 독립적으로 실행할 수 있으므로 노드를 추가함으로써 질의 처리량을 늘릴 수 있다. 크고 복잡한 질의는 훨씬 더 어렵긴 하지만 여러 노드에서 병렬 실행이 가능하다.

## 파티셔닝과 복제
**보통 복제와 파티셔닝을 함게 적용해 각 파티션의 복사본을 여러 노드에 저장한다.** 각 레코드는 정확히 한 파티션에 속하더라도 이를 여러 다른 노드에 저장해서 내결함성을 보장할 수 있다는 의미다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/2c58f206-f448-4cff-bbdd-53d24c599726)

한 노드에 여러 파티션을 저장할 수도 있다. 리더 팔로워 복제 모델을 사용한다면 파티셔닝과 복제의 조합은 위와 같은 형태가 된다. 각 파티션의 리더는 하나의 노드에 할당되고 팔로워들은 다른 노드에 할당된다. 각 노드는 어떤 파티션에게는 리더이면서 다른 파티션에게는 팔로워가 될 수 있다. 데이터베이스 복제에 관한 모든 내용은 파티션의 복제에도 동일하게 적용된다.

## 키-값 데이터 파티셔닝
대량의 데이터를 파티셔닝한다 생각해보자. 어떤 레코드를 어떤 노드에 저장할지 어떻게 결정해야 할까?

**파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이다.** 모든 노드가 동일한 분량을 담당한다 가정할 때 10대의 노드를 사용하면 한 대를 사용할 때보다 이론상으로 10배의 데이터를 저장하고 10배의 읽기, 쓰기 요청을 처리할 수 있다.

파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 쏠렸다고 한다. 그결과 파티셔닝의 효과는 매우 떨어진다. 극단적인 경우 모든 부하가 한 파티션에 몰려 10개 중 9개 노드는 유휴 상태에 있고 요청을 받는 노드 하나가 병목이 될 수 있다. 불균형하게 부하가 높은 파티션을 **핫스팟**이라고 한다.

**핫스팟을 회피하는 가장 단순한 방법은 레코드를 할당할 노드를 무작위로 선택하는 것이다.** 데이터가 노드들 사이에 매우 고르게 분산되지만 어떤 레코드를 읽으려고 할 때 해당 레코드가 어느 노드에 저장됐는지 알 수 없으므로 모든 노드에서 병렬적으로 질의를 실행해야 하는 커다란 단점이 있다.

### 키 범위 기준 파티셔닝
파티셔닝하는 방법 중 하나는 종이 백과사전처럼 각 파티션에 연속된 범위의 키를 할당하는 것이다. 각 범위들 사이의 경계를 알면 어떤 키가 어느 파티션에 속하는지 쉽게 찾을 수 있다. 또 어떤 파티션이 어느 노드에 할당됐는지 알면 적절한 노드로 요청을 직접 보낼 수 있다.

키 범위 크기가 반드시 동일할 필요는 없다. 데이터가 고르게 분포하지 않을 수도 있기 때문이다. 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다.

파티션 경계는 관리자가 수동으로 선택하거나 데이터베이스에서 자동으로 선택되게 할 수 있다. 이런 식으로 파티셔닝하는 전략은 HBase, 2.4 이전 버전의 MongoDB에서 사용된다.

각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있다. 이렇게 하면 범위 스캔이 쉬워지는 이점이 있고, 키를 연쇄된 색인으로 간주해서 질의 하나로 관련 레코드 여러 개를 읽어오는 데 사용할 수 있다. 예를 들어 센서 네트워크 데이터를 저장하는 애플리케이션에서 측정값의 타임스탬프를 키로 사용한다고 하자. 이 경우 범위 스캔이 매우 유용하다.

**그러나 키 범위 기준 파티셔닝은 특정한 접근 패턴이 핫스팟을 유발하는 단점이 있다.** 타임스탬프가 키라면 파티션은 시간 범위에 대응된다. 유감스럽게도 센서에서 값이 측정될 때마다 데이터를 데이터베이스에 기록하므로 쓰기 연산이 모두 동일한 파티션으로 전달되어 해당 파티션만 과부하가 걸리고 나머지 파티션은 유휴 상태로 남아 있을 수 있다.

이 문제를 피하려면 키의 첫 번째 요소로 타임스탬프가 아닌 다른 것을 사용해야 한다. 에를 들어 타임스탬프 앞에 센서 이름을 붙여 파티셔닝할 때 센서 이름을 먼저 사용한 후 시간을 사용하게 할 수 있다. 동시에 동작하는 센서가 많이 있다면 쓰기 부하가 파티션 사이에 더 균등하게 퍼진다.

### 키의 해시값 기준 파티셔닝
**쏠림과 핫스팟의 위험 때문에 많은 분산 데이터스토어는 키의 파티션을 정하는 데 해시 함수를 사용한다.**

좋은 해시 함수는 쏠린 데이터를 입력으로 받아 균일하게 분산되게 한다. 문자열을 입력으로 받는 32bit 해시 함수가 있다고 하자. 이 함수에 문자열을 넣으면 겉보기에는 `0 ~ 2^32 - 1` 사이의 무작위 숫자를 반환한다. 입력 문자열이 거의 유사해도 해시값은 숫자 범위 내에서 균일하게 분산된다.

**파티셔닝용 해시 함수는 암호적으로 강력할 필요는 없다.** 키에 적합한 해시 함수를 구했다면 각 파티션에 키 범위 대신 해시값 범위를 할당하고 해시값이 파티션의 범위에 속하는 모든 키를 그 파티션에 할당하면 된다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/418e629b-67b1-410a-8e6d-b0af53829df9)

이 기법은 키를 파티션 사이에 균일하게 분산시키는 데 좋다. 파티션 경계는 크기가 동일하도록 나눌 수도 있고 무작위에 가깝게 선택할 수도 있다. 이런 기법을 일관성 해싱이라고 부르기도 한다.

그러나 유감스럽게도 파티셔닝에 키의 해시값을 사용해서 파티셔닝하면 키 범위 파티셔닝의 좋은 속성을 잃어 버린다. 바로 범위 질의를 효율적으로 실행할 수 있는 능력이다. 전에는 인접했던 키들이 이제는 모든 파티션에 흩어져 정렬 순서가 유지되지 않는다. MongoDB에선 해시 기반 샤딩 모드를 활성화하면 범위 질의가 모든 파티션에 전송돼야 한다.

카산드라는 두 가지 파티셔닝 전략 사이에서 타협한다. 테이블을 선언할 때 여러 칼럼을 포함하는 **복합 기본키**를 지정할 수 있다. 키의 첫 부분에만 해싱을 적용해 파티션 결정에 사용하고, 남은 칼럼은 카산드라의 SS테이블에서 데이터를 정렬하는 연쇄된 색인으로 사용한다. 따라서 복합 키의 첫 번째 칼럼에 대해선 값 범위로 검색하는 질의를 쓸 순 없지만 첫 번째 칼럼에 고정된 값을 지정하면 키의 다른 칼럼에 대해선 범위 스캔을 효율적으로 실행할 수 있다.

### 쏠린 작업부하와 핫스팟 완화
키를 해싱해서 파티션을 정하면 핫스팟을 줄이는 데 도움이 된다. 그렇지만 핫스팟을 완벽히 제거할 수는 없다. 항상 동일한 키를 읽고 쓰는 극단적인 상황에선 모든 요청이 동일한 파티션으로 쏠리게 된다.

**현대 데이터 시스템은 대부분 크게 쏠린 작업부하를 자동으로 보정하지 못하므로 애플리케이션에서 쏠림을 완화해야 한다.** 예를 들어 요청이 매우 많이 쏠리는 키를 발견했을 때 간단한 해결책은 각 키의 시작이나 끝에 임의의 숫자를 붙이는 것이다. 임의의 10진수 두 개만 붙이더라도 한 키에 대한 쓰기 작업이 100개의 다른 키로 균등하게 분산되고 그 키들은 다른 파티션으로 분산될 수 있다.

그러나 다른 키에 쪼개서 쓰면 읽기를 실행할 때 추가적인 작업이 필요해진다. 100개의 키에 해당하는 데이터를 읽어서 조합해야 하기 때문이다. 추가적으로 저장해야 할 정보도 있다. 이 기법은 요청이 몰리는 소수의 키에만 적용하는 게 타당하다. 쓰기 처리량이 낮은 대다수의 키에도 적용하면 불필요한 오버헤드가 생긴다. 따라서 어떤 키가 쪼개졌는지 추적할 방법도 있어야 한다.

## 파티셔닝과 보조 색인
