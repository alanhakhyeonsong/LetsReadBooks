# 7장. 트랜잭션
현실 세계에서 데이터 시스템은 여러 가지 문제가 생길 수 있다.

- 데이터베이스 소프트웨어나 하드웨어는 쓰기 연산이 실행 중일 때를 포함해서 언제라도 실패할 수 있다.
- 애플리케이션은 연속된 연산이 실행되는 도중도 포함해서 언제라도 죽을 수 있다.
- 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있다.
- 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
- 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.
- 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

시스템이 신뢰성을 지니려면 이런 결함을 처리해서 전체 시스템의 치명적인 장애로 이어지는 것을 막아야 한다. 그러나 내결함성을 갖춘 시스템을 구현하려면 할 일이 많다. 잘못될 수 있는 모든 것에 대해 신중하게 생각해야 하며 테스트를 여러 번 해서 해결책이 실제로 동작하는지 확인해야 한다.

수십년 동안 트랜잭션은 이런 문제를 단순화하는 메커니즘으로 채택돼 왔다. **트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.**

- 개념적으로 한 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행된다.
- 트랜잭션은 전체가 성공(commit)하거나 실패(rollback)한다.
- 트랜잭션이 실패하면 애플리케이션에서 안전하게 재시도할 수 있다.

트랜잭션을 쓰면 애플리케이션에서 오류 처리를 하기 훨씬 단순해진다. 어떤 연산은 성공하고 어떤 연산은 실패하는 경우처럼 부분적인 실패를 걱정할 필요가 없기 때문이다.

트랜잭션은 데이터베이스에 접속하는 애플리케이션에서 **프로그래밍 모델을 단순화**하려는 목적으로 만든 것이다. 트랜잭션을 사용함으로써 애플리케이션에서 어느 정도의 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있다. 데이터베이스에서 대신 이런 일을 도맡아 주기 때문이다.

모든 애플리케이션에서 트랜잭션이 필요하진 않으며 때로는 트랜잭션적인 보장을 완화하거나 아예 쓰지 않는 게 이득이다. (성능을 향상시키거나 가용성을 높일 수 있다.) 어떤 안정성 속성은 트랜잭션 없이도 보장될 수 있다.

## 애매모호한 트랜잭션의 개념
현대의 거의 모든 관계형 데이터베이스와 일부 비관계형 데이터베이스는 트랜잭션을 지원한다.

2000년대 후반 NoSQL 데이터베이스가 인기를 얻기 시작했다. 이들은 새로운 데이터 모델을 선택할 수 있게 하고 기본적으로 복제와 파티셔닝 기능을 제공함으로써 관계형 데이터베이스의 현 상황을 개선하는 것을 목표로 했다. 새로운 세대의 데이터베이스 중 다수는 트랜잭션을 완전히 포기하거나 과거에 인식되던 것보다 훨씬 약한 보장을 의미하는 단어로 트랜잭션의 의미를 재정의했다.

### ACID의 의미
트랜잭션이 제공하는 안전성 보장은 흔히 **원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 의미하는 약어인 ACID로 잘 알려져 있다.**

그러나 현실에선 데이터베이스마다 ACID 구현이 제각각이다. 격리성의 의미 주변에는 모호함이 많이 있다.

#### 원자성
일반적으로 원자적이란 더 작은 부분으로 쪼갤 수 없는 뭔가를 가리킨다. **시스템은 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며 그 중간 상태에는 머물 수 없다.**

ACID의 원자성은 클라이언트가 쓰기 작업 몇 개를 실행하려 하는데 그중 일부만 처리된 후 결함이 생기면 무슨일이 생기는지 설명한다. 여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함 때문에 commit 될 수 없다면 abort되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소해야 한다.

원자성 없이는 여러 변경을 적용하는 도중 오류가 발생하면 어떤 변경은 효과가 있고 어떤 것은 그렇지 않은지 알기 어렵다. 애플리케이션에서 재시도할 수 있지만 동일한 변경이 두 번 실행돼서 중복되거나 잘못된 데이터가 만들어지기 쉽다. 원자성은 이 문제를 단순하게 만들어준다. 트랜잭션이 어보트됐다면 애플리케이션에서 이 트랜잭션이 어떤 것도 변경하지 않았음을 알 수 있으므로 안전하게 재시도할 수 있다.

#### 일관성
ACID 일관성의 아이디어는 **항상 진실이어야 하는, 데이터에 관한 어떤 선언이 있다는 것이다.** 그러나 일관성의 아이디어는 애플리케이션의 불변식 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다. 이는 데이터베이스가 보장할 수 있는게 아니다. 데이터베이스는 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다.

원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 일관성은 애플리케이션의 속성이다.

#### 격리성
대부분 동시에 여러 클라이언트에서 데이터베이스에 접속한다. 클라이언트들이 데이터베이스의 다른 부분을 읽고 쓰면 아무 문제가 없지만 동일한 데이터베이스 레코드에 접근하면 동시성 문제에 맞닥뜨리게 된다.

**ACID에서 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다.** 트랜잭션은 다른 트랜잭션을 방해할 수 없다. 고전적인 데이터베이스 교과서에선 격리성을 직렬성이라는 용어로 공식화한다. 직렬성은 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인 것처럼 동작할 수 있다는 것을 의미한다. 데이터베이스는 실제로 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/9c7b4b9a-fefc-491f-970d-6d1ad8b7ded1)

#### 지속성
데이터베이스 시스템의 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공하는 것이다. **지속성은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.**

단일 노드 데이터베이스에서 지속성은 일반적으로 데이터가 하드디스크나 SSD 같은 비휘발성 저장소에 기록됐다는 뜻이다. 보통 디스크에 저장된 데이터 구조가 오염됐을 때 복구할 수 있게 해주는, 쓰기 전 로그나 비슷한 수단을 동반한다. 복제 기능이 있는 데이터베이스에서 지속성은 데이터가 성공적으로 다른 노드 몇 개에 복사됐다는 것을 의미할 수 있다. **지속성을 보장하려면 데이터베이스는 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야 한다.**

### 단일 객체 연산과 다중 객체 연산
ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야 하는지를 서술한다.

- 원자성  
  쓰기를 이어서 실행하는 도중 오류가 발생하면 트랜잭션은 어보트돼야 하고 그때까지 쓰여진 내용은 폐기돼야 한다. 다시 말해 데이터베이스는 전부 반영되거나 아무것도 반영되지 않는 것을 보장함으로써 부분 실패를 걱정할 필요가 없게 도와준다.
- 격리성  
  동시에 실행되는 트랜잭션들은 서로를 방해하지 말아야 한다. 예를 들어, 한 트랜잭션이 여러 번 쓴다면 다른 트랜잭션은 그 내용을 전부 볼 수 있든지 아무것도 볼 수 없든지 둘 중 하나여야 하고 일부분만 볼 수 있어서는 안 된다.

이 정의는 한 번에 여러 객체를 변경할 수 있다고 가정한다. **다중 객체 트랜잭션은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.** 어떤 사용자의 읽지 않은 메시지 개수를 보여주려면 다음과 같은 질의를 실행할 수 있다.

```sql
SELECT COUNT(*) FROM emails WHERE recipient_id = 2 AND unread_flag = true;
```

그러나 이메일이 많으면 이 질의가 너무 느려져 읽지 않은 메시지 개수를 별개의 필드에 저장하고 싶을 것이다(일종의 비정규화). 이제 새 메시지가 올 때마다 읽지 않은 메시지 개수도 증가시켜야 하고, 메시지를 읽었다고 표시할 때마다 읽지 않은 메시지 개수도 감소시켜야 한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/dfc9fa1b-f679-4305-be9e-21f214560cce)

위 그림에선 사용자 2는 이상 현상을 경험한다. 격리성은 사용자 2가 삽입된 이메일과 갱신된 개수를 모두 보거나 모두 보지 못하게 하고 일관성이 깨진 중간 지점을 보는 일은 없게 해준다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/a77c3b65-94fd-4517-8da1-d5e47a148d26)

위 그림에선 원자성의 필요성이 설명돼 있다. 트랜잭션 실행 도중 어느 시점에서 오류가 발생하면 우편함의 내용과 읽지 않은 메시지 개수가 동기화되지 않을 수 있다. 원자적 트랜잭션에선 개수 갱신을 실패하면 트랜잭션이 어보트되고 삽입된 이메일은 롤백된다.

다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다. **관계형 데이터베이스에서 이것은 전형적으로 클라이언트와 데이터베이스 서버 사이의 TCP 연결을 기반으로 한다.** 어떤 특정 연결 내에서 `BEGIN TRANSACTION`문과 `COMMIT`문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여겨진다.

**반면 비관계형 데이터베이스는 이런식으로 연산을 묶는 방법이 없는 경우가 많다.** 다중 객체 API가 있더라도 반드시 트랜잭션 시맨틱을 뜻하지는 않는다. 어떤 키에 대한 연산은 성공하고 나머지 키에 대한 연산은 실패해서 데이터베이스가 부분적으로 갱신된 상태가 될 수 있다.

#### 단일 객체 쓰기
원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다. 예를 들어 20KB의 JSON 문서를 데이터베이스에 쓴다고 해보자.

- 첫 10KB를 보낸 후에 네트워크 연결이 끊기면 데이터베이스는 파싱 불가능한 10KB의 JSON 조각을 저장할 것인가?
- 데이터베이스가 디스크에 저장된 기존 값을 덮어쓰는 도중에 전원이 나가면 기존 값과 새 값이 함께 붙어 있게 될까?
- 문서를 쓰고 있을 때 다른 클라이언트에서 그 문서를 읽으면 부분적으로 갱신된 값을 읽게 될까?

저장소 엔진들은 거의 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다. 원자성은 장애 복구용 로그를 써서 구현할 수 있고 격리성은 각 객체에 잠금을 사용해 구현할 수 있다.

단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실을 방지하므로 유용하다. 그러나 일반적으로 쓰이는 의미의 트랜잭션이 아니다. compare-and-set과 다른 단일 객체 연산은 경량 트랜잭션으로 불리거나 심지어 마케팅 목적으로 ACID로 간주되기도 했지만 이런 용어는 오해의 소지가 있다. 트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘으로 이해된다.

#### 다중 객체 트랜잭션의 필요성
**많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했다.** 다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기가 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오도 있기 때문이다. **하지만 분산 데이터베이스에서 근본적으로 트랜잭션을 막는 것은 아무것도 없다.**

단일 객체 삽입, 갱신, 삭제만으로 충분한 사용 사례도 있다. 하지만 많은 다른 경우에는 여러 개의 다른 객체에 실행되는 쓰기 작업은 코디네이션돼야 한다.

- 관계형 데이터 모델에서 테이블의 로우는 종종 다른 테이블의 로우를 참조하는 외래 키를 갖는다. 다중 객체 트랜잭션은 참조가 유효한 상태로 유지되도록 보장해준다. 서로 참조하는 여러 레코드를 삽입할 때 참조 키는 올바라야 하고 최신 정보를 반영해야 한다. 그렇지 않으면 데이터가 비정상적으로 만들어진다.
- 문서 데이터 모델에서는 함께 갱신돼야 하는 필드들이 단일 객체로 다뤄지는 동일한 문서 내에 존재하는 경우가 흔하다. 단일 문서를 갱신할 때는 다중 객체 트랜잭션이 필요 없다. 하지만 조인 기능이 없는 문서 데이터베이스는 비정규화를 장려하기도 한다.
- 보조 색인이 있는 데이터베이스에선 값을 변경할 때마다 색인도 갱신돼야 한다. 트랜잭션 관점에서 색인은 서로 다른 데이터베이스 객체다. 예를 들어 트랜잭션 격리성이 없으면 어떤 색인에서는 레코드가 보이지만 다른 색인은 아직 갱신되지 않아서 레코드가 보이지 않을 수 있다.

트랜잭션이 없더라도 이런 애플리케이션들을 구현할 수 있다. 하지만 원자성이 없으면 오류 처리가 훨씬 더 복잡해지고 격리성이 없으면 동시성 문제가 생길 수 있다.

#### 오류와 어보트 처리
**트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다. ACID 데이터베이스는 이 철학을 바탕으로 한다.** 데이터베이스가 원자성, 격리성, 또는 지속성 보장을 위반할 위험이 있으면 트랜잭션이 절반 정도 완료된 상태에 머물게 하는 대신 트랜잭션을 완전히 폐기한다.

하지만 모든 시스템이 이 철학을 따르지는 않는다. 데이터베이스는 가능한 모든 것을 할 것이며 그 때문에 오류가 발생하면 이미 한 일은 취소하지 않는다. 따라서 오류 복구는 애플리케이션에게 책임이 있다.

어보트의 취지는 안전하게 재시도를 할 수 있게 하는 데 있기 때문이다.

어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지는 않다.

- 트랜잭션이 실제로는 성공했지만 서버가 클라이언트에게 커밋 성공을 알리는 도중 네트워크가 끊겼을 때 재시도하면 트랜잭션이 두 번 실행된다. 애플리케이션에 추가적인 중복 제거 메커니즘이 없다면 말이다.
- 오류가 과부하 때문이라면 트랜잭션 재시도는 문제를 개선하는 게 아니라 악화시킬 수 있다. 이런 피드백 주기를 피하려면 재시도 횟수를 제한하든지 지수적 백오프를 사용하거나 과부화와 관련된 오류를 다른 오류와 별도로 처리하는 방법을 쓸 수 있다.
- 일시적인 오류만 재시도할 가치가 있으며 영구적인 오류는 재시도해도 아무 소용이 없다.
- 트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션이 어보트될 때도 부수 효과가 실행될 수 있다. 여러 개의 다른 시스템들이 함께 커밋되거나 어보트되게 만들고 싶다면 2PC가 도움이 될 수도 있다.
- 클라이언트 프로세스가 재시도 중에 죽어버리면 그 클라이언트에서 데이터베이스에 쓰려고 했던 데이터가 모두 손실된다.

## 완화된 격리 수준
