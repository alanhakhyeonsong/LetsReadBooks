# 7장. 트랜잭션
현실 세계에서 데이터 시스템은 여러 가지 문제가 생길 수 있다.

- 데이터베이스 소프트웨어나 하드웨어는 쓰기 연산이 실행 중일 때를 포함해서 언제라도 실패할 수 있다.
- 애플리케이션은 연속된 연산이 실행되는 도중도 포함해서 언제라도 죽을 수 있다.
- 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있다.
- 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
- 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.
- 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

시스템이 신뢰성을 지니려면 이런 결함을 처리해서 전체 시스템의 치명적인 장애로 이어지는 것을 막아야 한다. 그러나 내결함성을 갖춘 시스템을 구현하려면 할 일이 많다. 잘못될 수 있는 모든 것에 대해 신중하게 생각해야 하며 테스트를 여러 번 해서 해결책이 실제로 동작하는지 확인해야 한다.

수십년 동안 트랜잭션은 이런 문제를 단순화하는 메커니즘으로 채택돼 왔다. **트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.**

- 개념적으로 한 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행된다.
- 트랜잭션은 전체가 성공(commit)하거나 실패(rollback)한다.
- 트랜잭션이 실패하면 애플리케이션에서 안전하게 재시도할 수 있다.

트랜잭션을 쓰면 애플리케이션에서 오류 처리를 하기 훨씬 단순해진다. 어떤 연산은 성공하고 어떤 연산은 실패하는 경우처럼 부분적인 실패를 걱정할 필요가 없기 때문이다.

트랜잭션은 데이터베이스에 접속하는 애플리케이션에서 **프로그래밍 모델을 단순화**하려는 목적으로 만든 것이다. 트랜잭션을 사용함으로써 애플리케이션에서 어느 정도의 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있다. 데이터베이스에서 대신 이런 일을 도맡아 주기 때문이다.

모든 애플리케이션에서 트랜잭션이 필요하진 않으며 때로는 트랜잭션적인 보장을 완화하거나 아예 쓰지 않는 게 이득이다. (성능을 향상시키거나 가용성을 높일 수 있다.) 어떤 안정성 속성은 트랜잭션 없이도 보장될 수 있다.

## 애매모호한 트랜잭션의 개념
현대의 거의 모든 관계형 데이터베이스와 일부 비관계형 데이터베이스는 트랜잭션을 지원한다.

2000년대 후반 NoSQL 데이터베이스가 인기를 얻기 시작했다. 이들은 새로운 데이터 모델을 선택할 수 있게 하고 기본적으로 복제와 파티셔닝 기능을 제공함으로써 관계형 데이터베이스의 현 상황을 개선하는 것을 목표로 했다. 새로운 세대의 데이터베이스 중 다수는 트랜잭션을 완전히 포기하거나 과거에 인식되던 것보다 훨씬 약한 보장을 의미하는 단어로 트랜잭션의 의미를 재정의했다.

### ACID의 의미
트랜잭션이 제공하는 안전성 보장은 흔히 **원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 의미하는 약어인 ACID로 잘 알려져 있다.**

그러나 현실에선 데이터베이스마다 ACID 구현이 제각각이다. 격리성의 의미 주변에는 모호함이 많이 있다.

#### 원자성
일반적으로 원자적이란 더 작은 부분으로 쪼갤 수 없는 뭔가를 가리킨다. **시스템은 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며 그 중간 상태에는 머물 수 없다.**

ACID의 원자성은 클라이언트가 쓰기 작업 몇 개를 실행하려 하는데 그중 일부만 처리된 후 결함이 생기면 무슨일이 생기는지 설명한다. 여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함 때문에 commit 될 수 없다면 abort되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소해야 한다.

원자성 없이는 여러 변경을 적용하는 도중 오류가 발생하면 어떤 변경은 효과가 있고 어떤 것은 그렇지 않은지 알기 어렵다. 애플리케이션에서 재시도할 수 있지만 동일한 변경이 두 번 실행돼서 중복되거나 잘못된 데이터가 만들어지기 쉽다. 원자성은 이 문제를 단순하게 만들어준다. 트랜잭션이 어보트됐다면 애플리케이션에서 이 트랜잭션이 어떤 것도 변경하지 않았음을 알 수 있으므로 안전하게 재시도할 수 있다.

#### 일관성
ACID 일관성의 아이디어는 **항상 진실이어야 하는, 데이터에 관한 어떤 선언이 있다는 것이다.** 그러나 일관성의 아이디어는 애플리케이션의 불변식 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다. 이는 데이터베이스가 보장할 수 있는게 아니다. 데이터베이스는 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다.

원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 일관성은 애플리케이션의 속성이다.

#### 격리성
대부분 동시에 여러 클라이언트에서 데이터베이스에 접속한다. 클라이언트들이 데이터베이스의 다른 부분을 읽고 쓰면 아무 문제가 없지만 동일한 데이터베이스 레코드에 접근하면 동시성 문제에 맞닥뜨리게 된다.

**ACID에서 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다.** 트랜잭션은 다른 트랜잭션을 방해할 수 없다. 고전적인 데이터베이스 교과서에선 격리성을 직렬성이라는 용어로 공식화한다. 직렬성은 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인 것처럼 동작할 수 있다는 것을 의미한다. 데이터베이스는 실제로 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/9c7b4b9a-fefc-491f-970d-6d1ad8b7ded1)

#### 지속성
데이터베이스 시스템의 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공하는 것이다. **지속성은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.**

단일 노드 데이터베이스에서 지속성은 일반적으로 데이터가 하드디스크나 SSD 같은 비휘발성 저장소에 기록됐다는 뜻이다. 보통 디스크에 저장된 데이터 구조가 오염됐을 때 복구할 수 있게 해주는, 쓰기 전 로그나 비슷한 수단을 동반한다. 복제 기능이 있는 데이터베이스에서 지속성은 데이터가 성공적으로 다른 노드 몇 개에 복사됐다는 것을 의미할 수 있다. **지속성을 보장하려면 데이터베이스는 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야 한다.**

### 단일 객체 연산과 다중 객체 연산
ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야 하는지를 서술한다.

- 원자성  
  쓰기를 이어서 실행하는 도중 오류가 발생하면 트랜잭션은 어보트돼야 하고 그때까지 쓰여진 내용은 폐기돼야 한다. 다시 말해 데이터베이스는 전부 반영되거나 아무것도 반영되지 않는 것을 보장함으로써 부분 실패를 걱정할 필요가 없게 도와준다.
- 격리성  
  동시에 실행되는 트랜잭션들은 서로를 방해하지 말아야 한다. 예를 들어, 한 트랜잭션이 여러 번 쓴다면 다른 트랜잭션은 그 내용을 전부 볼 수 있든지 아무것도 볼 수 없든지 둘 중 하나여야 하고 일부분만 볼 수 있어서는 안 된다.

이 정의는 한 번에 여러 객체를 변경할 수 있다고 가정한다. **다중 객체 트랜잭션은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.** 어떤 사용자의 읽지 않은 메시지 개수를 보여주려면 다음과 같은 질의를 실행할 수 있다.

```sql
SELECT COUNT(*) FROM emails WHERE recipient_id = 2 AND unread_flag = true;
```

그러나 이메일이 많으면 이 질의가 너무 느려져 읽지 않은 메시지 개수를 별개의 필드에 저장하고 싶을 것이다(일종의 비정규화). 이제 새 메시지가 올 때마다 읽지 않은 메시지 개수도 증가시켜야 하고, 메시지를 읽었다고 표시할 때마다 읽지 않은 메시지 개수도 감소시켜야 한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/dfc9fa1b-f679-4305-be9e-21f214560cce)

위 그림에선 사용자 2는 이상 현상을 경험한다. 격리성은 사용자 2가 삽입된 이메일과 갱신된 개수를 모두 보거나 모두 보지 못하게 하고 일관성이 깨진 중간 지점을 보는 일은 없게 해준다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/a77c3b65-94fd-4517-8da1-d5e47a148d26)

위 그림에선 원자성의 필요성이 설명돼 있다. 트랜잭션 실행 도중 어느 시점에서 오류가 발생하면 우편함의 내용과 읽지 않은 메시지 개수가 동기화되지 않을 수 있다. 원자적 트랜잭션에선 개수 갱신을 실패하면 트랜잭션이 어보트되고 삽입된 이메일은 롤백된다.

다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다. **관계형 데이터베이스에서 이것은 전형적으로 클라이언트와 데이터베이스 서버 사이의 TCP 연결을 기반으로 한다.** 어떤 특정 연결 내에서 `BEGIN TRANSACTION`문과 `COMMIT`문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여겨진다.

**반면 비관계형 데이터베이스는 이런식으로 연산을 묶는 방법이 없는 경우가 많다.** 다중 객체 API가 있더라도 반드시 트랜잭션 시맨틱을 뜻하지는 않는다. 어떤 키에 대한 연산은 성공하고 나머지 키에 대한 연산은 실패해서 데이터베이스가 부분적으로 갱신된 상태가 될 수 있다.

#### 단일 객체 쓰기
원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다. 예를 들어 20KB의 JSON 문서를 데이터베이스에 쓴다고 해보자.

- 첫 10KB를 보낸 후에 네트워크 연결이 끊기면 데이터베이스는 파싱 불가능한 10KB의 JSON 조각을 저장할 것인가?
- 데이터베이스가 디스크에 저장된 기존 값을 덮어쓰는 도중에 전원이 나가면 기존 값과 새 값이 함께 붙어 있게 될까?
- 문서를 쓰고 있을 때 다른 클라이언트에서 그 문서를 읽으면 부분적으로 갱신된 값을 읽게 될까?

저장소 엔진들은 거의 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다. 원자성은 장애 복구용 로그를 써서 구현할 수 있고 격리성은 각 객체에 잠금을 사용해 구현할 수 있다.

단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실을 방지하므로 유용하다. 그러나 일반적으로 쓰이는 의미의 트랜잭션이 아니다. compare-and-set과 다른 단일 객체 연산은 경량 트랜잭션으로 불리거나 심지어 마케팅 목적으로 ACID로 간주되기도 했지만 이런 용어는 오해의 소지가 있다. 트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘으로 이해된다.

#### 다중 객체 트랜잭션의 필요성
**많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했다.** 다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기가 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오도 있기 때문이다. **하지만 분산 데이터베이스에서 근본적으로 트랜잭션을 막는 것은 아무것도 없다.**

단일 객체 삽입, 갱신, 삭제만으로 충분한 사용 사례도 있다. 하지만 많은 다른 경우에는 여러 개의 다른 객체에 실행되는 쓰기 작업은 코디네이션돼야 한다.

- 관계형 데이터 모델에서 테이블의 로우는 종종 다른 테이블의 로우를 참조하는 외래 키를 갖는다. 다중 객체 트랜잭션은 참조가 유효한 상태로 유지되도록 보장해준다. 서로 참조하는 여러 레코드를 삽입할 때 참조 키는 올바라야 하고 최신 정보를 반영해야 한다. 그렇지 않으면 데이터가 비정상적으로 만들어진다.
- 문서 데이터 모델에서는 함께 갱신돼야 하는 필드들이 단일 객체로 다뤄지는 동일한 문서 내에 존재하는 경우가 흔하다. 단일 문서를 갱신할 때는 다중 객체 트랜잭션이 필요 없다. 하지만 조인 기능이 없는 문서 데이터베이스는 비정규화를 장려하기도 한다.
- 보조 색인이 있는 데이터베이스에선 값을 변경할 때마다 색인도 갱신돼야 한다. 트랜잭션 관점에서 색인은 서로 다른 데이터베이스 객체다. 예를 들어 트랜잭션 격리성이 없으면 어떤 색인에서는 레코드가 보이지만 다른 색인은 아직 갱신되지 않아서 레코드가 보이지 않을 수 있다.

트랜잭션이 없더라도 이런 애플리케이션들을 구현할 수 있다. 하지만 원자성이 없으면 오류 처리가 훨씬 더 복잡해지고 격리성이 없으면 동시성 문제가 생길 수 있다.

#### 오류와 어보트 처리
**트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다. ACID 데이터베이스는 이 철학을 바탕으로 한다.** 데이터베이스가 원자성, 격리성, 또는 지속성 보장을 위반할 위험이 있으면 트랜잭션이 절반 정도 완료된 상태에 머물게 하는 대신 트랜잭션을 완전히 폐기한다.

하지만 모든 시스템이 이 철학을 따르지는 않는다. 데이터베이스는 가능한 모든 것을 할 것이며 그 때문에 오류가 발생하면 이미 한 일은 취소하지 않는다. 따라서 오류 복구는 애플리케이션에게 책임이 있다.

어보트의 취지는 안전하게 재시도를 할 수 있게 하는 데 있기 때문이다.

어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지는 않다.

- 트랜잭션이 실제로는 성공했지만 서버가 클라이언트에게 커밋 성공을 알리는 도중 네트워크가 끊겼을 때 재시도하면 트랜잭션이 두 번 실행된다. 애플리케이션에 추가적인 중복 제거 메커니즘이 없다면 말이다.
- 오류가 과부하 때문이라면 트랜잭션 재시도는 문제를 개선하는 게 아니라 악화시킬 수 있다. 이런 피드백 주기를 피하려면 재시도 횟수를 제한하든지 지수적 백오프를 사용하거나 과부화와 관련된 오류를 다른 오류와 별도로 처리하는 방법을 쓸 수 있다.
- 일시적인 오류만 재시도할 가치가 있으며 영구적인 오류는 재시도해도 아무 소용이 없다.
- 트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션이 어보트될 때도 부수 효과가 실행될 수 있다. 여러 개의 다른 시스템들이 함께 커밋되거나 어보트되게 만들고 싶다면 2PC가 도움이 될 수도 있다.
- 클라이언트 프로세스가 재시도 중에 죽어버리면 그 클라이언트에서 데이터베이스에 쓰려고 했던 데이터가 모두 손실된다.

## 완화된 격리 수준
두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않으므로 안전하게 병렬 실행될 수 있다. **동시성 문제는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때만 나타난다.**

동시성 버그는 타이밍에 운이 없을 때만 촉발되기 때문에 테스트로 발견하기 어렵다. 타이밍 문제는 매우 드물게 발생할 수도 있으며 일반적으로 재현하기 어렵다. 동시성은 추론하기도 매우 어렵다.

그러한 까닭에 데이터베이스는 오랫동안 **트랜잭션 격리**를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다. 이론상으로 격리성은 동시성이 없는 것처럼 행동할 수 있으므로 개발자들의 부담을 줄여줘야 한다. **직렬성** 격리는 데이터베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것, 즉 동시성 없이 한 번에 트랜잭션 하나만 실행되는 것과 동일한 결과가 나오도록 보장한다는 것을 의미한다.

하지만 격리가 그리 간단하지 않다. 직렬성 격리는 성능 비용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않는다. 따라서 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지는 않는, 완화된 격리 수준을 사용하는 시스템들이 흔하다. 이런 격리성 수준은 이해하기 훨씬 더 어렵고 미묘한 버그를 유발할 수 있음에도 현장에서 사용된다. 인기 있는 관계형 데이터베이스 시스템조차 완화된 격리성을 사용하는 경우가 많아 이런 버그가 발생하는 것을 반드시 막아주지는 못한다.

맹목적으로 도구에 의존하기보단 존재하는 동시성 문제의 종류를 잘 이해하고 방지하는 방법을 배울 필요가 있다.

### 커밋 후 읽기
가장 기본적인 수준의 트랜잭션 격리는 **커밋 후 읽기(read committed)다.** 이 수준에선 두 가지를 보장해준다.

- 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다. (더티 읽기가 없다)
- 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다. (더티 쓰기가 없음)

#### 더티 읽기 방지
트랜잭션이 데이터베이스에 데이터를 썼지만 아직 커밋되거나 어보트되지 않았다고 하자. 다른 트랜잭션에서 커밋되지 않은 데이터를 볼 수 있을까? 만약 그렇다면 이를 **더티 읽기**라 부른다.

커밋 후 읽기 수준에서 실행되는 트랜잭션은 더티 읽기를 막아야 한다. **트랜잭션이 쓴 내용은 커밋된 후에야 다른 트랜잭션에게 보인다는 뜻이다.**

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/ce86c5af-664f-4906-96f8-07bf9f35beed)

더티 읽기를 막는 게 유용한 이유가 몇 가지 있다.

- 트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 다른 트랜잭션이 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있다. 부분적으로 갱신된 상태에 있는 데이터베이스를 보는 것은 사용자에게 혼란스러우며 다른 트랜잭션들이 잘못된 결정을 하는 원인이 될 수도 있다.
- 트랜잭션이 어보트되면 그때까지 쓴 내용은 모두 롤백돼야 한다. 데이터베이스가 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터, 즉 실제로는 데이터베이스에 결코 커밋되지 않을 데이터를 볼 수 있다.

#### 더티 쓰기 방지
두 트랜잭션이 데이터베이스에 있는 동일한 객체를 동시에 갱신하려고 하면 무슨 일이 생길까? 쓰기 순서가 어떻게 될지는 모르지만 일반적으로 나중에 쓴 내용이 먼저 쓴 내용을 덮어쓴다고 가정한다.

그러나 **먼저 쓴 내용이 아직 커밋되지 않은 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리면 어떻게 될까? 이를 더티 쓰기라 한다.** 커밋 후 읽기 격리 수준에서 실행되는 트랜잭션은 더티 쓰기를 방지해야 한다. **보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두 번째 쓰기를 지연시키는 방법을 사용한다.**

더티 쓰기를 막음으로써 이 격리 수준은 몇 가지 동시성 문제를 회피한다.

- 트랜잭션들이 여러 객체를 갱신하면 더티 쓰기는 나쁜 결과를 유발할 수 있다. 커밋 후 읽기는 이런 사고를 막아준다.
- 그러나 커밋 후 읽기는 두 번의 카운터 증가 사이에 발생하는 경쟁 조건은 막지 못한다. 이 경우는 첫 번째 트랜잭션이 커밋된 후 두 번째 쓰기가 일어났으므로 더티 쓰기가 아니다. 이유는 다르다. 갱신 손실 방지에서 이런 작업을 안전하게 만들 수 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/15511eb6-280c-4261-bf6b-e1279a672b3b)

#### 커밋 후 읽기 구현
커밋 후 읽기는 매우 널리 쓰이는 격리 수준이다. Oracle 11g, PostgresSQL, SQL Server 2012과 다른 여러 데이터베이스에선 기본 설정이다.

**가장 흔한 방법으로 데이터베이스는 로우 수준 잠금을 사용해 더티 쓰기를 방지한다.** 트랜잭션에서 특정 객체를 변경하고 싶다면 먼저 해당 객체에 대한 잠금을 획득해야 한다. 그리고 트랜잭션이 커밋되거나 어보트될 때까지 잠금을 보유하고 있어야 한다. 오직 한 트랜잭션만 어떤 주어진 객체에 대한 잠금을 보유할 수 있다. 다른 트랜잭션에서 동일한 객체에 쓰기를 원한다면 첫 번째 트랜잭션이 커밋되거나 어보트된 후에야 잠금을 얻어 진행할 수 있다. 이런 잠금은 커밋 후 읽기 모드 또는 더 강한 격리 수준에서 데이터베이스에 의해 자동으로 실행된다.

더티 읽기를 막을 수 있는 한 가지 선택은 **동일한 잠금을 써서 객체를 읽기 원하는 트랜잭션이 잠시 잠금을 획득한 후 읽기가 끝난 후 바로 해제하게 하는 것이다.** 이렇게 하면 객체가 변경됐으나 아직 커밋되지 않은 값을 갖고 있을 때 읽기가 실행되지 않도록 보장할 수 있다.

그러나 읽기 잠금을 요구하는 방법은 현실에선 잘 동작하지 않는다. 읽기만 실행하는 여러 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될 때까지 기다려야 할 수 있기 때문이다. 읽기만 실행하는 트랜잭션들의 응답 시간에 해를 끼치며 운용성이 나쁘다. 잠금 대기 때문에 애플리케이션 일부에서 발생한 지연이 애플리케이션의 완전히 다른 부분에 연쇄 효과를 미칠 수 있다.

대부분의 데이터베이스는 쓰여진 모든 객체에 대해 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값 모두를 기억한다. 해당 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거의 값을 읽게 된다. 새 값이 커밋돼야만 다른 트랜잭션들이 새 값을 읽을 수 있게 된다.

### 스냅숏 격리와 반복 읽기
커밋 후 읽기 격리를 피상적으로 보면 트랜잭션이 해야 하는 모든 일을 해 주는 것으로 생각하는 것도 무리가 아니다. 어보트를 허용하고 트랜잭션의 미완료된 결과를 읽는 것을 방지하며 동시에 실행되는 쓰기가 섞이는 것을 막아준다. 이런 것들은 정말로 유용한 특성이며 트랜잭션을 지원하지 않는 시스템에서 얻을 수 있는 것보다 훨씬 더 강력한 보장을 해준다.

**그러나 이 격리 수준을 사용하더라도 동시성 버그가 생길 수 있는 경우가 아직 많이 남아 있다.** 아래 그림은 커밋 후 읽기를 사용할 때 발생할 수 있는 문제가 나와 있다.

<img width="481" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/c3627b6e-e454-4a3d-9327-9df369d6f466">

이런 이상 현상을 **비반복 읽기(nonrepeatable read)나 읽기 스큐(read skew)라고 한다.** 앨리스가 트랜잭션이 끝난 시점에 계좌 1의 잔고를 읽으면 이전 질의에서 봤던 것과는 다른 값(600달러)을 보게 된다. 읽기 스큐는 커밋 후 읽기 격리에선 받아들일 수 있는 것으로 여겨진다. 앨리스가 봤던 계좌 잔고들은 읽은 시점에 실제로 커밋된 상태였다. 하지만 지속적인 문제는 아니다. 몇 초 후 새로고침하면 거의 일관성 있는 계좌 잔고를 볼 가능성이 높기 때문이다. 그러나 어떤 상황에서는 이런 일시적인 비일관성을 감내할 수 없는 경우도 있다.

- 백업  
  백업을 하려면 데이터베이스 전체의 복사본을 만들어야 하는데 데이터베이스가 크면 몇 시간이 걸릴 수도 있다. 백업 프로세스가 실행되는 동안에도 계속 데이터베이스에 쓰기가 실행된다. 따라서 백업의 일부는 데이터의 과거 버전을, 다른 부분은 새 버전을 갖고 있을 수 있다. 이런 백업을 사용해서 복원하면 비일관성이 영속적이게 된다.
- 분석 질의와 무결성 확인  
  데이터베이스의 큰 부분을 스캔하는 질의를 실행하고 싶을 때가 있다. 이런 질의는 분석 작업에서 흔하거나 모든 것이 순차적으로 실행되는 주기적인 무결성 확인의 일부일 수도 있다. 이런 질의는 다른 시점의 데이터베이스 일부를 보게 되면 불합리한 결과를 반환할 수도 있다.

**스냅숏 격리는 이런 문제의 가장 흔한 해결책이다.** 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다. 즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다. 데이터가 나중에 다른 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다.

스냅숏 격리는 백업이나 분석처럼 실행하는 데 오래 걸리며 읽기만 실행하는 질의에 요긴하다. 질의가 실행 중일 때 동시에 대상 데이터가 변경된다면 그 질의의 의미에 대해 추론하기 매우 어렵다. 트랜잭션이 특정 시점에 고정된 데이터베이스의 일관된 스냅숏만 볼 수 있다면 이해하기 훨씬 쉬워진다.

스냅숏 격리는 널리 쓰인다. PostgresSQL, MySQL InnoDB 엔진, Oracle, SQL Server 등에서 지원된다.

#### 스냅숏 격리 구현
**스냅숏 격리 구현은 커밋 후 읽기 격리처럼 전형적으로 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용한다.** 쓰기를 실행하는 트랜잭션은 같은 객체에 쓰는 다른 트랜잭션의 진행을 차단할 수 있다는 뜻이다. 그러나 읽을 때는 아무 잠금도 필요 없다.

성능 관점에서 스냅숏 격리의 핵심 원리는 **읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다**는 것이다. 따라서 데이터베이스는 잠금 경쟁 없이 쓰기 작업이 일상적으로 처리되는 것과 동시에 일관성 있는 스냅숏에 대해 오래 실행되는 읽기 작업을 처리할 수 있다.

스냅숏 격리를 구현하기 위해 데이터베이스는 더티 읽기를 막는 데 쓰는 메커니즘을 일반화한 방법을 사용한다. 데이터베이스는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다. 진행 중인 여러 트랜잭션에서 서로 다른 시점의 데이터베이스 상태를 봐야 할 수도 있기 때문이다. **데이터베이스가 객체의 여러 버전을 함께 유지하므로 이 기법은 다중 버전 동시성 제어(multi-version concurrrency control, MVCC)라고 한다.**

데이터베이스가 스냅숏 격리가 아니라 커밋 후 읽기 격리만 제공할 필요가 있다면 객체마다 버전 두 개씩만 유지하면 충분하다. 바로 커밋된 버전과 덮어 쓰여졌지만 아직 커밋되지 않은 버전이다. 그러나 스냅숏 격리를 지원하는 저장소 엔진은 보통 커밋 후 읽기 격리를 위해서도 MVCC를 사용한다. **전형적인 방법은 커밋 후 읽기는 질의마다 독립된 스냅숏을 사용하고 스냅숏 격리는 전체 트랜잭션에 대해 동일한 스냅숏을 사용하는 것이다.**

<img width="514" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/5c3ba971-d980-43e8-a6d0-ce6a16e43781">

다른 구현도 비슷하지만, 위 그림에선 PostgresSQL에서 MVCC 기반 스냅숏 격리를 어떻게 구현했는지 설명돼 있다. 트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID(txid)를 할당받는다. 트랜잭션이 데이터베이스에 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션의 ID가 함께 붙는다.

테이블의 각 로우에는 그 로우를 테이블에 삽입한 트랜잭션의 ID를 갖는 `created_by` 필드가 있다. 또 각 로우에는 처음에는 비어있는 `deleted_by` 필드도 있다. 트랜잭션이 로우를 삭제하면 실제로 데이터베이스에서 지우지 않고 `deleted_by` 필드를 삭제 요청 트랜잭션의 ID로 설정함으로써 지워졌다고 표시한다. 나중에 아무 트랜잭션도 더 이상 삭제된 데이터에 접근하지 않는 게 확실해지면 데이터베이스의 가비지 컬렉션 프로세스가 지워졌다 표시된 로우들을 삭제해서 사용량을 줄인다. **갱신은 내부에서 삭제와 생성으로 변환된다.**

#### 일관된 스냅숏을 보는 가시성 규칙
트랜잭션은 데이터베이스에서 객체를 읽을 때 트랜잭션 ID를 사용해 어떤 것을 볼 수 있고 어떤 것을 볼 수 없는지 결정한다. 면밀하게 가시성 규칙을 정의함으로써 데이터베이스는 데이터베이스의 일관된 스냅숏을 애플리케이션에게 제공할 수 있다.

1. 데이터베이스는 각 트랜잭션을 시작할 때 그 시점에 진행 중인 모든 트랜잭션의 목록을 만든다. 이 트랜잭션들이 쓴 데이터는 모두 무시된다. 설령 데이터를 쓴 트랜잭션이 나중에 커밋되더라도 마찬가지다.
2. 어보트된 트랜잭션이 쓴 데이터는 모두 무시된다.
3. 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계 없이 모두 무시된다.
4. 그 밖의 모든 데이터는 애플리케이션의 질의로 볼 수 있다.

이 규칙들은 객체 생성과 삭제 모두에 적용된다.

다시 말해 아래 두 조건이 모두 참이면 객체를 볼 수 있다.

- 읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태였다.
- 읽기 대상 객체가 삭제된 것으로 표시되지 않았다. 또는 삭제된 것으로 표시됐지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않았다.

오래 실행되는 트랜잭션은 오랫동안 스냅숏을 사용해서 덮어써지거나 삭제된 지 오래된 값을 계속 읽을 수도 있다. 데이터베이스는 갱신할 때 값을 교체하지 않고 값이 바뀔 때마다 새 버전을 생성함으로써 작은 오버헤드만 유발하면서 일관된 스냅숏을 제공할 수 있다.

#### 색인과 스냅숏 격리
다중 버전 데이터베이스에서 색인은 어떻게 동작할까? 하나의 선택지는 단순하게 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 하는 것이다. 가비지 컬렉션이 어떤 트랜잭션에게도 더 이상 보이지 않는 오래된 객체 버전을 삭제할 때 대응되는 색인 항목도 삭제된다.

현실에선 여러 구현 세부 사항에 따라 다중 버전 동시성 제어의 성능이 결정된다. **이를테면 PostgresSQL은 동일한 객체의 다른 버전들이 같은 페이지에 저장될 수 있다면 색인 갱신을 회피하는 최적화를 한다.**

추가 전용 B Tree를 사용하면 쓰기를 실행하는 모든 트랜잭션은 새로운 B Tree 루트를 생성하며 특정 루트는 그것이 생성된 시점에 해당하는 데이터베이스의 일관된 스냅숏이 된다. 나중에 실행된느 쓰기는 새로운 트리 루트만 생성할 수 있고 존재하는 B Tree를 변경할 수 없으므로 트랜잭션 ID를 기반으로 객체를 걸러낼 필요가 없다. 그러나 이 방법도 컴팩션과 가비지 컬렉션을 실행하는 백그라운드 프로세스가 필요하다.

#### 반복 읽기와 혼란스러운 이름
스냅숏 격리는 유용한 격리 수준이며 특히 읽기 전용 트랜잭션에 유용하다. 그러나 이를 구현한 많은 데이터베이스에서 다른 이름을 사용한다.

- Oracle: 직렬성
- PostgresSQL, MySQL: 반복 읽기(repeatable read)

### 갱신 손실 방지
더티 쓰기 외에도 동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 몇 가지 충돌이 더 있다. 이 중 가장 널리 알려진 것은 **갱신 손실** 문제이며 앞서 두 트랜잭션이 동시에 카운터를 증가시키는 예제로 설명했다.

**갱신 손실 문제는 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생할 수 있다.** 만약 두 트랜잭션이 이 작업을 동시에 하면 두 번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있다. 이런 패턴은 다양한 시나리오에서 발생한다.

- 카운터를 증가시키거나 계좌 잔고를 갱신한다. (현재 값을 읽어 새 값을 계산하고 갱신된 값을 다시 써야 한다)
- 복잡한 값을 지역적으로 변경한다. 예를 들어 JSON 문서 내에 있는 리스트에 엘리먼트를 추가한다. (문서를 파싱해서 변경하고 변경된 문서를 다시 써야 한다)
- 사용자가 편집한 내용을 저장할 때 전체 페이지 내용을 서버에 보내 현재 데이터베이스에 저장된 내용을 덮어 쓰도록 만들어진 위키에서 두 명의 사용자가 동시에 같은 페이지를 편집한다.

#### 원자적 쓰기 연산
여러 데이터베이스에서 원자적 갱신 연산을 제공한다. 이 연산은 애플리케이션 코드에서 read-modify-write 주기를 구현할 필요를 없애 준다. 보통 가장 좋은 해결책이다. 다음 명령은 대부분의 RDBMS에서 동시성 안전하다.

```sql
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

MongoDB 같은 문서 데이터베이스는 JSON 문서의 일부를 지역적으로 변경하는 원자적 연산을 제공하고 Redis는 우선순위 큐 같은 데이터 구조를 변경하는 원자적 연산을 제공한다. 모든 쓰기가 쉽게 원자적 연산으로 표현되진 않는다. 그러나 원자적 연산이 사용될 수 있는 상황에선 이들이 보통 최선의 선택이다.

**원자적 연산은 보통 객체를 읽을 때 그 객체에 독점적인 잠금을 획득해서 구현한다. 그래서 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못하게 한다.** 이 기법을 **커서 안정성**이라 부르기도 한다. 다른 선택지는 그냥 모든 원자적 연산을 단일 스레드에서 실행되도록 강제하는 것이다.

불행하게도 ORM 프레임워크를 사용하면 뜻하지 않게 데이터베이스가 제공하는 원자적 연산을 사용하는 대신 불안전한 read-modify-write 주기를 실행하는 코드를 작성하기 쉽다. 잠재적으로는 테스트로 발견하기 어려운 미묘한 버그의 원인이 될 수 있다.

#### 명시적인 잠금
DB에서 내장된 원자적 연산이 필요한 기능을 제공하지 않을 때 갱신 손실을 막는 또 다른 선택지는 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것이다. 그러면 애플리케이션이 read-modify-write 주기를 수행할 수 있고 다른 트랜잭션이 동시에 같은 객체를 읽으려 하면 첫 번째 해당 주기가 완료될 때까지 기다리도록 강제한다.

```sql
BEGIN TRANSACTION;

SELECT * FROM figures
  WHERE name = 'robot' AND game_id = 222
  FOR UPDATE;

-- 유효한지 확인한 후
-- 이전의 SELECT에서 반환된 것의 위치를 갱신한다.
UPDATE figures SET position = 'c4' WHERE id = 1234;

COMMIT;
```

> `FOR UPDATE` 절은 데이터베이스가 이 질의에 의해 반환된 모든 로우에 잠금을 획득해야 함을 가리킨다.

이 방법은 동작하지만 올바르게 동작하게 하려면 애플리케이션 로직에 대해 신중하게 생각해야 한다. 코드의 어딘가에 필요한 잠금을 추가하는 것을 잊어버려 경쟁 조건을 유발하기 쉽다.

#### 갱신 손실 자동 감지
이 외에 대안으로 이들의 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트시키고 read-modify-write 주기를 재시도하도록 강제하는 방법이 있다.

이 방법의 이점은 데이터베이스가 이 확인을 스냅숏 격리와 결합해 효율적으로 수행할 수 있다는 것이다. 실제로 PostgresSQL의 반복 읽기, Oracle의 직렬성, SQL 서버의 스냅숏 격리 수준은 갱신 손실이 발생하면 자동으로 발견해서 문제가 되는 트랜잭션을 어보트시킨다. 그러나 MySQL InnoDB의 반복 읽기는 갱신 손실을 감지하지 않는다.

갱신 손실 감지는 애플리케이션 코드에서 어떤 특별한 데이터베이스 기능도 쓸 필요가 없게 도와주므로 매우 좋은 기능이다. 잠금이나 원자적 연산을 쓰는 것을 잊어버려서 버그를 유발할 수는 있지만 자동으로 갱신 손실이 감지되어 오류가 덜 방지하게 해준다.

#### compare-and-set
트랜잭션을 제공하지 않는 데이터베이스 중에는 원자적 compare-and-set 연산을 제공하는 것도 있다. 이 연산의 목적은 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것이다. 현재 값이 이전에 읽은 값과 일치하지 않으면 갱신은 반영되지 않고 read-modify-write 주기를 재시도해야 한다.

```sql
UPDATE wiki_pages SET content = 'new content'
  WHERE id = 1234 AND content = 'old content';
```

내용이 바뀌어서 더는 `old content`와 일치하지 않으면 이 갱신은 적용되지 않는다. 따라서 갱신이 적용됐는지 확인하고 필요하다면 재시도해야 한다. 그러나 DB가 `WHERE` 절이 오래된 스냅숏으로부터 읽는 것을 허용한다면 이 구문은 갱신 손실을 막지 못할 수도 있다. 동시에 다른 쓰기 작업이 실행되고 있더라도 조건이 참이 될 수 있기 때문이다.

#### 충돌 해소와 복제
복제가 적용된 데이터베이스에서 갱신 손실을 막는 것은 다른 차원의 문제다. 여러 노드에 데이터의 복사본이 있어서 데이터가 다른 노드들에서 동시에 변경될 수 있으므로 갱신 손실을 방지하려면 추가 단계가 필요하다.

잠금과 compare-and-set 연산은 데이터의 최신 복사본이 하나만 있다고 가정한다. 그러나 **다중 리더 또는 리더 없는 복제를 사용하는 데이터베이스는 일반적으로 여러 쓰기가 동시에 실행되고 비동기식으로 복제되는 것을 허용하므로 데이터의 최신 복사본이 하나만 있으리라 보장할 수 없다.**

이렇게 복제가 적용된 데이터베이스에서 흔히 쓰는 방법은 **쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 충돌된 버전을 생성하는 것을 허용하고 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합하는 것이다.**

원자적 연산은 복제 상황에서도 잘 동작한다. 반면 최종 쓰기 승리 충돌 해소 방법은 갱신 손실이 발생하기 쉽다. 많은 복제 데이터베이스는 최종 쓰기 승리가 기본 설정이다.

### 쓰기 스큐와 팬텀
아래 예시는 의사들이 병원에서 교대로 서는 호출 대기를 관리하는 애플리케이션에서의 예시다. 거의 동시에 호출 대기 상태를 끄는 버튼을 클릭했을 경우 일어날 수 있는 상황이다.

<img width="525" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/fcaabea0-f4d4-4d6b-b206-a908041cd3dc">

각 트랜잭션에서 애플리케이션은 먼저 현재 두 명 이상의 의사가 대기 중인지 확인한다. 만약 그렇다면 의사 한 명이 호출 대기에서 빠져도 안전하다고 가정한다. 데이터베이스에서 스냅숏 격리를 사용하므로 둘 다 2를 반환해서 두 트랜잭션 모두 다음 단계로 진행한다. 앨리스는 대기 상태를 끄도록 자신의 레코드를 갱신하고 밥도 같은 식으로 자신의 레코드를 갱신한다. 두 트랜잭션 모두 커밋되고 호출 대기하는 의사가 한 명도 없게 된다. 최소 한 명의 의사가 호출 대기해야 한다는 요구사항을 위반했다.

#### 쓰기 스큐를 특징짓기
위와 같은 이상 현상을 **쓰기 스큐(write skew)** 라고 한다. 두 트랜잭션이 두 개의 다른 객체를 갱신하므로 더티 쓰기도 갱신 손실도 아니다. 여기선 충돌이 발생했다는 것이 덜 명백해 보이지만 분명히 경쟁 조건이다. 만약 두 트랜잭션이 한 번에 하나씩 실행됐다면 두 번째 의사는 호출 대기를 끄는 게 방지됐을 것이다. 트랜잭션이 동시에 실행됐기 때문에 이상 동작이 나타날 수 있었다.

**쓰기 스큐는 두 트랜잭션이 같은 객체들을 읽어 그중 일부를 갱신할 때 나타날 수 있다. 다른 트랜잭션이 하나의 동일한 객체를 갱신하는 특별한 경우에 타이밍에 따라 더티 쓰기나 갱신 손실 이상 현상을 겪게 된다.**

쓰기 스큐를 막는 방법의 선택지는 더 제한돼있다.

- 여러 객체가 관련되므로 원자적 단일 객체 연산은 도움이 되지 않는다.
- 일부 스냅숏 격리 구현에서 제공되는 갱신 손실 자동 감지도 도움 되지 않는다. 쓰기 스큐는 PostgresSQL의 반복 읽기, MySQL InnoDB의 반복 읽기, Oracle의 직렬성, SQL Server의 스냅숏 격리 수준에서 자동으로 감지되지 않는다. 쓰기 스큐를 자동으로 방지하려면 진짜 직렬성 격리가 필요하다.
- 어떤 데이터베이스에선 제약 조건을 설정할 수 있다. 제약 조건은 데이터베이스에 의해 엄격하게 준수된다. 그러나 최소 한 명의 의사가 호출 대기를 해야 한다고 명시하려면 여러 객체와 연관된 제약 조건이 필요하다. 대부분의 데이터베이스는 이런 제약 조건 지원을 내장하지 않지만 데이터베이스에 따라 트리거나 구체화 뷰를 사용해 구현할 수 있다.
- 직렬성 격리 수준을 사용할 수 없다면 트랜잭션이 의존하는 로우를 명시적으로 잠그는 것이 차선책이다.

```sql
BEGIN TRANSACTION;

SELECT * FROM doctors
  WHERE on_call = true
  AND shift_id = 1234 FOR UPDATE;

UPDATE doctors
  SET on_call = false
  WHERE name = 'Alice'
  AND shift_id = 1234;

COMMIT;
```

#### 추가적인 쓰기 스큐의 예
- 회의실 예약 시스템
  - 동시에 같은 회의실을 중복 예약할 수 없게 하고 싶다 가정해보자. 누군가 예약을 하려고 할 때 먼저 충돌하는 예약이 있는지 확인하고, 없다면 회의를 예약한다.
  - 스냅숏 격리는 다른 사용자가 동시에 충돌되는 회의를 삽입하는 것을 막아줄 수 없다. 스케줄이 충돌하지 않도록 보장하려면 다시 한 번 직렬성 격리가 필요하다.
- 다중플레이어 게임
  - 잠금은 플레이어들이 두 개의 다른 물체를 게임판 위의 같은 위치로 옮기거나 잠재적으로 게임의 규칙을 위반하는 다른 이동을 하는 것을 막아주지 않는다. 준수하고자 하는 규칙의 종류에 따라 유일성 제약을 쓸 수 있을지도 모르지만 그렇지 않으면 쓰기 스큐에 취약하다.
- 사용자명 획득
  - 각 사용자가 유일한 사용자명을 가져야 하는 웹사이트에서 두 명의 사용자가 동시에 같은 사용자명으로 계정 생성을 시도할 수 있다. 트랜잭션을 사용해 이름이 점유됐는지 확인하고 그렇지 않다면 그 이름으로 계정을 생성할 수 있다. 하지만 스냅숏 격리에선 안전하지 않다. 이 예시에선 유일성 제약 조건이 간단한 해결책이다.
- 이중 사용 방지
  - 사용자가 돈이나 포인트를 지불할 수 있는 서비스는 사용자가 갖고 있는 것보다 더 많이 지불하지 않는지 확인해야 한다. 지불 예정 항목을 사용자 계좌에 삽입하고 그 계좌에 있는 모든 항목을 나열한 후 그 합이 양수인지 확인하는 방법으로 구현하려고 할 수도 있다. 쓰기 스큐가 발생하면 동시에 삽입된 두 개의 지불 항목이 모여 잔고가 음수가 되게 하는 일이 생길 수 있지만 어떤 트랜잭션도 다른 쪽에 알려주지 못한다.

#### 쓰기 스큐를 유발하는 팬텀
이 모든 예는 비슷한 패턴을 따른다.

1. `SELECT` 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인한다.
2. 첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정한다.
3. 애플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고 트랜잭션을 커밋한다. 이 쓰기의 효과로 2단계를 결정한 전제 조건이 바뀐다. 다시 말해 쓰기를 커밋한 후 1단계의 `SELECT` 질의를 재실행하면 다른 결과를 얻게 된다. 쓰기의 결과로 검색 조건에 부합하는 로우 집합이 바뀌었기 때문이다.

이 과정은 다른 순서로 일어날 수도 있다. 먼저 쓰기를 실행한 후 `SELECT` 질의를 실행하고 마지막으로 그 질의 결과에 따라 어보트할지 커밋할지 결정할 수 있다.

이처럼 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 **팬텀**이라 한다. 스냅숏 격리는 읽기 전용 질의에선 팬텀을 회피하지만 읽기 쓰기 트랜잭션에선 팬텀이 쓰기 스큐의 특히 까다로운 경우를 유발할 수 있다.

#### 충돌 구체화
팬텀의 문제가 잠글 수 있는 객체가 없다는 것이라면 인위적으로 데이터베이스에 잠금 객체를 추가할 수 있지 않을까?

예를 들어 회의실 예약의 경우 시간 슬롯과 회의실에 대한 테이블을 만드는 것을 생각해볼 수 있다. 이 테이블의 각 로우는 특정한 시간 범위 동안 사용되는 특정한 회의실에 해당한다. 회의실과 시간 범위의 모든 조합에 대해 로우를 미리 만들어 둘 수 있다. 예약을 하는 트랜잭션은 테이블에서 원하는 회의실과 시간 범위에 해당하는 로우를 잠글 수 있다. 잠금을 획든한 후 전처럼 겹치는 예약이 있는지 확인하고 새 예약을 삽입할 수 있다. 추가된 테이블은 예약 정보를 저장하는 데 사용되지 않는다는 점을 주목하자. 단지 회의실과 시간 범위가 동일한 예약이 동시에 변경되는 것을 막는 데 사용되는 잠금의 모음일 뿐이다.

이런 방법을 **충돌 구체화**라고 한다. **팬텀을 데이터베이스에 존재하는 구체적인 로우 집합에 대한 잠금 충돌로 변환하기 때문이다.** 하지만 충돌을 구체화하는 방법은 알아내기 어렵고 오류가 발생하기 쉽다. 또한 동시성 제어 메커니즘이 애플리케이션 데이터 모델로 새어 나오는 것도 보기 좋지 않다. 따라서 이 방식은 최후의 수단으로 고려해야 한다. **대부분의 경우 직렬성 격리 수준이 훨씬 더 선호된다.**

### 직렬성
- 격리 수준은 이해하기 어렵고 데이터베이스마다 그 구현에 일관성이 없다.
- 애플리케이션 코드를 보고 특정한 격리 수준에서 해당 코드를 실행하는 게 안전한지 알기 어렵다. 특히 동시에 일어나는 모든 일을 알지 못할 수도 있는 거대한 애플리케이션이라면 더 그렇다.
- 경쟁 조건을 감지하는 데 도움이 되는 좋은 도구가 없다. 이론상으론 정적 분석이 도움될지 모르지만 아직 현실적으로 사용되는 연구 기법은 없다. 동시성 문제는 보통 비결정적이라서 테스트하기 어렵다. 타이밍이 좋지 못할 때만 문제가 발생한다.

위 문제들은 1970년대부터 있던 문제다. **직렬성** 격리를 사용하자.

직렬성 격리는 보통 가장 강력한 격리 수준이라 여겨진다. 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다. 따라서 데이터베이스는 트랜잭션을 개별적으로 실행할 때 올바르게 동작한다면 이들을 동시에 실행할 때도 올바르게 동작할 것을 보장해 준다. **즉 데이터베이스가 발생할 수 있는 모든 경쟁 조건을 막아준다.**

직렬성 격리가 여러 완화된 격리 수준보다 훨씬 좋지만 모두 그것을 사용하지 않는 이유가 있다. 이에 대해 살펴보자.

#### 실제적인 직렬 실행
동시성 문제를 피하는 가장 간단한 방법은 동시성을 완전히 제거하는 것이다. 한 번에 트랜잭션 하나씩만 직렬로 단일 스레드에서 실행하면 된다. 그러면 트랜잭션 사이의 충돌을 감지하고 방지하는 문제를 완전히 회피할 수 있다. 결과적으로 격리 수준은 당연히 직렬성 격리가 된다.

데이터베이스 설계자들은 상당히 최근이 돼서야 단일 스레드 루프에서 트랜잭션을 실행하는 게 실현 가능하다고 결론내렸다. 과거 30년 동안 높은 성능을 위해 다중 스레드 동시성이 필수적인 것으로 여겨졌다면 단일 스레드 실행이 가능하게 된 이유는 무엇일까?

- 램 가격이 저렴해져서 많은 사용 사례에서 활성화된 데이터셋 전체를 메모리에 유지할 수 있을 정도가 됐다. 트랜잭션이 접근해야 하는 모든 데이터가 메모리에 있다면 데이터를 디스크에서 읽어 오기를 기다려야 할 때보다 트랜잭션이 훨씬 빨리 실행될 수 있다.
- 데이터베이스 설계자들은 OLTP 트랜잭션이 보통 짧고 실행하는 읽기와 쓰기의 개수가 적다는 것을 깨달았다. 반대로 오래 실행되는 분석 질의는 전형적으로 읽기 전용이라 직렬 실행 루프 밖에서 스냅숏 격리를 사용해 일관된 스냅숏을 사용해 실행할 수 있다.

단일 스레드로 실행되도록 설계된 시스템이 동시성을 지원하는 시스템보다 성능이 나을 때도 있다. 잠금을 코디네이션하는 오버헤드를 피할 수 있기 때문이다. 그렇지만 이들의 처리량은 CPU 코어 하나의 처리량을 제한된다. 단일 스레드를 최대한 활용하려면 트랜잭션이 전통적인 형태와는 다르게 구조화돼야 한다.

#### 트랜잭션은 스토어드 프로시저 안에 캡슐화하기
데이터베이스의 초창기에는 데이터베이스 트랜잭션이 사용자 활동의 전체 흐름을 포함할 수 있게 하려는 의도가 있었다. 불행하게도 사람은 결정하는 것도 매우 느리다. 데이터베이스 트랜잭션이 사용자의 입력을 기다려야 한다면 데이터베이스는 대부분 유휴 상태지만 잠재적으로 매우 많은 동시 실행 트랜잭션을 지원해야 한다. **대부분의 데이터베이스는 이를 효율적으로 처리할 수 없어서 거의 모든 OLTP 애플리케이션은 트랜잭션 내에서 대화식으로 사용자 응답을 대기하는 것을 회피함으로써 트랜잭션을 짧게 유지한다. 웹의 경우 이것은 트랜잭션이 동일한 HTTP 요청 내에서 커밋된다는 뜻이다.** 트랜잭션은 여러 요청에 걸쳐서 실행되지 않는다. 새로운 HTTP 요청은 새로운 트랜잭션을 시작한다.

상호작용식 트랜잭션은 애플리케이션과 데이터베이스 사이의 네트워크 통신에 많은 시간을 소비한다. 데이터베이스에서 동시성을 허용하지 않고 한 번에 트랜잭션 하나씩만 처리하면 처리량은 끔찍할 것이다. 이런 종류의 데이터베이스에서 쓸 만한 성능을 얻으려면 여러 트랜잭션을 동시에 처리할 필요가 있다.

이런 까닭으로 단일 스레드에서 트랜잭션을 순차적으로 처리하는 시스템들은 상호작용하는 다중 구문 트랜잭션을 허용하지 않는다. 대신 애플리케이션은 트랜잭션 코드 전체를 **스토어드 프로시저** 형태로 데이터베이스에 미리 제출해야 한다.

<img width="514" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/46774971-9f9f-40e1-a39e-3c32f0d29698">

트랜잭션에 필요한 데이터는 모두 메모리에 있고 스토어드 프로시저는 네트워크나 디스크 I/O 대기 없이 매우 빨리 실행된다고 가정한다.

#### 스토어드 프로시저의 장단점
- 데이터베이스 벤더마다 제각각 스토어드 프로시저용 언어가 있다. 이 언어들은 범용 프로그래밍 언어의 발전을 따라잡지 못했다.
- 데이터베이스에서 실행되는 코드는 관리하기 어렵다. 애플리케이션 서버와 비교할 때 디버깅하기 어렵고 버전 관리 및 배포가 불편하며 테스트하기도 까다롭고 모니터링용 지표 수집 시스템과 통합하기도 어렵다.
- 데이터베이스는 애플리케이션 서버보다 훨씬 더 성능에 민감할 때가 많다. 흔히 여러 애플리케이션 서버에서 데이터베이스 인스턴스 하나를 공유하기 때문이다.

현대의 스토어드 프로시저 구현은 PL/SQL을 버리고 기존의 범용 프로그래밍 언어를 사용한다.

스토어드 프로시저가 있고 데이터가 메모리에 저장된다면 모든 트랜잭션을 단일 스레드에서 실행하는 게 현실성 있다. I/O 대기가 필요 없고 다른 동시성 제어 메커니즘의 오버헤드를 회피하므로 단일 스레드로 상당히 좋은 처리량을 얻을 수 있다.

#### 파티셔닝
모든 트랜잭션을 순차적으로 실행하면 동시성 제어는 훨씬 간단해지지만 데이터베이스의 트랜잭션 처리량이 단일 장비에 있는 단일 CPU 코어의 속도로 제한된다. 읽기 전용 트랜잭션은 스냅숏 격리를 사용해 다른 곳에서 실행될 수 있지만 쓰기 처리량이 높은 애플리케이션에게는 단일 스레드 트랜잭션 처리자가 심각한 병목이 될 수 있다.

여러 CPU 코어와 여러 노드로 확장하기 위해 데이터를 파티셔닝할 수도 있다. 볼트 DB는 이를 지원한다. 각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티셔닝 할 수 있다면 각 파티션은 다른 파티션과 독립적으로 실행되는 자신만의 트랜잭션 처리 스레드를 가질 수 있다. 이 경우 각 CPU 코어에 각자의 파티션을 할당해서 트랜잭션 처리량을 CPU 코어 개수에 맞춰 선형적으로 확장할 수 있다.

그러나 여러 파티션에 접근해야 하는 트랜잭션이 있다면 데이터베이스가 해당 트랜잭션이 접근하는 모든 파티션에 걸쳐서 코디네이션을 해야 한다. 스토어드 프로시저는 전체 시스템에 걸쳐 직렬성을 보장하기 위해 모든 파티션에 걸쳐 잠금을 획득한 단계에서 실행돼야 한다.

여러 파티션에 걸친 트랜잭션은 추가적인 코디네이션 오버헤드가 있으므로 단일 파티션 트랜잭션보다 엄청나게 느리다.

#### 직렬 실행 요약
트랜잭션 직렬 실행은 몇 가지 제약 사항 안에서 직렬성 격리를 획득하는 실용적인 방법이 됐다.

- 모든 트랜잭션은 작고 빨라야 한다. 느린 트랜잭션 하나가 모든 트랜잭션 처리를 지연시킬 수 있기 때문이다.
- 활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다. 거의 접근되지 않는 데이터는 잠재적으로 디스크로 옮겨질 수 있지만 단일 스레드 트랜잭션에서 이에 접근해야 한다면 시스템이 매우 느려진다.
- 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 한다. 그렇지 않으면 여러 파티션에 걸친 코디네이션이 필요하지 않도록 트랜잭션을 파티셔닝해야 한다.
- 여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 이것을 사용할 수 있는 정도에는 엄격한 제한이 있다.

### 2단계 잠금(2PL)
더티 쓰기를 막는데 잠금이 자주 사용된다고 했다. 두 개의 트랜잭션이 동시에 같은 객체에 쓰려고 하면 잠금은 나중에 쓰는 쪽이 진행하기 전에 먼저 쓰는 쪽에서 트랜잭셔늘 완료할 때까지 기다리도록 보장해준다.

2단계 잠금도 비슷하지만 잠금 요구사항이 훨씬 더 강하다. 쓰기를 실행하는 트랜잭션이 없는 객체는 여러 트랜잭션에서 동시에 읽을 수 있다. 그러나 누군가 어떤 객체에 쓰려고 하면 독점적인 접근이 필요하다.

2PL에서 쓰기 트랜잭션은 다른 쓰기 트랜잭션뿐만 아니라 읽기 트랜잭션도 진행하지 못하게 막고 그 역도 성립한다. 스냅숏 격리는 **읽는 쪽은 결코 쓰는 쪽을 막지 않으며 쓰는 쪽도 결코 읽는 쪽을 막지 않는다**는 원칙이 있는데 이게 둘 사이의 중요한 차이다. 반면 2PL은 직렬성을 제공하므로 앞에서 설명했던 갱신 손실과 쓰기 스큐를 포함한 모든 경쟁 조건으로부터 보호해준다.

#### 2단계 잠금 구현
2PL은 MySQL(InnoDB)와 SQL Server에서 직렬성 격리 수준을 구현하는 데 사용되고 DB2에선 반복 읽기 격리 수준을 구현하는 데 사용된다.

읽는 쪽과 쓰는 쪽을 막는 것은 데이터베이스의 각 객체에 잠금을 사용해 구현한다. 잠금은 공유 모드나 독점 모드로 사용될 수 있다. 잠금은 다음과 같이 사용된다.

- 트랜잭션이 객체를 읽기 원한다면 먼저 공유 모드로 잠금을 획득해야 한다. 동시에 여러 트랜잭션이 공유 모드로 잠금을 획득하는 것은 허용되지만 만약 그 객체에 이미 독점 모드로 잠금을 획득한 트랜잭션이 있으면 이 트랜잭션이 완료될 때까지 기다려야 한다.
- 트랜잭션이 객체에 쓰기를 원한다면 먼저 독점 모드로 잠금을 획득해야 한다. 다른 어떤 트랜잭션도 동시에 잠금을 획득할 수 없으므로 그 객체에 잠금이 존재한다면 트랜잭션은 대기해야 한다.
- 트랜잭션이 객체를 읽다가 쓰기를 실행할 때는 공유 잠금을 독점 잠금으로 업그레이드해야 한다. 업그레이드는 독점 잠금을 직접 획득할 때와 똑같이 동작한다.
- 트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료될 때까지 잠금을 갖고 있어야 한다. 그래서 2단계라는 이름이 붙었다. 첫 번째 단계는 잠금을 획득할 때이고 두 번째 단계는 모든 잠금을 해제할 때다.

잠금이 아주 많이 사용되므로 교착 상태가 매우 쉽게 발생할 수 있다. 데이터베이스는 트랜잭션 사이의 교착 상태를 자동으로 감지하고 트랜잭션 중 하나를 어보트시켜서 다른 트랜잭션들이 진행할 수 있게 한다. 어보트된 트랜잭션은 애플리케이션에서 재시도해야 한다.

#### 2단계 잠금의 성능
가장 큰 약점은 성능이다. 2단계 잠금을 쓰면 완화된 격리 수준을 쓸 때보다 트랜잭션 처리량과 질의 응답 시간이 크게 나빠진다.

그 원인은 부분적으로는 잠금을 획득하고 해제하는 오버헤드 때문이지만 더 중요한 원인은 동시성이 줄어드는 것이다. 설계에 따라 두 트랜잭션이 어떤 식으로든 경쟁 조건을 유발하는 일을 하려고 하면 한 트랜잭션은 다른 트랜잭션이 완료될 때까지 기다려야 한다.

전통적인 RDBMS들은 트랜잭션의 실행 시간을 제한하지 않는다. 상호작용식 애플리케이션에서 사용자의 입력을 기다리도록 설계됐기 때문이다. 그 결과, 한 트랜잭션이 다른 트랜잭션이 끝나기를 기다릴 때 얼마나 오래 기다려야 하는지에 대한 제한이 없다.

이런 까닭으로 2PL을 실행하는 데이터베이스는 작업부하에 경쟁이 있다면 지연 시간이 아주 불안정하고 높은 백분위에서 매우 느릴 수 있다. 트랜잭션 하나만 느리게 할 수도 있고 한 트랜잭션이 많은 데이터에 접근하고 잠금을 많이 획득해서 시스템의 다른 부분이 서서히 멈추도록 만들 수도 있다.

**잠금 기반 커밋 후 읽기 격리 수준에서도 교착 상태가 생길 수 있지만 2PL 직렬성 격리에선 훨씬 더 자주 발생한다.** 교착 상태는 부가적인 성능 문제가 될 수 있다. 트랜잭션이 교착 상태 때문에 어보트돼 재시도하면 작업을 전부 다시 해야 한다.

#### 서술 잠금
직렬성 격리를 쓰는 데이터베이스는 팬텀을 막아야 한다. 개념상으로 서술 잠금이 필요하다. 서술 잠금은 공유/독점 잠금과 비슷하게 동작하지만 특정 객체에 속하지 않고 아래와 같은 어떤 검색 조건에 부합하는 모든 객체에 속한다.

```sql
SELECT * FROM bookings
  WHERE room_id = 123 AND
    end_time > '2018-01-01 12:00' AND
    start_time < '2018-01-01 13:00';
```

여기서 핵심 아이디어는 서술 잠금은 데이터베이스에 아직 존재하지 않지만 미래에 추가될 수 있는 객체(팬텀)에도 적용할 수 있다는 것이다. 2PL이 서술 잠금을 포함하면 데이터베이스에서 모든 형태의 쓰기 스큐와 다른 경쟁 조건을 막을 수 있어서 격리 수준이 직렬성 격리가 된다.

#### 색인 범위 잠금
실제로 서술 잠금은 잘 동작하지 않는다. 진행 중인 트랜잭션들이 획득한 잠금이 많으면 조건에 부합하는 잠금을 확인하는 데 시간이 오래 걸린다. 이 때문에 2PL을 지원하는 대부분의 데이터베이스는 실제로 **색인 범위 잠금**을 구현한다. 이것은 서술 잠금을 간략하게 근사한 것이다.

회의실 예약 데이터베이스에는 아마도 `room_id` 칼럼과 `start_time`, `end_time` 칼럼에 색인이 있을 것이다. 또는 `room_id`에만 혹은 `start_time`, `end_time`에만 있을 수도 있다.

어떤 방법을 쓰든지 간략화한 검색 조건이 색인 중 하나에 붙는다. 이제 다른 트랜잭션이 같은 방을 사용하거나 시간이 겹치는 예약을 삽입, 갱신, 삭제하길 원한다면 색인의 같은 부분을 갱신해야 한다. 그 과정에서 공유 잠금을 발견하고 잠금이 해제될 때까지 기다리게 된다.

이 방법을 쓰면 팬텀과 쓰기 스큐로부터 보호해주는 효과를 낳는다. 서술 잠금보다 정밀하진 않지만 오버헤드가 훨씬 더 낮기 때문에 좋은 타협안이 된다. 범위 잠금을 잡을 수 있는 적합한 색인이 없다면 데이터베이스는 테이블 전체에 공유 잠금을 잡는 것으로 대체할 수 있다. 성능엔 좋진 않지만 안전한 대비책이다.

### 직렬성 스냅숏 격리(SSI)
직렬성 격리와 좋은 성능은 근본적으로 공존할 수 없는 것일까?

**직렬성 스냅숏 격리(SSI)라는 알고리즘이 아주 유망하다.** 완전한 직렬성을 제공하지만 스냅숏 격리에 비해 약간의 성능 손해만 있을 뿐이다. 최근에 나온 방식이고 오늘날 SSI는 단일 노드 데이터베이스(PostgresSQL 9.1 부터 직렬성 격리 수준 제공)와 분산 데이터베이스 모두에서 사용된다.

#### 비관적 동시성 제어 대 낙관적 동시성 제어
**2단계 잠금은 이른바 비관적 동시성 제어 메커니즘이다.** 뭔가 잘못될 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해질 때까지 기다리는 게 낫다는 원칙을 기반으로 한다. 다중 스레드 프로그래밍에서 자료구조 보호를 위해 사용되는 상호 배제와 비슷하다.

직렬 실행은 어떤 면에서 보면 극단적으로 비관적이다. 각 트랜잭션이 실행되는 동안 전체 데이터베이스에 독점 잠금을 획득하는 것과 본질적으로 같다. 개별 트랜잭션이 아주 빨리 실행되게 해서 잠금을 유지하는 시간을 줄이는 방법으로 비관주의를 보완한다.

**반대로 직렬성 스냅숏 격리는 낙관적 동시성 제어 기법이다.** 뭔가 위험한 상황이 발생할 가능성이 있을 때 트랜잭션을 막는 대신 모든 것이 괜찮아질 거라는 희망을 갖고 계속 진행한다는 뜻이다. 트랜잭션이 커밋되기를 원할 때 데이터베이스는 나쁜 상황이 발생했는지 확인한다. 만약 그렇다면 트랜잭션은 어보트되고 재시도해야 한다. 직렬로 실행된 트랜잭션만 커밋이 허용된다.

낙관적 동시성 제어는 오래된 아이디어고 장단점이 오랜 시간 동안 논의됐다. 경쟁이 심하면 어보트시켜야 할 트랜잭션의 비율이 높아지므로 성능이 떨어진다. 시스템이 이미 최대 처리량에 근접했다면 재시도되는 트랜잭션으로 발생하는 부가적인 트랜잭션 부하가 성능을 저하시킬 수 있다. 그러나 예비 용량이 충분하고 트랜잭션 사이의 경쟁이 너무 심하지 않으면 낙관적 동시성 제어 기법은 비관적 동시성 제어보다 성능이 좋은 경향이 있다.

SSI는 스냅숏 격리를 기반으로 한다. 즉 트랜잭션에서 실행되는 모든 읽기는 데이터베이스의 일관된 스냅숏을 보게 된다. 이게 이전의 낙관적 동시성 제어 기법과 크게 다른 점이다. SSI는 스냅숏 격리 위에 쓰기 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 알고리즘을 추가한다.

#### 뒤처진 전제에 기반한 결정
스냅숏 격리에선 트랜잭션이 데이터베이스에서 어떤 데이터를 읽고 그 질의 결과를 조사한 후 관찰한 결과를 기반으로 어떤 동작을 취할지 결정한다. 그러나 **스냅숏 격리하에서는 트랜잭션이 커밋되는 시점에 원래 질의의 결과가 더 이상 최신이 아닐 수 있다. 도중에 데이터가 변경됐을 수 있기 때문이다.**

다시 말해 트랜잭션은 어떤 전제를 기반으로 어떤 동작을 한다. 내중에 해당 트랜잭션이 커밋하려 할 때 원래의 데이터가 바뀌어서 그 전제가 더 이상 참이 아닐 수 있다. 애플리케이션이 질의를 실행할 때 데이터베이스는 애플리케이션 로직이 질의 결과를 어떻게 사용할지 모른다. 안전하려면 데이터베이스는 질의 결과에 변화가 있으면 트랜잭션에서 실행하는 쓰기가 유효하지 않을 수 있다고 가정해야 한다. **즉 트랜잭션에서 실행하는 질의와 쓰기 사이에는 인과적 의존성이 있을지도 모른다.** 직렬성 격리를 제공하려면 데이터베이스는 트랜잭션이 뒤처진 전제를 기반으로 동작하는 상황을 감지하고 그런 상황에선 트랜잭션을 어보트시켜야 한다.

DB에서 질의 결과가 바뀌었는지 알기 위해 두 가지 상황을 고려해야 한다.

- 오래된 MVCC 객체 버전을 읽었는지 감지하기(읽기 전에 커밋되지 않은 쓰기가 발생했음)
- 과거의 읽기에 영향을 미치는 쓰기 감지하기(읽은 후에 쓰기가 실행됨)

#### 오래된 MVCC 읽기 감지하기
트랜잭션이 MVCC 데이터베이스의 일관된 스냅숏에서 읽으면 스냅숏 생성 시점에 다른 트랜잭션이 썼지만 아직 커밋되지 않은 데이터는 무시한다.

<img width="574" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/d8f1ea24-d5a4-4603-a28d-5fea4088f8fb">

트랜잭션 43은 앨리스가 `on_call = true`인 상태인 것을 본다. 앨리스의 호출 대기 상태를 변경한 트랜잭션 42는 커밋되지 않았기 때문이다. 그러나 트랜잭션 43이 커밋하기를 원할 때는 트랜잭션 42가 이미 커밋된 상태다. 일관된 스냅숏에서 읽을 때는 무시됐던 쓰기가 지금은 영향이 있고 트랜잭션 43의 전제가 더 이상 참이 아니라는 뜻이다.

**이런 이상 현상을 막으려면 데이터베이스는 트랜잭션이 MVCC 가시성 규칙에 따라 다른 트랜잭션의 쓰기를 무시하는 경우를 추적해야 한다. 트랜잭션이 커밋하려고 할 때 데이터베이스는 무시된 쓰기 중에 커밋된 게 있는지 확인해야 한다. 커밋된 게 있다면 트랜잭션은 어보트돼야 한다.**

트랜잭션 43이 읽기 전용 트랜잭션이라면 쓰기 스큐의 위험이 없으므로 어보트될 필요가 없다. 트랜잭션 43이 읽기를 실행하는 시점에 데이터베이스는 그 트랜잭션이 나중에 쓰기를 실행할 지 알 수 없다. 게다가 트랜잭션 42는 어보트될 수도 있고 트랜잭션 43이 커밋되는 시점에 아직 커밋되지 않았을 수도 있다. 따라서 결국에는 읽기가 오래되지 않은 것으로 밝혀질지도 모른다. **SSI는 불필요한 어보트를 피해 일관된 스냅숏에서 읽으며 오래 실행되는 작업을 지원하는 스냅숏 격리의 특성을 유지한다.**

#### 과거의 읽기에 영향을 미치는 쓰기 감지하기
데이터를 읽은 후 다른 트랜잭션에서 그 데이터를 변경할 때를 고려하자.

<img width="570" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/54033663-3e33-46f3-b8f3-a3c28dbce385">

2단계 잠금의 맥락에서 데이터베이스가 `WHERE shift_id = 1234` 같은 검색 질의에 부합하는 모든 로우에 대한 접근을 잠글 수 있는 색인 범위 잠금이 있다. SSI 잠금은 다른 트랜잭션을 차단하지 않는다는 것만 제외하고 여기서도 비슷한 기법을 쓸 수 있다.

위 예시에서 트랜잭션 42, 43 모두 대기 순번 1234 동안의 호출 대기 의사를 검색한다. `shift_id`에 색인이 있으면 데이터베이스가 색인 항목 1234를 사용해 트랜잭션 42, 43이 이 데이터를 읽었다는 사실을 기록할 수 있다. 이 정보는 잠시 동안만 유지하면 된다. 트랜잭션이 완료되고 동시에 실행되는 모든 트랜잭션들이 완료된 후에 데이터베이스는 트랜잭션에서 어떤 데이터를 읽었는지 잊어버려도 된다.

트랜잭션이 데이터베이스에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 색인에서 확인해야 한다. 이 과정은 영향받는 키 범위에 쓰기 잠금을 획득하는 것과 비슷하지만 읽는 쪽에서 커밋될 때까지 차단하지 않는다. 이 잠금은 트랜잭션이 읽은 데이터가 더 이상 최신이 아니라고 트랜잭션에게 알려줄 뿐이다.

트랜잭션 43은 42에게 전에 읽은 데이터가 뒤처졌다 알려주고 트랜잭션 42도 43에게 알려준다. 트랜잭션 42가 먼저 커밋을 시도해 성공한다. 트랜잭션 43이 실행한 쓰기는 트랜잭션 42에 영향을 주지만 트랜잭션 43은 아직 커밋되지 않았으므로 그 쓰기는 아직 효과가 없다. 그러나 트랜잭션 43이 커밋하길 원할 때는 42의 충돌되는 쓰기가 이미 커밋됐으므로 43은 어보트돼야 한다.

#### 직렬성 스냅숏 격리의 성능
2단계 잠금과 비교할 때 직렬성 스냅숏 격리의 큰 이점은 트랜잭션이 다른 트랜잭션들이 잡고 있는 잠금을 기다리느라 차단될 필요가 없다는 것이다. 스냅숏 격리하에서와 마찬가지로 쓰는 쪽은 읽는 쪽을 막지 않고 반대도 마찬가지다. 이런 설계 원칙은 질의 지연 시간 예측이 쉽고 변동이 적게 만든다. 특히 읽기 전용 질의는 어떤 잠금도 없이 일관된 스냅숏 위에서 실행될 수 있다. 읽기 작업 부하가 심한 경우에 매우 매력적이다.

순차 실행과 비교해 직렬성 스냅숏 격리는 단일 CPU 코어의 처리량에 제한되지 않는다. 파운데이션DB는 직렬성 충돌 감지를 여러 장비로 분산시켜서 처리량이 아주 높도록 확장할 수 있게 한다. 데이터가 여러 장비에 걸쳐서 파티셔닝돼 있더라도 트랜잭션은 직렬성 격리를 보장하면서 여러 파티션으로부터 읽고 쓸 수 있다.

어보트 비율은 SSI의 전체적인 성능에 큰 영향을 미친다. 오랜 시간 동안 데이터를 읽고 쓰는 트랜잭션은 충돌이 나고 어보트되기 쉬워 SSI는 읽기 쓰기 트랜잭션이 상당히 짧기를 요구한다. 그러나 SSI는 아마 2PL이나 순차 실행보단 느린 트랜잭션에 덜 민감할 것이다.