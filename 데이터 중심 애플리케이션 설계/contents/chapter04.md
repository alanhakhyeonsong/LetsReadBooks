# 4장. 부호화와 발전
애플리케이션은 필연적으로 시간이 지남에 따라 변한다. 새로운 제품을 출시하거나 사용자 요구사항을 잘 이해하게 되거나 비즈니스 환경이 변함에 따라 애플리케이션 기능은 추가되거나 변경된다. 대부분의 경우 애플리케이션 기능을 변경하려면 저장하는 데이터도 변경해야 한다. 아마 새로운 필드나 레코드 유형을 저장해야 하거나 기존 데이터를 새로운 방법으로 제공해야 할지 모른다.

데이터 타입이나 스키마가 변경될 때 애플리케이션 코드에 대한 변경이 종종 발생한다. 하지만 대규모 애플리케이션에서 코드 변경은 대개 즉시 반영할 수 없다.

- 서버 측 애플리케이션에서는 한 번에 몇 개의 노드에 새 버전을 배포하고 새로운 버전이 원활하게 실행되는지 확인한 다음 서서히 모든 노드에서 실행되게 하는 순회식 업그레이드(rolling upgrade)(단계적 롤아웃(staged rollout)이라고도 함) 방식이 있다. 이는 서비스 정지 시간 없이 새로운 버전을 배포할 수 있기 때문에 더욱 자주 출시할 수 있다. 이 점이 더 좋은 발전성을 갖게 해준다.
- 클라이언트 측 애플리케이션은 사용자에 전적으로 좌우된다. 어떤 사용자는 한동안 업데이트를 설치하지 않을 수도 있다.

**이것은 예전 버전의 코드와 새로운 버전의 코드, 이전의 데이터 타입과 새로운 데이터 타입이 어쩌면 모든 시스템에 동시에 공존할 수 있다는 의미다.** 시스템이 계속 원활하게 실행되게 하려면 양방향으로 호환성을 유지해야 한다.

- 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다. 새로운 코드 쓰기는 예전 버전의 코드가 기록한 데이터의 형식을 알기에 명시적으로 해당 형식을 다룰 수 있다.
- 상위 호환성: 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다. 예전 버전의 코드가 새 버전의 코드에 의해 추가된 것을 무시할 수 있어야 하므로 다루기 더 어렵다.

## 데이터 부호화 형식
프로글매은 보통 최소한 두 가지 형태로 표현된 데이터를 사용해 동작한다.

메모리에 객체(Object), 구조체(struct), 목록(list), 배열(array), 해시 테이블(hash table), 트리(tree) 등으로 데이터가 유지된다. 이런 데이터 구조는 CPU에서 효율적으로 접근하고 조작할 수 있게 보통은 포인터를 이용해 최적화된다.

데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 스스로를 포함한 일련의 바이트열(ex. JSON)의 형태로 부호화해야 한다. 포인터는 다른 프로세스가 이해할 수 없으므로 이 일련의 바이트열은 보통 메모리에서 사용하는 데이터 구조와는 상당히 다르다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/17fe4278-4434-4f19-961c-fcae3f8e136e)

따라서 두 가지 표현 사이에 일종의 전환이 필요하다.

- 부호화(직렬화, 마셜링): 인메모리 표현에서 바이트열로의 전환
- 복호화(파싱, 역직렬화, 언마셜링): 바이트열에서 인메모리 표현으로 전환

### 언어별 형식
많은 프로그래밍 언어는 인메모리 객체를 바이트열로 부호화하는 기능을 내장한다.

- Java: `java.io.Serializable`
- Ruby: `Marshal`
- Python: `pickle`
- Java의 써드파티 라이브러리: Kryo

프로그래밍 언어에 내장된 부호화 라이브러리는 최소한의 추가 코드로 인메모리 객체를 저장하고 복원할 수 있기 때문에 매우 편리하지만 심각한 문제점 또한 많다.

- 부호화는 보통 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기는 매우 어렵다. 이런 부호화로 데이터를 저장하고 전송하는 경우 매우 오랜 시간이 될지도 모를 기간 동안 현재 프로그래밍 언어로만 코드를 작성해야 할 뿐 아니라 다른 시스템과 통합하는 데 방해가 된다.
- 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 한다. 이것은 종종 보안 문제의 원인이 된다. 공격자가 임의의 바이트열을 복호화할 수 있는 애플리케이션을 얻을 수 있으면 임의의 클래스를 인스턴스화할 수 있고 공격자가 원격으로 임의 코드를 실행하는 것과 같은 끔찍한 일이 발생할 수 있다.
- 데이터 버전 관리는 보통 부호화 라이브러리에선 나중에 생각하게 된다. 데이터를 빠르고 쉽게 부호화하기 위해 상위, 하위 호환성의 불편한 문제가 등한시되곤 한다.
- 부호화나 복호화에 소요되는 CPU 시간과 부호화된 구조체의 크기 같은 효율성도 종종 나중에 생각하게 된다. (ex. Java의 내장 직렬화는 성능이 좋지 않고 비대해지는 부호화로 유명하다.)

이런 이유로 매우 일시적인 목적 외에 언어에 내장된 부호화를 사용하는 방식은 일반적으로 좋지 않다.

### JSON과 XML, 이진 변형
JSON이 XML 대비 단순하고, 웹 브라우저에 내장된 지원 때문에 인기가 더 많다. 그리고 CSV도 있다. JSON, XML, CSV는 텍스트 형식이라 어느 정도 사람이 읽을 수 있다. 피상적인 문법적 문제 외에도 일부 미묘한 문제가 있다.

- 수(number)의 부호화에는 많은 애매함이 있다. XML과 CSV에선 수와 숫자(digit)로 구성된 문자열을 구분할 수 없다. JSON은 문자열과 수를 구분하지만 정수와 부동소수점 수를 구별하지 않고 정밀도를 지정하지 않는다.
- 2^53을 넘어가면 부동 소수점 문제가 발생한다. twitter는 이 문제를 해결하기 위해 64bit 숫자를 사용한다.
- JSON과 XML은 유니코드 문자열을 잘 지원한다. 그러나 이진 문자열을 지원하지 않는다.
  - 이진 문자열은 매우 유용하다. 그래서 이진 데이터를 Base64를 사용해 텍스트로 부호화해 이런 제한을 피한다.
  - 그리고 값이 Base64로 부호화 되었다는 사실을 스키마를 사용해 표시한다.
  - 데이터 크기가 33% 증가한다.
- CSV는 스키마가 없으므로 각 로우와 컬럼의 의미를 정의하는 작업은 애플리케이션이 해야 한다.

이런 결점에도 JSON, XML, CSV는 다양한 용도에 사용하기 충분하다. 이 부호화 형식들은 앞으로도 인기를 유지할 것이다. **특히 데이터 교환 형식(즉, 한 조직에서 다른 조직으로 데이터를 전송)으로 사용하기에 매우 좋다.**

### 이진 부호화
작은 데이터셋의 경우 부호화 형식 선택으로 얻는 이득이 무시할 정도지만 테라바이트 정도가 되면 데이터 타입의 선택이 큰 영향을 미친다.

- JSON은 XML보다 덜 장황하지만 이진 형식과 비교하면 둘 다 훨씬 많은 공간을 사용한다.
- JSON은 스키마를 지정하지 않기 때문에 부호화된 데이터 안에 모든 객체의 필드 이름을 포함해야 한다.

```json
{
  "userName": "Martin",
  "favoriteNumber": 1337,
  "interests": ["daydreaming", "hacking"]
}
```

메시지팩의 예를 살펴보자. 메시지팩은 JSON용 이진 부호화 형식이다. JSON 문서를 메시지 팩으로 부호화해 얻은 바이트다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/57d75c14-bbe7-4936-8856-7fb00010a5ad)

1. 첫 번째 바이트인 0x83은 이어지는 내용이 세 개의 필드(하위 4비트 = 0x03)를 가진 객체(상위 4비트 = 0x80)라는 뜻이다.
2. 두 번째 바이트는 0xa8은 이어지는 내용이 8바이트 길이(하위 4비트 = 0x08)의 문자열(상위 4비트 = 0xa0)이라는 의미다.
3. 다음 8바이트는 필드 이름인 `userName`의 아스키 코드다. 길이는 이전에 표시됐기 때문에 문자열이 끝나는 곳을 표시(또는 이스케이핑)할 필요가 없다.
4. 다음 7바이트는 앞에 0xa6이 붙고 `Martin`이라는 6글자 문자열 값을 부호화한다.

이진 부호화는 길이가 66바이트로 텍스트 JSON 부호화로 얻은 81바이트보다 약간 작다. JSON의 모든 이진 부호화는 이와 비슷하다. 이 같은 작은 공간의 절약이 사람의 가독성을 해칠 만큼 가치가 있는지는 확실치 않다.

### 스리프트와 프로토콜 버퍼
아파치 스리프트(Apache Thrift)와 프로토콜 버퍼(Protocol Buffers)는 같은 원리를 기반으로 한 이진 부호화 라이브러리다. 둘 다 부호화할 데이터를 위한 스키마가 필요하다.

스리프트로 앞선 JSON을 부호화하려면 다음과 같이 스리프트 인터페이스 정의 언어로 스키마를 기술해야 한다.

```thrift
struct Person {
  1: required string    userName,
  2: optional i64       favoriteNumber,
  3: optional list<string> interests
}
```

프로토콜 버퍼로 정의한 동등한 스키마는 스리프트 스키마와 매우 비슷하다.

```protobuf
message Person {
  required string user_name      = 1;
  optional int64 favorite_number = 2;
  repeated string interests      = 3;
}
```

위 두 정의를 이용해 코드를 생성하는 도구를 가지고 다양한 프로그래밍 언어로 스키마를 구현한 클래스를 생성한다. 애플리케이션 코드는 생성된 코드를 호출해 스키마의 레코드를 부호화하고 복호화할 수 있다.

이 스키마로 부호화된 데이터는 어떤 모습일까? 스리프트는 바이너리프로토콜과 컴팩트프로토콜이라는 두 가지 다른 이진 부호화 형식이 있다.

- 스리프트 바이너리 프로토콜
  - 59바이트

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/569074b5-2ab0-4022-9730-14db6c0346ca)

- 스리프트 컴팩트 프로토콜
  - 34바이트
  - 필드 타입과 태그 숫자를 단일 바이트로 줄임
  - 가변 길이 정수를 사용해서 부호화
  - 숫자 1337도 2바이트로 부호화. 더 큰 숫자는 더 많은 바이트를 사용한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/7adc4ff0-3b88-4fee-949a-564c52d0933c)

- 프로토콜 버퍼
  - 컴팩트 프로토콜과 비슷하고 33바이트
  - 스키마에서 각 필드에는 `required`나 `optional` 표시가 되어 있다. 하지만 필드를 부호화하는 방법에는 차이가 없으냐 `required`를 사용하면 필드가 설정되지 않은 경우를 실행 시에 확인할 수 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/dbe9cd84-c8e0-41ac-aba1-e4ddacb0f462)

#### 필드 태그와 스키마 발전
