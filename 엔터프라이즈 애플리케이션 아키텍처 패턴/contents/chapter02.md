# 2장. 도메인 논리 구성
### 트랜잭션 스크립트
도메인 논리를 저장하는 가장 간단한 방식은 트랜잭션 스크립트다.
- 프레젠테이션에서 입력을 받고, 유효성 검사와 계산을 통해 입력을 처리한 다음, 데이터베이스에 데이터를 저장하고, 다른 시스템에서 작업을 호출하는 프로시저
- 이후 필요에 따라 응답을 구성하고 서식을 지정하는 계산을 더 수행하고 추가 데이터로 프레젠테이션에 응답한다.
- 기본 구성은 사용자가 수행할 각 작업마다 프로시저를 하나씩 만드는 것이다.
- 작업 또는 비즈니스 트랜잭션마다 스크립트 하나를 만드는 패턴으로 볼 수 있다.
- 코드를 서브루틴으로 분리하고 이러한 서브루틴을 여러 다른 트랜잭션 스크립트에서 공유할 수 있다.

핵심 개념은 각 작업마다 프로시저 하나를 사용한다는 것이다.

장점은 다음과 같다.
- 대부분의 개발자가 이해할 수 있는 간단한 절차적 모델이다.
- **행 데이터 게이트웨이**나 **테이블 데이터 게이트웨이**를 적용해 데이터 원본 계층과 함께 사용하기에 적합하다.
- 트랜잭션의 경계를 설정하기가 쉽다. 트랜잭션 열기와 함께 시작하고 트랜잭션 닫기와 함께 종료한다. 툴을 사용해 배후에서 이러한 작업을 하기도 쉽다.

아쉽게도 단점 역시 상당히 많다.
- 도메인 논리가 늘어나면서 복잡도가 상승한다.
- 여러 트랜잭션이 비슷한 작업을 수행해야 하므로 코드가 많이 중복된다.
- 트랜잭션 스크립트 메서드가 모든 일을 다 한다.

공통 서브루틴을 뽑아내 어느정도 해결할 수 있지만, 그래도 중복 제거가 어렵고 찾아내기 더 어렵다. 결과적으로 애플리케이션이 명확한 구조가 없는 얼키고 설킨 루틴 뭉치가 된다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/1e3065a1-0c14-41e6-a3c5-233194f981d7)

### 도메인 모델
앞선 문제를 해결하기 위한 객체지향적 방법이 바로 도메인 모델이다.

- 도메인에 있는 명사를 바탕으로 도메인과 비슷한 모델을 구축한다.
  - 임대 시스템을 위해 임대, 자산 등에 대한 클래스 생성.
- 유효성 검사와 계산을 처리하는 논리는 이 도메인 모델에 넣을 수 있다.
- **한 루틴이 한 가지 사용자 작업의 논리를 모두 처리하는 것이 아니라 각 객체가 관련된 논리의 일부를 담당하게 된다.**

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/977a8d09-003c-4849-82f7-8151866c3dce)

여러 객체가 있으며, 최종적으로 전략 객체가 결과를 내놓을 때까지 각 객체가 동작의 일부를 다음 객체로 전달한다.

- 도메인 모델에 익숙해지면 복잡한 논리를 체계적으로 관리할 수 있는 아주 다양한 기법을 활용할 수 있다.
- 수익 인식을 계산하는 알고리즘이 늘어나면 인식 전략 객체를 새로 추가하는 식으로 알고리즘을 추가할 수 있다.
- 일단 객체에 대한 기본 개념이 정립된 후에는 아주 간단한 경우에도 도메인 모델을 선호하게 된다.

도메인 모델을 사용하는 데 따르는 비용은 사용의 복잡성과 데이터 원본 계층의 복잡성이다. 사고방식을 전환해도 데이터베이스 매핑은 여전히 해야한다.

- 도메인 모델이 풍성해질수록 관계형 데이터베이스 매핑도 복잡해진다.

### 테이블 모듈
도메인 모델은 데이터베이스에서 각 계약마다 계약 인스턴스가 있지만, 테이블 모듈은 인스턴스가 단 하나라는 것이다.

- 레코드 집합과 함께 사용하도록 설계돼 있다.
- 테이블 모듈의 클라이언트는 먼저 데이터베이스에 쿼리를 수행해 레코드 집합을 얻고 이 레코드 집합을 인수로 전달해 계약 객체를 만든다.
- 이후 클라이언트는 이 계약에 대해 다양한 작업을 수행할 수 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/750a57ec-0c69-4fad-8438-8197ec8e6109)

가장 큰 장점은 아키텍처의 나머지 부분과 잘 맞는다는 것이다.

## 선택
어떤 패턴이 가장 적절한지는 도메인 논리가 얼마나 복잡하느냐에 따라 크게 달라진다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/83ed8669-249a-447d-aa20-e0181bfc4890)

보통 도메인 모델을 선호한다.

## 서비스 계층
**도메인 논리를 처리하는 일반적인 방법은 도메인 계층을 둘로 나누는 것이다.**
- 서비스 계층을 기반이 되는 도메인 모델이나 테이블 모듈 위에 배치한다.
- 트랜잭션 스크립트만 사용하는 도메인 계층은 별도의 계층을 수용할 만큼 복잡하지 않기 때문에 일반적으로 이 구조는 도메인 모델이나 테이블 모듈에만 사용한다.
- 프레젠테이션 계층은 애플리케이션의 API 역할을 하는 서비스 계층과 단독으로 상호작용한다.
- **서비스 계층은 명확한 API를 제공하며 트랜잭션 제어와 보안과 같은 기능을 넣기도 좋은 위치다.**
  - 서비스 계층의 각 메서드에 대한 트랜잭션과 보안 특성을 기술하는 간단한 모델을 활용할 수 있다.

**서비스 계층을 사용할 때는 여기에 얼마나 많은 동작을 넣을지 결정하는 것이 아주 중요하다.**
- 소극적 사례는 서비스 계층을 퍼사드로 만들고 모든 실제 동작을 기반 객체에 넣은 다음, 서비스 계층이 이 퍼사드에 대한 호출을 하위 객체로 전달하게 하는 것이다.
  - 이 경우 서비스 계층은 유스케이스를 반영해서 구성된 사용하기 쉬운 API를 제공한다.
  - 또한 트랜잭션 래퍼와 보안 검사를 추가하기도 편리한 지점이다.
- 극단적 사례는 대부분의 비즈니스 논리를 서비스 계층 안의 트랜잭션 스크립트에 넣는 것이다.
  - 기본 도메인 객체는 아주 간단하며, 기본 도메인 객체가 도메인 모델인 경우, 데이터베이스와 일대일이므로 활성 레코드와 같은 간단한 데이터 원본 계층을 사용할 수 있다.

두 방법의 중간적인 성격으로서 행동을 혼합한 **컨트롤러-엔티티** 형식이 있다.
- 한 트랜잭션이나 유스케이스에 적용되는 논리를 트랜잭션 스크립트에 넣는 것이며, 일반적으로 이를 **컨트롤러나 서비스**라고 한다.
  - 유스케이스 컨트롤러
- 코드 중복을 많이 유발한다.

절차형 서비스 객체는 논리를 리팩터링하는 아주 유용한 방법이기도 하지만 이를 아키텍처의 필수 계층으로 활용하기보단 필요에 따라 이용한다. **보통의 경우엔 사용하지 않고, 애플리케이션에 꼭 필요하다 판단될 때만 최대한 간소화된 서비스 계층을 사용한다.**