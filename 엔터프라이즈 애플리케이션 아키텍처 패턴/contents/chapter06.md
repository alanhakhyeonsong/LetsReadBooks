# 6장. 세션 상태
비즈니스 트랜잭션과 시스템 트랜잭션 간의 차이는 stateless session과 stateful session에 대한 논의의 바탕이 됐다.

## 상태 비저장의 가치
진정한 상태 비저장 객체란 필드가 없는 객체를 말하는데, 이러한 객체도 가끔 등장하긴 하나 매우 드물다.

대부분의 사람들이 말하는 분산된 엔터프라이즈 애플리케이션의 상태 비저장은 위와 같은 의미가 아니다. **상태 비저장 서버는 요청 간에 상태가 유지되지 않는 객체를 의미한다.** 물론 필드를 가질 수 있지만 상태 비저장 서버에서 메서드를 호출할 때 필드의 값이 정의되지 않는다는 것이다.

- 상태 비저장 서버 예시 : 책에 대한 정보를 담은 웹 페이지를 반환하는 객체
  - 이 객체는 ASP 문서나 서블릿일 수 있으며 정해진 URL에 접근해 이 객체를 호출할 수 있다.
  - URL에는 서버가 HTTP 응답을 생성하는 데 사용할 ISBN 번호를 제공한다.
  - 상호작용이 수행되는 동안 서버 객체는 데이터베이스에서 책의 ISBN 등의 정보를 얻고 HTML을 생성하기 전에 이런 정보를 필드에 저장할 수 있다.
  - 작업이 완료되면 이러한 값은 더 이상 필요 없으니 다음번 ISBN은 완전히 다른 작업이므로 서버 객체는 모든 기존 값을 초기화한다.

많은 사람들이 상태 저장 서버를 재앙이나 다름 없는 것으로 받아들인다.
- 서버 리소스에 대한 문제
  - 상태 저장 서버 객체는 사용자가 웹 페이지를 보는 동안 대기하면서 모든 상태를 유지해야 한다.
  - 사실 이런 객체는 90%의 시간 동안 아무 일도 하지 않는다.
  - → 상태 비저장 서버 객체로 요청에 응답하면 서버 객체 10개로 모든 요청을 처리할 수 있다.

메서드 호출 간에 상태를 저장할 필요가 없으면 어떤 객체로 요청을 처리해도 관계없지만, 상태를 저장하려면 항상 같은 객체가 필요하다는 것이다. 상태 비저장은 객체를 폴링해 훨씬 적은 수의 객체로 더 많은 사용자를 처리할 수 있게 해준다. 유휴 사용자가 많을수록 상태 비저장 서버의 가치는 높아진다.
- 상태 비저장 서버는 트래픽이 많은 웹 사이트에 아주 유용하다.
- HTTP가 stateless하므로 웹과도 잘 맞는다.

클라이언트 상호작용 중에는 근본적으로 상태 저장인 것이 많다.
- 장바구니는 사용자의 전체 세션 동안 유지돼야 한다.
  - 상태 저장 비즈니스 트랜잭션을 수행해야 하므로 세션도 상태 저장이어야 한다.

단, 상태 비저장 서버를 사용해 상태 저장 세션을 구현할 수 있긴 하다.

## 세션 상태
장바구니의 세부 사항은 **세션 상태**이므로 장바구니 안의 데이터는 특정 세션에만 해당된다. 이 상태는 한 비즈니스 트랜잭션에 포함되며, 다른 세션이나 비즈니스 트랜잭션과는 분리된다. (각 비즈니스 트랜잭션이 한 세션 안에서만 실행되며 이 세션이 한 번에 한 비즈니스 트랜잭션만 수행된다 간주)

- 레코드 데이터: DB에 저장되는 장기 보존 데이터. 모든 세션에서 볼 수 있음.
- 세션 상태: 커밋을 거쳐야 레코드 데이터가 됨.

세션 상태는 한 비즈니스 트랜잭션에 포함되므로 ACID와 같이 여러 사람들이 트랜잭션의 속성이라 생각하는 속성을 가진다. 이에 따르는 한 가지 흥미로운 영향은 **동시성**이다.
- 고객이 보험증서를 편집하는 동안 이 보험증서의 현재 상태는 유효하지 않을 수 있다.
  - 값을 변경하고, 요청을 통해 값을 시스템으로 전송하면, 시스템은 잘못된 값임을 알려줄 수 있다. 이러한 값은 세션 상태의 일부지만 유효하지는 않다.
  - **세션 상태는 이와 같이 작업 중인 동안엔 유효성 검사 규칙과 맞지 않는 경우가 많다.**
  - 비즈니스 트랜잭션이 커밋할 때만 유효성 검사 규칙과 맞게 된다.

**세션 상태와 관련된 가장 중요한 문제는 격리성이다.**
- 두 명이 동시에 보험증서를 편집하는 경우에서, 보험증서에 고객 레코드의 우편번호를 반영해 값이 결정된다면,
  - 다른 사용자가 우편번호와 위험 값을 변경하면 일관성 없는 읽기가 발생함.

세션이 저장하는 모든 데이터가 세션 상태인 것은 아니다. 세션은 요청 간 꼭 저장할 필요가 없는 데이터도 성능 향상을 위해 캐싱할 수 있다. 세션 상태는 올바른 동작을 위해 요청 간에 저장해야 하지만 캐시는 손실되더라도 올바른 동작에 방해되지 않는다.

## 세션 상태를 저장하는 방법
크게 세 가지 방법이 있다.

- 클라이언트 세션 상태: 데이터를 클라이언트에 저장
  - 웹 프래젠테이션을 위한 URL 안에 데이터 인코딩, 쿠키 이용, 웹 양식의 숨겨진 필드로 데이터 직렬화 등
  - 각 요청과 함께 세션 데이터를 전송해야 한다. → 데이터가 크면 전송해야 하는 데이터의 양도 늘어난다.
  - 클라이언트에서 표시하는 데 필요 없더라도 서버에 필요한 모든 데이터를 요청과 함께 전송해야 한다.
  - 저장해야 하는 세션 상태의 양이 아주 적지 않으면 사용하지 않는 것이 좋다.
  - 보안과 무결성도 고려해야 한다.
  - 바로 얻을 수는 있지만 원하는 형태로 만들어야 하는 경우가 많다.
- 서버 세션 상태: 요청 간 데이터를 메모리에 저장하는 간단한 방법일 수 있음.
  - 일반적으론 세션 상태를 직렬화된 객체와 같이 더 안정적으로 저장할 수 있는 메커니즘이 사용된다.
  - 객체는 애플리케이션 서버의 로컬 파일 시스템이나 공유된 데이터 원본에 저장할 수 있으며, 세션 ID와 직렬화된 객체가 각각 키와 값인 간단한 DB 테이블일 수 있다.
  - 세션 상태는 거의 바로 사용 가능하다.
- 데이터베이스 세션 상태: 서버 쪽 저장소지만 오랫동안 보관할 데이터를 저장하듯 데이터를 테이블과 필드로 분리하여 DB에 저장하는 방식
  - 세션 데이터는 격리해야 한다. → DB에 저장된 레코드 데이터로부터 세션 데이터를 격리하기 위해 까다로운 작업이 필요할 수 있다.
  - 데이터베이스에서 세션 상태를 가져오고 원하는 형태로 만들어야 한다.

사용자 수가 많은 경우 처리량 향상을 위해 클러스터링 도입을 고려할 수 있다. 이 경우 세션 마이그레이션이 필요한지 생각해야 한다.  
세션 마이그레이션은 세션을 한 서버에서 다른 서버로 이동해 한 서버가 요청을 처리하고 있으면 다른 서버가 요청을 처리하게 해준다. 이와 반대되는 개념은 한 서버가 특정 세션의 모든 요청을 처리하게 하는 서버 선호도다.

서버 선호도를 높이기 위한 기준으로 클라이언트의 IP 주소를 사용하는 경우가 많은데 이 경우 대형 인터넷 서비스 업체의 IP 주소 때문에 트래픽의 상당수가 한 서버로 몰릴 수 있는 심각한 문제가 있다.

**서버가 세션 상태를 사용하려면 이를 신속하게 사용할 수 있는 형태로 만들어야 한다.** 각 방식은 시스템의 응답성에 각기 다른 영향을 준다. 응답에 걸리는 시간은 데이터의 크기와 복잡성에 따라 결정된다.

인터넷 소매 사이트에선 각 세션에서 사용되는 데이터 양은 많지 않지만 유휴 사용자가 상당히 많을 수 있다. 따라서 데이터베이스 세션 상태가 성능 면에서 적절할 수 있다. 반면 임대 시스템에선 각 요청마다 많은 양의 데이터가 데이터베이스로 오갈 수 있어 서버 세션 상태를 선택하면 더 나은 성능을 얻을 수 있다.

사용자가 세션을 취소하고 다시 돌아오지 않을 수 있다는 숨은 문제점이 있다. 특히 B2C 애플리케이션에선 **사용자가 정상적으로 취소하지 않고 그냥 잊어버리는 경우가 많다.** 클라이언트 세션 상태는 이런 상황에 적합하다. 다른 패턴을 사용할 때는 사용자가 세션 상태를 취소했다 판단되는 경우 세션 상태를 지워야 하며, 일정 시간 제한이 지나면 취소하는 시스템을 마련해야 한다.

**사용자의 취소만이 아니라 시스템의 문제도 고려해야 한다.** 여기엔 클라이언트 강제 종료, 서버 오류, 그리고 네트워크 연결 실패가 있다. 데이터베이스 세션 상태는 이 상황들에 잘 대처할 수 있다.

보통 주요 정보를 원격에 저장하면 서버 오류가 발생하더라도 손상되지 않아 서버 세션 상태를 사용하거나, 세션 ID를 저장하거나 세션 데이터가 아주 적을 때는 클라이언트 세션 상태도 자주 이용된다. 데이터베이스 세션 상태는 장애 조치와 클러스터링이 필요하고 원격에 주요 정보를 저장할 수 없거나 세션 간의 격리가 문제가 아닌 경우를 제외하면 잘 사용하지 않는다.