# 1장. 계층화
계층화는 소프트웨어 설계자가 복잡한 소프트웨어 시스템을 분할하는 데 사용하는 가장 일반적인 기법.
- 컴퓨터 아키텍처의 경우 프로그래밍 언어, OS, 장치 드라이버, CPU 명령어 집합 등.
- 네트워크의 프로토콜 계층

상위 계층은 하위 계층이 정의하는 다양한 서비스를 사용하지만, **하위 계층은 상위 계층을 인식하지 못한다.** 일반적으로 각 계층은 상위 계층이 하위 계층을 보지 못하게 한다.

시스템을 계층으로 분할하면 여러 중요한 이점이 있다.

- 다른 계층에 대한 정보 없이도 단일 계층을 하나의 일관된 계층으로 이해할 수 있다.
- 동일한 기본 서비스를 가진 대안 구현으로 계층을 대체할 수 있다.
- 계층 간의 의존성을 최소화할 수 있다.
- 계층은 표준화하기 좋은 위치다. TCP와 IP는 해당 계층이 작동하는 위치를 정의하기 때문에 표준이 됐다.
- 한 번 구축한 계층은 여러 다른 상위 서비스에서 사용할 수 있다.

계층화는 중요한 기법이지만 단점도 있다.
- 계층은 전체가 효과적으로 캡슐화되지 않는다. 그 결과, 뭔가를 변경했을 때 다른 계층에 영향을 미치는 경우가 있다. 계층형 엔터프라이즈 애플리케이션에서 볼 수 있는 전형적인 예는 UI에 표시해야 하는 필드가 데이터베이스에도 있어야 하므로 그 사이에 있는 모든 계층에 해당 필드를 추가해야 한다는 것이다.
- 계층을 추가하면 성능이 저하된다. 일반적으로 각 계층에서는 정보를 한 표현에서 다른 표현으로 변환해야 한다. 다만, 기반 기능을 캡슐화하면 성능 저하가 보상될 만큼 효율이 향상되는 경우도 있다. 예를 들어, 트랜잭션을 제어하는 계층을 최적화하면 애플리케이션 전체가 빨라지는 효과가 있다.

그러나 계층형 아키텍처에서 가장 어려운 부분은 어떤 계층을 만들고 각 계층이 어떤 역할을 담당할지 결정하는 것이다.

## 엔터프라이즈 애플리케이션에서 계층의 발전
계층의 개념은 90년대 클라이언트-서버 시스템의 등장과 함께 좀 더 중요해졌다.
- 주로 관계형 데이터를 표시하고 간단한 업데이트를 수행하는 것이라면 클라이언트-서버 시스템은 상당히 잘 동작
- **문제는 비즈니스 규칙, 유효성 검사, 계산과 같은 도메인 논리를 수행하는 경우에 발생**

대안으로 도메인 논리를 저장 프로시저로 만들어 데이터베이스에 저장하는 방법이 있다.
- 저장 프로시저는 제한적 구조와 메커니즘을 가지고 있어 어색한 코드가 되는 문제는 여전하다.
- SQL 표준이 아니다.

객체지향 진영에선 도메인 논리 문제에 대한 해결책으로 **3계층 시스템**을 제안했다.
- 프레젠테이션 계층, 도메인 계층, 데이터 원본을 이용함.
- 당시 시스템이 너무 간단하거나 적어도 간단하게 시작했기 때문에 큰 진전은 없었음.
  - 장점이 많았지만 클라이언트-서버 툴에서 이 구성을 사용하기 어렵거나 아예 불가능했음.

웹이 등장하면서 판도가 바꼈다.

## 세 가지 주요 계층
|계층|역할|
|--|--|
|프레젠테이션|서비스 제공, 정보 표시(창 또는 HTML), 사용자 요청(마우스 클릭, 키 누름), HTTP 요청, 명령줄 호출, 일괄 작업 API 처리|
|도메인|시스템의 핵심이 되는 논리|
|데이터 원본|데이터베이스, 메시징 시스템, 트랜잭션 관리자 및 다른 패키지와의 통신|

- 프레젠테이션 논리: 사용자와 소프트웨어 간 상호작용을 처리
- 데이터 원본 논리: 애플리케이션을 대신해 다른 시스템과 통신
- 비즈니스 논리(도메인 논리): 애플리케이션이 수행해야 하는 도메인과 관련된 작업.
  - 입력과 저장된 데이터를 바탕으로 하는 계산
  - 프레젠테이션에서 받은 데이터의 유효성 검사
  - 프레젠테이션에서 받은 명령을 기준으로 작업 대상이 될 데이터 원본 논리를 결정하는 등의 작업

도메인 계층이 데이터 원본을 프레젠테이션으로부터 완전히 감추도록 계층이 구성된 경우도 있다. 그런데 프레젠테이션이 데이터 저장소에 접근하는 경우가 더 많다. 이 방식은 순수하지 않지만 잘 작동하긴 한다. 프레젠테이션은 사용자의 명령을 해석하고 데이터 원본을 통해 데이터베이스에서 해당하는 데이터를 가져온 다음 도메인 논리에 데이터 처리를 맡긴 후 처리된 데이터를 사용자에게 제공한다.

만약 소프트웨어를 작동시키는 사람이 없다면 어떻게 될까. 프레젠테이션과 데이터 원본 계층이 외부 세계와 연결한다는 면에서 비슷한 점이 많다는 것을 알 수 있다. 이것은 모든 시스템을 외부 시스템에 대한 인터페이스에 둘러싸인 시스템으로 시각화하는 **육각 아키텍처 패턴**의 바탕이 되는 논리다.

**육각 아키텍처는 모든 외부 요소를 근본적으로 외부 인터페이스로 나타내므로 비대칭 계층화 체계와는 다른 모양의 대칭 뷰를 보여준다.**

하지만 다른 사람에게 서비스로 제공하는 인터페이스와 다른 사람의 서비스를 사용하기 위한 인터페이스를 구분할 수 있는 비대칭이 유용하다.
- 프레젠테이션은 복잡한 사용자 인터페이스 또는 간단한 원격 프로그램 인터페이스든 관계없이 시스템이 다른 사람에게 제공하는 서비스에 대한 외부 인터페이스다.
- 데이터 원본은 프로그램에 제공하는 서비스에 대한 외부 인터페이스다.
- 클라이언트의 차이 때문에 서비스에 대한 생각도 달라지므로 이처럼 인터페이스를 서로 다르게 보는 것이 도움이 된다.

계층을 구분하는 방법은 애플리케이션이 얼마나 복잡하느냐에 따라 달라진다. 시스템이 더 복잡해지면 세 계층을 별도의 클래스로 분리할 수 있고, 그 다음에는 클래스를 별도의 패키지로 분리할 수 있다. **적어도 서브루틴 수준에서 상황에 맞는 가장 적절한 분리 방법을 선택하는 것이 좋다.**

분리 외에도 의존성에 대한 중요한 규칙이 있다.
- 도메인과 데이터 원본은 프레젠테이션에 의존하지 않아야 한다.
- 도메인이나 데이터 원본 코드가 프레젠테이션의 코드의 서브루틴을 호출하면 안 된다.
- 이 규칙을 잘 지키면 동일한 기반을 유지하면서 다른 프레젠테이션으로 쉽게 교체 가능하며, 다른 계층에 미치는 영향을 최소화하면서 프레젠테이션을 수정하기 쉽다.

**도메인 논리 작업에서 가장 어려운 점 중 하나는 도메인 논리와 다른 형태의 논리를 구분하기 어려운 경우가 많다는 것이다.** 필자는 웹  애플리케이션에 명령줄 인터페이스를 추가하는 것과 같이 근본적으로 다른 계층을 애플리케이션에 추가한다 가정해본다고 한다. **계층을 추가하기 위해 복제해야 하는 기능이 있다면 도메인 논리가 프레젠테이션으로 유출됐다는 신호다.**

## 계층이 실행될 위치 선택
이 책은 시스템을 별도의 부분으로 분리해 시스템의 다른 부분 간의 결합을 완화하기 위한 논리적 계층을 설명한다. 계층 간의 분리는 모든 계층이 한 시스템에서 실행되더라도 유용하다.

- **가장 간단한 방법은 모든 것을 서버에서 실행하는 것이다.**
  - 큰 장점은 서버에서 모든 작업이 이뤄지므로 업그레이드하거나 수정하기 쉽다는 것이다.
- 데이터 원본은 항상 서버에서 실행된다.
  - 예외는 일반적으로 비연결 작업을 위해 서버 기능을 고성능 클라이언트에 복제하려는 경우다. 이는 비연결 클라이언트의 데이터 원본에 대한 변경 사항을 서버와 동기화해야 한다. (논외)
- 프레젠테이션 계층을 실행하는 위치에 대한 결정은 주로 원하는 사용자 인터페이스의 유형에 따라 달라진다.
  - B2C 시스템 → 모든 처리를 서버에서 하고 소비자의 브라우저로는 HTML을 전달.
- 도메인 논리는 모두 서버 또는 클라이언트에서 실행하거나 분할해서 실행할 수 있다.
  - 유지 관리를 생각할 때 모두 서버에서 실행하는 것이 최선의 방법이다.

논리의 일부를 클라이언트에서 실행해야 한다면 아예 모든 논리를 클라이언트에서 실행하는 것을 고려할 수 있다.