# 5장. 동시성
동시성은 소프트웨어 개발에거 가장 까다로운 측면 중 하나다. 여러 프로세스나 스레드가 동일한 데이터를 조작하는 경우 필연적으로 동시성 문제가 발생한다. 동시성 문제를 해결하기 어려운 이유 중 하나는 문제의 모든 원인을 미리 알기 어렵기 때문이다. 게다가 동시성은 테스트하기도 어렵다.

엔터프라이즈 개발자가 동시성을 많이 사용하지만 이에 대한 걱정을 덜하곤 한다. 트랜잭션 관리자가 있기 때문이다. 트랜잭션 내에서 모든 데이터 조작을 수행하면 심각한 문제는 대부분 예방할 수 있다. 그러나 **단일 데이터베이스 트랜잭션에 넣을 수 없는 시스템과의 상호작용이 많기 때문에 동시성 문제를 완전히 무시할 수 있는 것은 아니다.** 데이터가 여러 트랜잭션에 걸쳐 조작되는 경우 개발자가 직접 동시성을 관리해야 하기 때문이다. 여러 데이터베이스 트랜잭션에 걸쳐 조작되는 데이터에 대한 동시성 제어를 **오프라인 동시성**이라 한다.

엔터프라이즈 개발자가 해결해야 하는 두 번째 까다로운 동시성 문제는 **다중 스레드를 지원하는 애플리케이션 서버 시스템에 대한 것이다.** 이 문제는 대처하기 훨씬 수월하며 일부 서버 플랫폼은 실질적으로 이 문제를 거의 자동으로 해결한다.

## 동시성 문제
- 손실된 업데이트
  - 같은 파일을 A가 수정하는 도중 B가 먼저 수정했을 때, A가 읽은 파일에는 B가 변경한 내용이 포함되지 않아 A가 저장하면 B가 업데이트한 버전을 덮어쓰므로 이 내용은 영원히 사라진다.
- 일관성 없는 읽기

위 두 문제는 **정확성 또는 안전성을 위반하는 잘못된 동작을 유발하지만 두 사람이 동시에 동일한 데이터를 사용하려고 하지 않는다면 애초에 발생하지 않는다.** 정확성만 중요하게 생각한다면 이 문제는 그리 심각하지 않을 수 있다. 하지만 모든 동시성 프로그래밍의 핵심적 문제는 **정확성을 충족하는 것으로는 충분하지 않으며, 동시 작업이 얼마나 많이 진행될 수 있는지를 나타내는 활동성도 충족해야 한다는 것이다.**

## 실행 컨텍스트
외부 세계와 상호작용하는 관점에서 중요한 두 가지 컨텍스트로 요청과 세션이 있다.
- 요청: 소프트웨어가 작업하고 선택적으로 응답을 보내야 하는 외부 세계로부터의 단일 호출에 해당.
  - 대부분 서버 영역에서 수행되며 클라이언트는 응답을 기다리며 대기한다.
  - 클라이언트가 원래 요청을 방해할 수 있는 다른 요청을 보내도록 허용하는 경우가 많다.
    - 예를 들어, 클라이언트는 주문 요청을 보낸 후 이 주문을 취소하는 다른 요청을 보낼 수 있다.
- 세션: 클라이언트와 서버 간에 오랫동안 실행되는 상호 작용
  - 사용자가 하나의 일관된 논리적 흐름으로 생각하는 일련의 요청으로 이뤄지는 경우가 많다.
  - 일반적으로 사용자의 로그인으로 시작해 쿼리를 실행하거나 하나 이상의 비즈니스 트랜잭션을 수행하는 등의 다양한 작업을 포함함.
  - 사용자가 로그아웃하거나 사이트에서 나가면 로그아웃으로 간주하고 세션이 끝난다.

운영체제와 관련된 중요한 용어로 프로세스와 스레드가 있다.
- 프로세스: 사용하는 내부 데이터에 대한 다단계 격리를 제공하는 대규모 실행 컨텍스트
- 스레드: 한 프로세스 내에서 여러 스레드로 작동할 수 있게 구성된 소규모의 활성 에이전트
  - 한 프로세스 안에서 여러 요청을 지원할 수 있어 효율적 자원 활용에 도움이 되므로 더 선호된다.
  - 하지만 일반적으로 메모리를 공유하기 때문에 동시성 문제를 유발할 수 있다.

문제는 **실행 컨텍스트가 생각과는 다르게 깔끔하게 정리되지 않는다는 것이다.** 이론상으론 각 세션은 전체 수명동안 한 프로세스와 독점적 관계를 맺는다. 프로세스는 서로 확실하게 격리되므로 동시성 충돌을 줄이는 데 상당히 유리하다. **그러나 실제로 이런 방식으로 작동하는 서버 툴은 없다.** 가장 비슷한 방식은 각 요청마다 새 프로세스를 시작하는 방식이지만 프로세스를 시작하려면 많은 양의 자원을 할당해야 하므로 거의 사용되진 않는다.

**데이터베이스를 처리할 때는 트랜잭션이라는 또 한 가지 중요한 컨텍스트가 있다.** 트랜잭션을 이용하면 클라이언트가 단일 요청인 것 처럼 처리하고 싶은 여러 요청을 하나로 처리할 수 있다.
- 애플리케이션에서 데이터베이스로 수행되는 시스템 트랜잭션
- 사용자에게서 애플리케이션으로 수행되는 비즈니스 트랜잭션

## 격리와 불변성
엔터프라이즈 애플리케이션에선 동시성 문제에 대해 **격리와 불변성이라는 두 가지 해결책이 특히 중요하다.**

**동시성 문제는 프로세스나 스레드와 같은 활성 에이전트가 동시에 둘 이상 동일한 데이터에 접근할 때 발생한다.** 이 문제를 해결하는 한 가지 방법은 격리를 통해 데이터를 분리함으로써 하나의 활성 에이전트만 데이터에 접근할 수 있게 하는 것이다. 프로세스는 OS 메모리에서 이와 비슷하게 작동한다. 여러 생산성 애플리케이션에서 이와 비슷한 파일 잠금 기능이 사용된다. 동일한 버전의 파일을 읽기 전용으로 열 수 있지만, 이를 변경하거나 처음 사용자의 변경 내용을 볼 수 없다.

**격리는 오류 발생 가능성을 낮추는 필수 기법이다.** 격리를 적절하게 활용하면 프로그램을 격리 환경으로 전환해 동시성 걱정 없이 필요한 작업을 할 수 있다. 훌륭한 동시성 설계란 이런 격리 환경을 만드는 방법을 찾고 이 환경 내에서 최대한 많은 프로그래밍 작업을 수행하는 것이다.

**동시성 문제는 공유하는 데이터가 수정될 수 있을 때만 발생한다. 따라서 변경 불가능한 데이터를 인식할 수 있으면 동시성 충돌을 예방할 수 있다.** 많은 시스템에서 가장 중요한 작업은 데이터 수정이므로 당연히 모든 데이터를 변경 불가능하게 만들 순 없다. 그러나 일부 데이터를 변경 불가능하게 만들거나 최소한 거의 항상 불가능하게 만들면 동시성 문제에 대한 우려를 줄이면서 데이터를 광범위하게 공유할 수 있다. 다른 방법으론 애플리케이션에서 데이터를 읽기만 하는 부분을 분리하고 이곳에서 데이터의 복사본을 사용하게 해서 모든 동시성 제어로부터 자유롭게 작업하는 것이다.

## 낙관적 동시성 제어와 비관적 동시성 제어
격리할 수 없는 변경 가능한 데이터는 낙관적 동시성 제어와 비관적 동시성 제어라는 두 가지 방법으로 제어할 수 있다.

- 낙관적 잠금: 두 사용자가 모두 자유롭게 파일을 복사하고 편집할 수 있다.
  - 충돌 감지에 해당
  - 변경 사항을 제출할 때만 잠금을 적용하므로 사용자가 더 원활하게 일 할 수 있다.
  - 충돌이 자주 발생하지 않거나 그 결과가 그리 심각하지 않다면 사용.
- 비관적 잠금: 먼저 파일을 체크아웃하면 다른 사용자가 파일을 편집할 수 없게 된다.
  - 충돌 예방에 해당
  - 동시성이 제한된다.
  - 충돌의 결과가 사용자에게 심각한 경우 사용.

낙관적 잠금과 비관적 잠금을 선택하는 가장 중요한 기준은 **충돌의 빈도와 심각도다.**

### 일관성 없는 읽기 예방
일관성 없는 읽기 문제는 비관적 잠금의 읽기 잠금과 쓰기 잠금을 활용하면 매끄럽게 해결할 수 있다.

데이터를 읽으려면 읽기(또는 공유된) 잠금이 필요하며 데이터를 쓰려면 쓰기(또는 배타적) 잠금이 필요하다. 여러 사용자가 동시에 데이터에 읽기 잠금을 가질 수 있지만, 읽기 잠금을 가진 사용자가 있으면 다른 사용자는 쓰기 잠금을 가질 수 없다. 또한 쓰기 잠금을 가진 사용자가 있으면 다른 사용자는 어떤 잠금도 가질 수 없다.

낙관적 잠금의 충돌 감지 기능은 일반적으로 데이터에 넣은 일종의 버전 표식을 기반으로 작동한다. 이 표식은 타임스탬프나 순차 카운터일 수 있다. 시스템은 손실된 업데이트가 있는지 확인하기 위해 업데이트의 버전 표식을 공유된 데이터의 버전 표식과 비교한다. 두 표식이 동일한 경우 시스템은 업데이트를 허용하고 버전 표식을 업데이트한다. 읽은 모든 데이터의 버전 표식도 공유된 데이터와 비교해야 한다.

**읽은 모든 데이터에 대한 접근을 제어하면 충돌이나 그리 중요하지 않은 데이터에 대한 대기 때문에 불필요한 문제가 발생할 수 있다.**

일관성 없는 읽기를 해결하는 또 한 가지 방법은 **임시 읽기를 이용하는 것이다.** 읽은 모든 데이터에 일종의 타임스탬프나 읽기 전용 라벨을 붙이며, DB는 이 시간이나 라벨을 기준으로 데이터를 반환한다. 문제는 데이터 원본에서 변경의 전체 임시 내역을 제공해야 하며, 시간과 공간이 많이 소비된다.

### 교착 상태
비관적 잠금 기법에서 발생할 수 있는 특수한 문제로 **교착상태가 있다.** 이를 해결하는 다양한 기법이 있다.

- 교착 상태 감지 → 희생자 한 명을 선택해 해당 사용자의 작업과 잠금을 포기해 다른 사용자가 작업을 진행할 수 있게 한다.
- 모든 잠금에 시간 제한을 두는 방식

## 트랜잭션
**트랜잭션은 엔터프라이즈 애플리케이션에서 동시성을 처리하는 가장 중요한 툴이다.**

- 트랜잭션은 시작점과 끝점이 명확하게 정의된 일련의 작업이다.
- 모든 트랜잭션은 전체를 실행하거나 실행하지 않는 양자택일 방식으로 수행해야 한다.

소프트웨어 트랜잭션은 다음과 같은 ACID 속성을 가진다.

- 원자성(Atomicity): 트랜잭션의 경계 안에서 수행되는 각 작업의 단계는 모두 성공적으로 완료되거나 롤백돼야 한다. 부분 완료는 트랜잭션의 개념이 아니다.
- 일관성(Consistency): 시스템의 자원은 트랜잭션의 시작과 완료 시점에 모두 일관성 있고 손상되지 않은 상태여야 한다.
- 격리성(Isolation): 개별 트랜잭션의 결과는 트랜잭션이 성공적으로 커밋하기 전까지 다른 열려있는 트랜잭션에서 볼 수 없어야 한다.
- 지속성(Durability): 커밋된 트랜잭션의 결과는 영구적이어야 한다. 어떠한 종류의 강제 종료가 발생해도 유지돼야 한다.

### 트랜잭션 리소스
대부분의 엔터프라이즈 애플리케이션은 데이터베이스 작업에 트랜잭션을 사용한다. 그러나 DB 외에도 메시지 큐, 프린터, 현금지급기 등 여러 다양한 리소스를 트랜잭션을 사용해 제어할 수 있다.

**처리량을 극대화하기 위해 최신 트랜잭션 시스템은 트랜잭션을 최대한 짧게 유지하도록 설계된다.**
- 여러 요청에 걸친 트랜잭션을 만들지 말아야 한다.
- 요청이 시작될 때 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션을 끝내는 방법이 일반적으로 많이 사용된다.
  - 요청 트랜잭션은 여러 환경에서 메서드를 트랜잭션으로 지정하는 방법으로 간편한 선언식 트랜잭션을 지원한다.
- 다른 방법은 **트랜잭션을 최대한 늦게 여는 것이다.**
  - 트랜잭션 밖에서 모든 읽기를 수행하고 업데이트를 시작할 때 트랜잭션을 여는 방식
  - 트랜잭션에 소비되는 시간을 최소화하는 장점이 있다.
  - 하지만 트랜잭션을 시작하기 전까지는 동시성 제어가 전혀 적용되지 않으므로 일관성 없는 읽기 문제의 우려가 있다.

트랜잭션을 사용할 땐 어떤 리소스가 잠기는지 어느정도 인식하고 있어야 한다. 여러 DB 작업에서 트랜잭션 시스템은 **작업과 관련된 행을 잠그므로 여러 트랜잭션이 동일한 테이블에 접근할 수 있다.** 그런데 트랜잭션이 테이블의 전체 행을 잠그는 경우 DB가 처리 가능한 수준 이상으로 잠금이 증가하고 결국 잠금이 상향되어 다른 트랜잭션까지 잠그게 된다. 이 잠금 상향은 동시성에 상당히 심각한 영향을 미친다.

도메인의 계층 상위 형식 레벨의 데이터에 일부 "객체" 테이블을 사용하지 않아야 하는 이유기도 하다. 이러한 테이블은 잠금 상향의 주요 후보이며, 해당 테이블이 잠기면 데이터베이스에서 다른 모든 작업에 영향을 미친다.

### 활동성을 위한 트랜잭션 격리성 저하
