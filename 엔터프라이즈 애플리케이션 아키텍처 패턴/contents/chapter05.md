# 5장. 동시성
동시성은 소프트웨어 개발에거 가장 까다로운 측면 중 하나다. 여러 프로세스나 스레드가 동일한 데이터를 조작하는 경우 필연적으로 동시성 문제가 발생한다. 동시성 문제를 해결하기 어려운 이유 중 하나는 문제의 모든 원인을 미리 알기 어렵기 때문이다. 게다가 동시성은 테스트하기도 어렵다.

엔터프라이즈 개발자가 동시성을 많이 사용하지만 이에 대한 걱정을 덜하곤 한다. 트랜잭션 관리자가 있기 때문이다. 트랜잭션 내에서 모든 데이터 조작을 수행하면 심각한 문제는 대부분 예방할 수 있다. 그러나 **단일 데이터베이스 트랜잭션에 넣을 수 없는 시스템과의 상호작용이 많기 때문에 동시성 문제를 완전히 무시할 수 있는 것은 아니다.** 데이터가 여러 트랜잭션에 걸쳐 조작되는 경우 개발자가 직접 동시성을 관리해야 하기 때문이다. 여러 데이터베이스 트랜잭션에 걸쳐 조작되는 데이터에 대한 동시성 제어를 **오프라인 동시성**이라 한다.

엔터프라이즈 개발자가 해결해야 하는 두 번째 까다로운 동시성 문제는 **다중 스레드를 지원하는 애플리케이션 서버 시스템에 대한 것이다.** 이 문제는 대처하기 훨씬 수월하며 일부 서버 플랫폼은 실질적으로 이 문제를 거의 자동으로 해결한다.

## 동시성 문제
- 손실된 업데이트
  - 같은 파일을 A가 수정하는 도중 B가 먼저 수정했을 때, A가 읽은 파일에는 B가 변경한 내용이 포함되지 않아 A가 저장하면 B가 업데이트한 버전을 덮어쓰므로 이 내용은 영원히 사라진다.
- 일관성 없는 읽기

위 두 문제는 **정확성 또는 안전성을 위반하는 잘못된 동작을 유발하지만 두 사람이 동시에 동일한 데이터를 사용하려고 하지 않는다면 애초에 발생하지 않는다.** 정확성만 중요하게 생각한다면 이 문제는 그리 심각하지 않을 수 있다. 하지만 모든 동시성 프로그래밍의 핵심적 문제는 **정확성을 충족하는 것으로는 충분하지 않으며, 동시 작업이 얼마나 많이 진행될 수 있는지를 나타내는 활동성도 충족해야 한다는 것이다.**

## 실행 컨텍스트
외부 세계와 상호작용하는 관점에서 중요한 두 가지 컨텍스트로 요청과 세션이 있다.
- 요청: 소프트웨어가 작업하고 선택적으로 응답을 보내야 하는 외부 세계로부터의 단일 호출에 해당.
  - 대부분 서버 영역에서 수행되며 클라이언트는 응답을 기다리며 대기한다.
  - 클라이언트가 원래 요청을 방해할 수 있는 다른 요청을 보내도록 허용하는 경우가 많다.
    - 예를 들어, 클라이언트는 주문 요청을 보낸 후 이 주문을 취소하는 다른 요청을 보낼 수 있다.
- 세션: 클라이언트와 서버 간에 오랫동안 실행되는 상호 작용
  - 사용자가 하나의 일관된 논리적 흐름으로 생각하는 일련의 요청으로 이뤄지는 경우가 많다.
  - 일반적으로 사용자의 로그인으로 시작해 쿼리를 실행하거나 하나 이상의 비즈니스 트랜잭션을 수행하는 등의 다양한 작업을 포함함.
  - 사용자가 로그아웃하거나 사이트에서 나가면 로그아웃으로 간주하고 세션이 끝난다.

운영체제와 관련된 중요한 용어로 프로세스와 스레드가 있다.
- 프로세스: 사용하는 내부 데이터에 대한 다단계 격리를 제공하는 대규모 실행 컨텍스트
- 스레드: 한 프로세스 내에서 여러 스레드로 작동할 수 있게 구성된 소규모의 활성 에이전트
  - 한 프로세스 안에서 여러 요청을 지원할 수 있어 효율적 자원 활용에 도움이 되므로 더 선호된다.
  - 하지만 일반적으로 메모리를 공유하기 때문에 동시성 문제를 유발할 수 있다.

문제는 **실행 컨텍스트가 생각과는 다르게 깔끔하게 정리되지 않는다는 것이다.** 이론상으론 각 세션은 전체 수명동안 한 프로세스와 독점적 관계를 맺는다. 프로세스는 서로 확실하게 격리되므로 동시성 충돌을 줄이는 데 상당히 유리하다. **그러나 실제로 이런 방식으로 작동하는 서버 툴은 없다.** 가장 비슷한 방식은 각 요청마다 새 프로세스를 시작하는 방식이지만 프로세스를 시작하려면 많은 양의 자원을 할당해야 하므로 거의 사용되진 않는다.

**데이터베이스를 처리할 때는 트랜잭션이라는 또 한 가지 중요한 컨텍스트가 있다.** 트랜잭션을 이용하면 클라이언트가 단일 요청인 것 처럼 처리하고 싶은 여러 요청을 하나로 처리할 수 있다.
- 애플리케이션에서 데이터베이스로 수행되는 시스템 트랜잭션
- 사용자에게서 애플리케이션으로 수행되는 비즈니스 트랜잭션

## 격리와 불변성
엔터프라이즈 애플리케이션에선 동시성 문제에 대해 **격리와 불변성이라는 두 가지 해결책이 특히 중요하다.**

**동시성 문제는 프로세스나 스레드와 같은 활성 에이전트가 동시에 둘 이상 동일한 데이터에 접근할 때 발생한다.** 이 문제를 해결하는 한 가지 방법은 격리를 통해 데이터를 분리함으로써 하나의 활성 에이전트만 데이터에 접근할 수 있게 하는 것이다. 프로세스는 OS 메모리에서 이와 비슷하게 작동한다. 여러 생산성 애플리케이션에서 이와 비슷한 파일 잠금 기능이 사용된다. 동일한 버전의 파일을 읽기 전용으로 열 수 있지만, 이를 변경하거나 처음 사용자의 변경 내용을 볼 수 없다.

**격리는 오류 발생 가능성을 낮추는 필수 기법이다.** 격리를 적절하게 활용하면 프로그램을 격리 환경으로 전환해 동시성 걱정 없이 필요한 작업을 할 수 있다. 훌륭한 동시성 설계란 이런 격리 환경을 만드는 방법을 찾고 이 환경 내에서 최대한 많은 프로그래밍 작업을 수행하는 것이다.

**동시성 문제는 공유하는 데이터가 수정될 수 있을 때만 발생한다. 따라서 변경 불가능한 데이터를 인식할 수 있으면 동시성 충돌을 예방할 수 있다.** 많은 시스템에서 가장 중요한 작업은 데이터 수정이므로 당연히 모든 데이터를 변경 불가능하게 만들 순 없다. 그러나 일부 데이터를 변경 불가능하게 만들거나 최소한 거의 항상 불가능하게 만들면 동시성 문제에 대한 우려를 줄이면서 데이터를 광범위하게 공유할 수 있다. 다른 방법으론 애플리케이션에서 데이터를 읽기만 하는 부분을 분리하고 이곳에서 데이터의 복사본을 사용하게 해서 모든 동시성 제어로부터 자유롭게 작업하는 것이다.

## 낙관적 동시성 제어와 비관적 동시성 제어
격리할 수 없는 변경 가능한 데이터는 낙관적 동시성 제어와 비관적 동시성 제어라는 두 가지 방법으로 제어할 수 있다.

- 낙관적 잠금: 두 사용자가 모두 자유롭게 파일을 복사하고 편집할 수 있다.
  - 충돌 감지에 해당
  - 변경 사항을 제출할 때만 잠금을 적용하므로 사용자가 더 원활하게 일 할 수 있다.
  - 충돌이 자주 발생하지 않거나 그 결과가 그리 심각하지 않다면 사용.
- 비관적 잠금: 먼저 파일을 체크아웃하면 다른 사용자가 파일을 편집할 수 없게 된다.
  - 충돌 예방에 해당
  - 동시성이 제한된다.
  - 충돌의 결과가 사용자에게 심각한 경우 사용.

낙관적 잠금과 비관적 잠금을 선택하는 가장 중요한 기준은 **충돌의 빈도와 심각도다.**

### 일관성 없는 읽기 예방
일관성 없는 읽기 문제는 비관적 잠금의 읽기 잠금과 쓰기 잠금을 활용하면 매끄럽게 해결할 수 있다.

데이터를 읽으려면 읽기(또는 공유된) 잠금이 필요하며 데이터를 쓰려면 쓰기(또는 배타적) 잠금이 필요하다. 여러 사용자가 동시에 데이터에 읽기 잠금을 가질 수 있지만, 읽기 잠금을 가진 사용자가 있으면 다른 사용자는 쓰기 잠금을 가질 수 없다. 또한 쓰기 잠금을 가진 사용자가 있으면 다른 사용자는 어떤 잠금도 가질 수 없다.

낙관적 잠금의 충돌 감지 기능은 일반적으로 데이터에 넣은 일종의 버전 표식을 기반으로 작동한다. 이 표식은 타임스탬프나 순차 카운터일 수 있다. 시스템은 손실된 업데이트가 있는지 확인하기 위해 업데이트의 버전 표식을 공유된 데이터의 버전 표식과 비교한다. 두 표식이 동일한 경우 시스템은 업데이트를 허용하고 버전 표식을 업데이트한다. 읽은 모든 데이터의 버전 표식도 공유된 데이터와 비교해야 한다.

**읽은 모든 데이터에 대한 접근을 제어하면 충돌이나 그리 중요하지 않은 데이터에 대한 대기 때문에 불필요한 문제가 발생할 수 있다.**

일관성 없는 읽기를 해결하는 또 한 가지 방법은 **임시 읽기를 이용하는 것이다.** 읽은 모든 데이터에 일종의 타임스탬프나 읽기 전용 라벨을 붙이며, DB는 이 시간이나 라벨을 기준으로 데이터를 반환한다. 문제는 데이터 원본에서 변경의 전체 임시 내역을 제공해야 하며, 시간과 공간이 많이 소비된다.

### 교착 상태
비관적 잠금 기법에서 발생할 수 있는 특수한 문제로 **교착상태가 있다.** 이를 해결하는 다양한 기법이 있다.

- 교착 상태 감지 → 희생자 한 명을 선택해 해당 사용자의 작업과 잠금을 포기해 다른 사용자가 작업을 진행할 수 있게 한다.
- 모든 잠금에 시간 제한을 두는 방식

## 트랜잭션
**트랜잭션은 엔터프라이즈 애플리케이션에서 동시성을 처리하는 가장 중요한 툴이다.**

- 트랜잭션은 시작점과 끝점이 명확하게 정의된 일련의 작업이다.
- 모든 트랜잭션은 전체를 실행하거나 실행하지 않는 양자택일 방식으로 수행해야 한다.

소프트웨어 트랜잭션은 다음과 같은 ACID 속성을 가진다.

- 원자성(Atomicity): 트랜잭션의 경계 안에서 수행되는 각 작업의 단계는 모두 성공적으로 완료되거나 롤백돼야 한다. 부분 완료는 트랜잭션의 개념이 아니다.
- 일관성(Consistency): 시스템의 자원은 트랜잭션의 시작과 완료 시점에 모두 일관성 있고 손상되지 않은 상태여야 한다.
- 격리성(Isolation): 개별 트랜잭션의 결과는 트랜잭션이 성공적으로 커밋하기 전까지 다른 열려있는 트랜잭션에서 볼 수 없어야 한다.
- 지속성(Durability): 커밋된 트랜잭션의 결과는 영구적이어야 한다. 어떠한 종류의 강제 종료가 발생해도 유지돼야 한다.

### 트랜잭션 리소스
대부분의 엔터프라이즈 애플리케이션은 데이터베이스 작업에 트랜잭션을 사용한다. 그러나 DB 외에도 메시지 큐, 프린터, 현금지급기 등 여러 다양한 리소스를 트랜잭션을 사용해 제어할 수 있다.

**처리량을 극대화하기 위해 최신 트랜잭션 시스템은 트랜잭션을 최대한 짧게 유지하도록 설계된다.**
- 여러 요청에 걸친 트랜잭션을 만들지 말아야 한다.
- 요청이 시작될 때 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션을 끝내는 방법이 일반적으로 많이 사용된다.
  - 요청 트랜잭션은 여러 환경에서 메서드를 트랜잭션으로 지정하는 방법으로 간편한 선언식 트랜잭션을 지원한다.
- 다른 방법은 **트랜잭션을 최대한 늦게 여는 것이다.**
  - 트랜잭션 밖에서 모든 읽기를 수행하고 업데이트를 시작할 때 트랜잭션을 여는 방식
  - 트랜잭션에 소비되는 시간을 최소화하는 장점이 있다.
  - 하지만 트랜잭션을 시작하기 전까지는 동시성 제어가 전혀 적용되지 않으므로 일관성 없는 읽기 문제의 우려가 있다.

트랜잭션을 사용할 땐 어떤 리소스가 잠기는지 어느정도 인식하고 있어야 한다. 여러 DB 작업에서 트랜잭션 시스템은 **작업과 관련된 행을 잠그므로 여러 트랜잭션이 동일한 테이블에 접근할 수 있다.** 그런데 트랜잭션이 테이블의 전체 행을 잠그는 경우 DB가 처리 가능한 수준 이상으로 잠금이 증가하고 결국 잠금이 상향되어 다른 트랜잭션까지 잠그게 된다. 이 잠금 상향은 동시성에 상당히 심각한 영향을 미친다.

도메인의 계층 상위 형식 레벨의 데이터에 일부 "객체" 테이블을 사용하지 않아야 하는 이유기도 하다. 이러한 테이블은 잠금 상향의 주요 후보이며, 해당 테이블이 잠기면 데이터베이스에서 다른 모든 작업에 영향을 미친다.

### 활동성을 위한 트랜잭션 격리성 저하
|격리 수준|더티 읽기|반복 불가능 읽기|팬텀|
|--|--|--|--|
|커밋되지 않은 읽기|예|예|예|
|커밋된 읽기|아니오|예|예|
|반복 가능 읽기|아니오|아니오|예|
|직렬화 가능|아니오|아니오|아니오|

정확성을 최대한 보장하려면 항상 직렬화 가능 격리 수준을 사용해야 한다. 그러나 직렬화 가능을 사용하면 시스템의 활동성이 크게 저하되므로 처리량을 늘리려면 어쩔 수 없이 직렬화 가능성을 어느정도 포기해야 한다. 즉, 어느 수준까지 위험을 감수할지 결정하고 오류와 성능 간의 적절한 균형을 찾는 것이 중요하다.

### 비즈니스 트랜잭션과 시스템 트랜잭션
- 시스템 트랜잭션 → 앞서 나온 모든 트랜잭션. RDBMS 시스템.

시스템 트랜잭션은 비즈니스 시스템의 사용자에겐 전혀 의미가 없다. 비즈니스 트랜잭션에서도 시스템 트랜잭션과 동일한 ACID 속성을 제공해야 한다.

비즈니스 트랜잭션에서 ACID 속성을 지원하는 확실한 방법은 한 비즈니스 트랜잭션 전체를 한 시스템 트랜잭션 안에서 실행하는 것이다. 그러나 비즈니스 트랜잭션을 완료하는 데는 여러 요청을 거치는 경우가 많으므로 시스템 트랜잭션 하나를 사용해 비즈니스 트랜잭션을 구현하면 긴 시스템 트랜잭션이 된다. **대부분의 시스템은 긴 트랜잭션을 잘 처리하지 못한다.**

절대 사용하지 말라는 의미는 아니지만, 관리가 어렵다. 이 경우 어쩔 수 없이 비즈니스 트랜잭션을 일련의 짧은 트랜잭션으로 분리해야 한다. 즉, 여러 시스템 트랜잭션 사이에서 비즈니스 트랜잭션의 ACID 특성을 지원하는 역할을 직접 만들어야 하며, 오프라인 동시성 문제를 해결해야 한다.

원자성과 지속성은 비즈니스 트랜잭션에서 가장 쉽게 지원할 수 있는 ACID 속성이다.

- 세션은 레코드 집합에 대한 모든 변경 사항을 커밋하기 전에 먼저 시스템 트랜잭션을 연다.
  - 이 시스템 트랜잭션은 변경 내용이 한 단위로 커밋되고 지속적으로 유지되게 한다.
  - 애플리케이션이 도메인 모델을 사용하는 경우 작업 단위로 정확하게 변경 추적 가능
  - 비즈니스 논리를 트랜잭션 스크립트에 넣은 경우 수동으로 변경 사항을 추적해야 함.

비즈니스 트랜잭션에서 적용하기 까다로운 ACID 속성은 격리다. 격리의 실패는 일관성의 실패로 이어진다. 일관성을 유지하려는 비즈니스 트랜잭션에서 레코드 집합을 잘못된 상태로 만들지 말아야 한다. 애플리케이션이 단일 트랜잭션 안에서 일관성을 유지하기 위해 해야 하는 역할은 모든 사용 가능한 비즈니스 규칙을 적용하는 것이다. 그리고 여러 트랜잭션에 걸쳐 일관성을 유지하기 위해 해야 하는 역할은 세션이 다른 세션의 변경 내용을 망치고 레코드 집합이 잘못된 상태가 되어 사용자의 작업이 손실되지 않도록 방지하는 것이다.

## 오프라인 동시성 제어를 위한 패턴
**가능하면 트랜잭션 시스템이 최대한으로 동시성 문제를 알아서 처리하게 해야 한다.** 여러 시스템 트랜잭션에 걸친 동시성 제어에 일단 손을 대면 동시성을 직접 해결해야 하는 혼란스러운 상황에 빠져들게 된다. 여기서는 여러 시스템 트랜잭션에 걸쳐 동시성 제어를 처리하는데 도움되는 몇 가지 패턴을 소개한다.

**이런 기법은 꼭 필요할 때만 사용해야 한다.**
- 모든 비즈니스 트랜잭션을 요청 하나에 연결해 시스템 트랜잭션 하나로 처리할 수 있다면 그렇게 하는 것이 좋다.
- 또한 확장성을 어느정도 포기하고 긴 트랜잭션을 사용할 수 있다면 그렇게 하는 것이 좋다.
- 동시성 제어를 트랜잭션 소프트웨어에 맡기면 수고를 크게 덜 수 있다.
- 이런 기법은 동시성 제어를 트랜잭션 소프트웨어에 맡길 수 없을 때 사용하는 것이다.

**오프라인 동시성을 처리하는 첫 번째 선택은 여러 비즈니스 트랜잭션에 걸쳐 낙관적 동시성 제어를 사용하는 낙관적 오프라인 잠금이다.**
- 프로그래밍하기 쉽고 활동성이 가장 높다.
- 한계는 비즈니스 트랜잭션이 실패하는 경우 커밋할 때가 돼서야 알 수 있다.
  - 사용자가 한 시간 동안 세부 사항을 입력한 임대 계약이 트랜잭션 오류 때문에 실패한다면?
- 비관적 오프라인 잠금은 이에 대한 대안으로 문제 시 조기에 알 수 있지만 프로그래밍하기 어렵고 활동성이 제한된다.

두 접근 방식을 사용할 때 모든 객체의 잠금을 직접 관리하려 하지 않으면 복잡도를 크게 낮출 수 있다.
- 굵은 입자 잠금을 사용하면 객체 그룹의 동시성을 함께 관리할 수 있다.
- 암시적 잠금을 사용하면 애플리케이션 개발자의 부담을 크게 덜 수 있다.
  - 잠금을 직접 관리할 필요가 없다.

**낙관적 또는 비관적 제어의 결정은 시스템의 전체 사용자 경험에 영향을 미친다.** 또한 비관적 오프라인 잠금을 현명하게 설계하려면 시스템의 사용자에게서 도메인에 대한 정보를 충분히 얻어야 한다. 마찬가지로, 굵은 입자 잠금을 적절하게 선택하려면 도메인 지식이 필요하다.

동시성을 다루는 것은 아주 어려운 프로그래밍 작업 중 하나다. 동시성 코드는 확실하게 테스트하기 매우 어렵다. 또한 동시성 버그는 재현하기 어렵고 추적하기도 매우 까다롭다.

## 애플리케이션 서버 동시성
- 공유된 데이터 원본에 대해 실행되는 다중 세션의 관점에서의 동시성
- **애플리케이션 서버 자체의 프로세스 동시성**

**서버가 여러 동시 요청을 어떻게 처리하며, 이것이 서버의 애플리케이션 설계에 어떤 영향을 미치는지 고려한다.** 앞서 내내 언급된 동시성 문제와 크게 다른 점은 애플리케이션 서버 동시성은 트랜잭션과는 관계 없기 때문에 비교적 잘 제어되는 트랜잭션의 세계에서 더 이상 도움을 받을 수 없다는 것이다.

**잠금과 동기화 블록을 사용해 명시적 다중 스레드 프로그래밍을 제대로 구현하기는 매우 어렵다.**
- 찾아내기 아주 어려운 결함이 쉽게 발생
- 동시성 버그는 재현하기 거의 불가능함
- 개발자가 동기화와 잠금을 명시적으로 처리하는 경우는 가급적 최소화해야 함.

가장 간단한 방법은 **각 세션이 각자의 프로세스에서 실행되는 세션별 프로세스를 사용하는 것이다.**
- 가장 큰 장점은 각 프로세스의 상태가 다른 프로세스로부터 완전히 격리되므로 애플리케이션 프로그래머가 다중 스레드에 대해 신경 쓸 필요가 전혀 없다는 것이다.
- 메모리 격리 관점에선 각 요청별로 새로운 스레드를 시작하는 방법과 한 프로세스를 요청 간에 유휴 상태로 유지되는 세션에 연결하는 방법이 거의 동일한 효과가 있다.
- 하지만, **프로세스가 리소스를 너무 많이 소모하는 문제가 있다.**

각 프로세스는 한 번에 한 요청만 처리할 수 있지만, 다른 세션의 여러 요청을 순차적으로 처리할 수 있도록 프로세스의 풀을 만들어 효율을 높이는 방법이 나왔다. **풀링되는 요청별 프로세스를 이용하면 일정 수의 세션을 처리하는 데 훨씬 적은 수의 프로세스가 사용된다.**
- 격리도 거의 같은 수준으로 유지되므로 까다로운 다중 스레드 문제가 많이 발생하지 않는다.
- 주의할 점은, 각 요청이 끝나면 요청을 처리할 때 사용된 모든 리소스를 반환해야 한다는 것이다.

요청별 프로세스 방식도 일정 수준의 부하를 처리하려면 많은 프로세스를 실행해야 한다. **한 프로세스가 여러 스레드를 실행하게 하면 처리량을 개선할 수 있다.** 이러한 **요청별 스레드 방식에서 각 요청은 프로세스 내의 한 스레드에 의해 처리된다.**
- 스레드는 프로세스보다 서버 리소스를 적게 사용하므로 적은 하드웨어 리소스로 더 많은 요청을 처리해 서버의 효율을 높일 수 있다.
- 문제는 스레드가 서로 격리되지 않기 때문에 어떤 스레드든지 접근 가능한 데이터를 변경할 수 있다는 것이다.

**가장 권장되는 방식은 요청별 프로세스다.**
- 요청별 스레드보단 효율이 낮지만 확장성이 충분하다.
- 견고성 또한 더 우수하다.
  - 한 스레드가 잘못되면 전체 프로세스가 잘못될 수 있기 때문에 요청별 스레드를 사용하면 피해가 제한된다.

**요청별 스레드를 사용할 때 가장 시급한 것은 애플리케이션 개발자가 다중 스레드 문제를 걱정할 필요가 없는 격리된 지역을 만들고 이를 활용하는 것이다.** 일반적인 방법은 스레드가 요청을 처리하기 시작할 때 다른 스레드가 볼 수 없는 곳에 새로운 객체를 만들고 이를 활용하는 것이다. 이 방법으로 다른 스레드가 참조할 수 없는 객체를 만들어 객체를 격리할 수 있다.

객체 생성 프로세스에 비용이 많이 든다 걱정하는 개발자들은 객체를 풀링하는 방법을 생각했다. 풀링을 사용할 때의 문제는 풀링된 객체에 대한 접근을 어떤 방식으로든 동기화해야 한다는 것이다. 객체를 생성하는 비용은 사용하는 가상 시스템과 메모리 관리 전략에 따라 크게 좌우된다. 실제 최신 환경에서 객체 생성 속도는 사실 상당히 빠르다. **각 세션마다 새로운 객체를 만들면 많은 동시성 버그를 예방하고 확장성을 개선할 수 있다.**

이 전술은 여러 경우에 적용 가능 하지만, 몇 가지 피해야 하는 영역이 있다.
- 정적, 클래스 기반 변수나 전역 변수
  - 이런 변수에 대한 접근은 모두 동기화해야 함.
- 싱글턴

**전역 메모리와 비슷한 기능이 필요하다면 레지스트리를 사용한다.** 정적 변수와 비슷하지만 실제론 스레드별 저장소를 사용할 수 있도록 구현할 수 있다.

세션을 위해 객체를 생성할 수 있고 결과적으로 비교적 안전한 영역을 만들 수 있다 해도 어떤 객체는 생성하는 비용이 정말 많이 들기 때문에 사용할 때 주의를 기울여야 한다. 가장 일반적인 예로 데이터베이스 연결이 있다. 이를 해결하려면 이러한 객체를 명시적 풀에 넣고, 필요할 때 얻고, 사용이 끝나면 반환해야 한다. 물론 이런 작업은 동기화해야 한다.