# 3장. 관계형 데이터베이스 매핑
- 데이터 원본 계층의 역할은 애플리케이션이 작업을 수행하는 데 필요한 인프라의 다양한 부분과 통신하는 것
- 이 계층에서 가장 중요한 것은 **데이터베이스와 상호작용하는 것이다.**

## 아키텍처 패턴
첫 번째 패턴 집합은 도메인 논리가 데이터베이스와 상호작용하는 방법을 좌우하는 아키텍처 패턴으로 구성돼있다. 이런 패턴의 선택은 **전체 설계에 미치는 파급효과가 크고 리팩터링하기 어렵기 때문에 충분한 주의를 기울여야 한다.**

SQL 접근을 도메인 논리와는 별도로 분리하고 개별 클래스에 배치하는 것이 좋다. 이런 클래스를 구성하는 방법으로는 **데이터베이스 테이블 당 클래스 하나를 가지도록 데이터베이스 테이블의 테이블 구조를 바탕으로 클래스를 구성하는 것이 좋다.** 애플리케이션의 나머지 부분에선 SQL에 대해 알 필요가 없으며, 데이터베이스에 접근하는 모든 SQL은 쉽게 찾을 수 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/6ade7f1e-6d78-40ca-954d-fc1fb424bc21)

- 테이블 데이터 게이트웨이
  - 테이블 기준으로 매핑되는 클래스에서, SQL을 구현하고 활용한다.
  - 테이블당 인스턴스 하나를 가진다.
  - 레코드 집합과 잘 어울려 테이블 모듈을 사용하는 경우에도 확실한 선택이다.
    - 레코드 집합은 데이터베이스의 테이블식 특성을 흉내 낸 테이블과 행의 범용 자료구조로서 다양한 환경에서 폭넓게 지원한다.
  - 저장 프로시저의 모음으로써 활용 가능하다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/9144cd03-f106-4282-98d8-893825c917e2)

- 행 데이터 게이트웨이
  - 쿼리가 반환하는 각 행마다 인스턴스 하나를 만드는 것
  - 객체지향적 사고방식과 자연스럽게 어울린다.
  - 대개 사용하는 ORM 방식과 비슷함.

도메인 모델은 다음과 같이 활용할 수 있다.
- 간단한 애플리케이션의 경우 활성 레코드를 활용한다. 도메인 객체가 데이터베이스 구조에 아주 근접하게 대응 되는 구조다.
- 복잡한 애플리케이션의 경우 활성 레코드로는 한계가 있고, 대신에 도메인 객체와 데이터베이스 테이블 간의 매핑을 간접 계층을 통해 완전히 처리해서 도메인 모델을 데이터베이스로부터 격리하는 것이 더 나은 방법이다.
  - 데이터 매퍼는 가장 복잡한 데이터베이스 매핑 아키텍처이며, 두 계층의 완전한 격리라는 장점을 제공한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/2e71329a-b007-4146-adaf-9853fbbe4e8d)

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/7eaeffd4-b004-494d-8842-4904a27ebdd6)

책의 필자는 뷰를 가상 테이블이라 생각하고, 이것은 SQL에서 뷰를 취급하는 방법이기도 하다. 테이블을 쿼리할 때와 같은 구문을 뷰를 쿼리하는 데도 사용할 수 있다. 뷰와 쿼리를 업데이트할 때는 뷰를 직접 업데이트할 수 없고 기반이 되는 테이블을 조작해야 하므로 확실히 더 복잡해진다. 이런 방법으로 뷰와 쿼리를 사용할 땐, 뷰가 구성되는 방법을 이해하지 못하는 개발자가 혼란을 느낄 수 있는 단점이 있다.

객체지향 데이터베이스
- 임피던스 부정합 문제 발생
- 가장 큰 장점은 생산성 향상
- 단, 대부분의 프로젝트에선 위험성 때문에 사용하진 않는다.
- O/R 매핑 툴을 도입하는 것을 고려할 수 있다.

## 동작 문제
O/R 매핑을 활용할 때 가장 어려운 측면은 O/R 매핑의 아키텍처와 동작 측면이다.

**동작 문제는 객체가 DB에 저장 및 로드되는 방법에 대한 것이다.**
- 다수의 객체를 메모리로 로드하고 수정할 때는 객체를 DB에 올바르게 기록하기 위해 수정한 객체를 모두 추적해야 한다. 한 번에 두어 개의 레코드를 로드한다면 아주 쉬운 일이지만 로드할 객체가 많으면 이야기가 달라질 수 있다.
  - 행을 만들고 다른 행을 수정하는 작업을 함께 할 때는 생성된 행을 참조하는 다른 행을 수정하려면 생성된 행의 키가 필요하므로 문제가 더 복잡함.
- **객체를 읽고 수정하는 동안 사용하는 DB의 상태를 일관되게 유지해야 한다.**
  - 객체를 읽고 이를 대상으로 작업할 때는 다른 프로세스가 이 객체를 변경하지 못하도록 읽기를 격리해야 한다.
  - 일관성 문제, 동시성 문제

**작업 단위는 데이터베이스에서 읽은 객체와 함께 이후 다양한 방법으로 수정한 객체를 추적하고 DB를 업데이트한다.**
- 저장 메서드를 직접 호출하지 않고 작업 단위에 커밋을 요청하면 된다.
- 작업 단위는 DB에 수행할 모든 동작을 적절한 순서로 정리한 다음, 커밋을 위한 복잡한 모든 작업을 한 곳에서 처리한다.
- DB와의 동작 상호작용이 복잡할 때 필수적인 패턴이다.
- DB 매핑의 컨트롤러로 작동하는 객체라 생각하면 좋다.

**객체를 로드할 때는 같은 객체를 두 번 로드하지 않게 주의해야 한다.**
- DB 행과 연결된 인메모리 객체가 두 개가 되며, 두 객체를 모두 업데이트하면 예기치 못한 결과가 발생함.
- 읽은 모든 행의 기록을 식별자 맵을 이용해 추적하는 방식으로 이 문제를 예방할 수 있다.
  - (JPA의 EntityManager, Persistence Context가 이런식으로 동작하는게 아닐까 싶다.)

**도메인 모델을 사용할 때는 DB에서 객체를 로드할 때 연관된 객체가 함께 로드되도록 구성하는 것이 일반적이다.**
- 비효율을 예방하려면 한 번에 읽는 양을 줄이면서도 나중에 필요할 때 손쉽게 추가 데이터를 가져올 수 있게 여지를 남겨두는 방법이 필요하다.
- 지연 로드가 이 방법에 해당.
  - 참조(링크)를 따라가는 경우에만 DB에서 실제 객체를 가져올 수 있다.
  - 적절한 지점에 활용하면 DB에 대한 각 호출로 데이터를 필요한 만큼 가져올 수 있다.

## 데이터 읽기
데이터를 읽을 때는 성능 문제가 크게 다가올 수 있다. 몇 가지 규칙을 우선적으로 생각하자.

- **가급적 여러 행을 한 번에 읽는다. 특히 같은 테이블에서 여러 행을 읽기 위해 반복적으로 쿼리하는 일이 없게 해야 한다.**
  - 일반적으로 너무 많이 읽는 것이 너무 적게 읽는 것보다 낫다.
  - 단, **비관적 동시성 제어를 사용할 땐 행이 너무 많이 잠기지 않도록 주의해야 한다.**
- **조인을 사용해 쿼리 하나로 여러 테이블을 한 번에 가져온다.**
  - 결과 레코드 집합은 조금 이상해 보일 수 있지만 속도를 향상하는 데 큰 도움을 준다.
  - 다만, **데이터베이스가 쿼리당 최대 3~4개의 조인을 처리하도록 최적화된다는 것을 염두에 둬야 한다.**
  - **캐시된 뷰를 이용하면 어느 정도 만회할 수는 있지만 조인을 너무 많이 사용하면 오히려 성능이 저하된다.**

DB에선 다양한 최적화가 가능하다.
- 자주 함께 참조되는 데이터의 클러스터링
- 세심한 인덱스 사용
- 메모리 캐시 활용

## 구조적 매핑 패턴
### 관계 매핑
객체와 RDBMS의 패러다임의 차이가 있다.

- 참조 방법의 차이
- 객체는 컬렉션을 사용해 단일 필드로 손쉽게 여러 참조를 처리할 수 있는 반면 RDBMS는 정규화를 지원하기 위해 모든 연관 링크가 단일 값을 가져야 한다.

각 객체의 관계형 식별자를 객체의 식별자 필드로 유지하고 이 값을 조회해 객체 참조와 관계형 키 간의 매핑을 처리한다.
- 다대일
  - 외래 키 매핑 필요
- 다대다
  - 연관 테이블 매핑을 사용

### 상속
SQL에는 상속을 처리하는 표준적인 방법이 없기 때문에 이 경우에도 매핑을 이용해야 한다.
- 단일 테이블 상속
  - 한 테이블에 한 계층의 모든 클래스를 저장
- 구현 테이블 상속
  - 한 테이블에 한 계층의 각 구현 클래스를 저장
- 클래스 테이블 상속
  - 한 테이블에 한 계층의 각 클래스를 저장

## 매핑
RDBMS로 매핑할 때는 기본적으로 세 가지 상황 중 하나에 해당한다.

- 스키마를 직접 선택할 수 있다.
- 기존의 스키마로 매핑해야 하며, 스키마를 변경할 수 있다.
- 기존의 스키마로 매핑해야 하지만 합의를 통해 스키마를 변경할 수 있다.

---
- 도메인 모델을 사용할 때는 데이터베이스 설계와 비슷한 설계를 조심해야 한다. 즉, 데이터베이스를 염두에 두지 말고 도메인 논리를 간소화하는 데 집중하면서 도메인 모델을 구축한다.
- 도메인 논리가 간단할 때는 데이터베이스를 모방하는 행 데이터 게이트웨이나 테이블 데이터 게이트웨이 클래스를 만들고, 이 위에 도메인 논리를 배치한다.
- 도메인 논리가 복잡하다면, 도메인 모델이 필요하며, 도메인 모델은 데이터베이스 설계와는 일치하지 않을 가능성이 높다.

## 데이터베이스 연결
- 연결 풀
  - 연결을 만드는데 드는 비용을 절약
  - 직접 연결을 만들고 닫는 대신 연결이 필요할 때, 풀에서 요청하며 작업이 끝나면 연결을 풀로 반환한다.
- 연결을 만드는 비용이 크든 작든 관리가 필요하다. 연결은 관리하는 데 비용이 많이 드는 자원이므로 사용이 끝나면 즉시 닫아야 한다.
- 연결은 트랜잭션과 밀접하게 관련되므로 트랜잭션과 함께 연결을 관리하는 것이 좋은 방법이다.
  - 트랜잭션과 연결을 함께 관리하는 데는 작업 단위가 적합하다.