# 9장. 마이크로서비스 보안
견고한 마이크로서비스 아키텍처를 갖게 되면서 보안 취약점을 막는 작업은 점점 더 중요해지고 있다.

마이크로서비스 아키텍처를 안전하게 보호하는 일은 다음과 같은 여러 보호 계층과 연관되어 복잡하고 힘든 작업이다.

- 애플리케이션 계층: 적절하게 사용자를 통제하여 사용자 본인 여부와 수행하려는 작업의 수행 권한이 있는지 확인한다.
- 인프라스트럭처: 취약점의 위험도를 최소화하도록 서비스를 항상 실행하고 패치하고 최신화 한다.
- 네트워크 계층: 서비스가 명확히 정의된 포트를 통해 인가된 소수의 서버에만 접근할 수 있도록 네트워크 접근 통제를 구현한다.

## OAuth2 소개
OAuth2는 토큰 기반의 보안 프레임워크로 권한 부여 패턴을 설명하지만 실제 인증을 수행하는 방법은 정의하지 않는다. 따라서 사용자는 **ID 제공자**라고 하는 제삼자 인증 서비스로 자신을 인증할 수 있다. 사용자는 인증에 성공하면 모든 요청과 함께 전달할 토큰을 제공받고 인증 서비스에 이 토큰의 유효성을 확인한다.

OAuth2의 주요 목적은 **사용자 요청을 수행하기 위해 여러 서비스를 호출할 때, 요청을 처리하는 모든 서비스에 자격 증명을 제시하지 않고도 각 서비스에서 사용자를 인증하는 것이다.** OAuth2를 사용하면 **그랜트(grants)** 라는 인증 체계를 통해 REST 기반의 서비스를 보호할 수 있다.

OAuth2 명세에는 네 가지 그랜트 타입이 있다.

- 패스워드
- 클라이언트 자격 증명
- 인가 코드
- 암시적

다음 사항을 알아보자.

- 비교적 단순한 OAuth2 그랜트 타입인 패스워드 그랜트 타입으로 마이크로서비스에서 OAuth2 사용 방법을 논의한다.
- JWT를 사용하여 더욱 안전한 OAuth2 솔루션을 제공하고 OAuth2 토큰 정보를 인코딩하는 표준을 만든다.
- 마이크로서비스를 구축할 때 고려해야 할 다른 보안 사항을 살펴본다.

OAuth2의 진정한 강점은 애플리케이션 개발자가 제삼자 ID 제공자와 쉽게 통합할 수 있으며, 자격 증명을 제삼자 서비스에 계속 전달하지 않고도 해당 서비스에서 사용자를 인증하고 인가할 수 있다는 것이다.

OpenID Connect(OIDC)는 OAuth2 프레임워크에 기반을 둔 상위 계층으로 애플리케이션에 로그인한 사람에 대한 인증 및 프로파일 정보를 제공한다. 인가 서버가 OIDC를 지원하는 경우, **ID 제공자**라고도 한다.

## 키클록 소개
Keycloak은 서비스와 애플리케이션을 위한 ID 및 액세스 관리용 오픈 소스 솔루션이다. 키클록의 주요 목표는 서비스와 애플리케이션의 코딩을 전혀 또는 거의 하지 않고 서비스와 애플리케이션을 쉽게 보호하는 것이다.

- 인증을 중앙 집중화하고 SSO(Single Sign-On) 인증을 가능하게 한다.
- 개발자는 인가와 인증처럼 보안 측면에 대해 걱정하기보단 비즈니스 기능에 집중할 수 있다.
- 2단계 인증이 가능하다.
- LDAP과 호환된다.
- 애플리케이션과 서버를 쉽게 보호할 수 있는 여러 어댑터를 제공한다.
- 패스워드 정책을 재정의할 수 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/46bcc311-b93e-48bd-8359-e036dc4f8123)

키클록 보안은 보호 자원, 자원 소유자, 애플리케이션, 인증 및 인가 서버 등 네 가지 구성 요소로 구분할 수 있다.

- 보호 자원(Protected Resource): 적절한 권한이 있는 인증된 사용자만 접근할 수 있게 하여 보호하려는 자원이다. (이 경우 마이크로서비스)
- 자원 소유자(Resource Owner): 이 소유자는 어떤 애플리케이션이 서비스를 호출할 수 있는지, 어떤 사용자가 서비스에 대한 접근 권한을 부여받았는지, 사용자가 서비스에서 어떤 작업을 수행할 수 있는지 정의한다. 자원 소유자가 등록한 모든 애플리케이션에는 애플리케이션을 식별하는 애플리케이션 이름과 시크릿 키가 지정된다. 애플리케이션 이름과 시크릿 키 조합은 액세스 토큰을 인증할 때 전달되는 자격 증명의 정보 일부다.
- 애플리케이션(Application): 사용자를 대신하여 서비스를 호출하는 애플리케이션이다. 결국 사용자는 서비스를 직접 호출할 때가 거의 없고, 작업을 수행하려고 애플리케이션에 의존한다.
- 인증 및 인가 서버(Authentication/Authorization Server): 인증 서버는 사용 중인 애플리케이션과 서비스 사이의 중개자다. 인증 서버를 사용하면 사용자는 자격 증명을 모든 서비스(애플리케이션이 사용자 대신 호출하는)에 전달하지 않고도 자신을 인증할 수 있다.

키클록 보안 구성 요소는 서비스 사용자를 인증하기 위해 상호 작용한다. 사용자는 자격 증며오가 보호 자원(마이크로서비스)에 액세스하는 데 사용하는 애플리케이션/디바이스를 제공하여 키클록 서버로 인증한다. 사용자의 자격 증명이 유효하다면 키클록 서버는 서비스 간 전달할 수 있는 인증 토큰을 제공한다.

그런 다음 보호 자원은 키클록 서버에 토큰의 유효성을 확인하고 사용자에게 할당된 역할(role)을 가져온다. 역할은 서로 연관된 사용자를 그룹으로 만들고 사용자가 접근할 수 있는 자원을 정의하는 데 사용된다.

웹 서비스 보안은 매우 복잡한 주제다. 누가 우리 서비스를 호출할지(내부 또는 외부 사용자), 서비스를 어떻게 호출할지(내부 웹 기반 클라이언트, 모바일 디바이스나 웹 애플리케이션), 그리고 사용자는 우리 코드로 어떤 행동을 할지 이해해야 한다.

---
📌 인증과 인가
- 인증: 자격 증명을 제시하여 사용자가 누구인지 증명하는 행위
- 인가(권한 부여): 사용자가 원하는 작업을 수행할 수 있는지 여부를 결정

---

키클록을 통해 클라이언트 자격 증명의 유효성 검증 성공 시 반환되는 JSON 페이로드는 아래와 같다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/dbdd5e1c-8caa-46c7-af2d-3818257916fd)

- `access_token`: 사용자가 보호 자원에 대한 서비스를 호출할 때 제시하는 액세스 토큰이다.
- `token_type`: 인가 명세에 따라 다양한 토큰 타입을 정의할 수 있다. 가장 일반적으로 사용하는 토큰 타입은 Bearer Token이다.
- `refresh_token`: 만료된 액세스 토큰을 재발급하려고 리프레시 토큰을 인가 서버에 제출한다.
- `expires_in`: 액세스 토큰이 만료되기까지 걸리는 시간(초)이다. 스프링에서 인가 토큰 만료의 기본값은 12시간이다.
- `scope`: 이 액세스 토큰의 유효 범위를 지정한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/439d0abd-0dde-46de-aaa3-79a2eb83cfb9)

## 키클록으로 조직 서비스 보호하기
### 액세스 토큰 전파
서비스 간 토큰 전파를 보여주려 라이선싱 서비스도 키클록으로 보호할 것이다. 먼저 라이선싱 서비스가 정보를 조회하려고 조직 서비스를 호출한다는 것을 기억하자. 문제는 "토큰을 한 서비스에서 다른 서비스로 어떻게 전파하는가?"다.

아래 그림은 인증된 사용자 토큰이 게이트웨이와 라이선싱 서비스를 거쳐 조직 서비스로 어떻게 흘러가는지 보여 준다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/d0ac5ef8-8d7b-4468-ba73-b2328d08759d)

- 사용자는 키클록 서버에서 이미 인증받았고 O-stock 웹 애플리케이션에 호출한다. 사용자의 액세스 토큰은 사용자 세션에 저장된다. O-stock 웹 애플리케이션은 라이선싱 데이터를 조회하고 라이선싱 서비스의 REST 엔드포인트 호출해야 한다. 라이선싱 REST 엔드포인트 호출의 일부로 O-stock 웹 애플리케이션은 액세스 토큰을 HTTP Authorization 헤더로 추가한다. 라이선싱 서비스는 스프링 게이트웨이 뒤에서만 액세스할 수 있다.
- 게이트웨이는 라이선싱 서비스 엔드포인트를 찾은 후 라이선싱 서비스의 서버 중 하나로 호출을 전달한다. 서비스 게이트웨이는 수신된 호출에서 HTTP Authorization 헤더를 복사하여 새로운 엔드포인트에 전달한다.
- 라이선싱 서비스는 호출을 받는다. 라이선싱 서비스는 보호 자원이기 때문에 키클록 서버에 토큰의 유효성을 확인한다. 그런 다음 적절한 권한 수행을 위해 사용자 역할을 확인한다. 작업 일부로 라이선싱 서비스는 조직 서비스를 호출하며, 이 작업을 수행할 때 라이선싱 서비스는 사용자의 액세스 토큰을 조직 서비스에 전파해야 한다.
- 조직 서비스가 호출을 받으면 HTTP Authorization 헤더를 찾아 키클록 서버에 토큰의 유효성을 확인한다.

기본적으로 게이트웨이는 Cookie, Set-Cookie, Authorization 등 민감한 HTTP 헤더를 하위 서비스에 전달하지 않는다. 헤더를 전파하려면 그에 맞는 설정이 필요하다.

## 마이크로서비스 보안을 마치며
키클록은 마이크로서비스 보안 퍼즐의 한 조각일 뿐이다. 실제 사용하도록 마이크로서비스를 구성하려면 다음 실천 사항을 중심으로 마이크로서비스 보안을 구축해야 한다.

- 모든 서비스 통신에 HTTPS/SSL을 사용하라.
- 모든 서비스 호출에는 API 게이트웨이를 사용하라.
- 서비스에 대한 영역을 지정하라(공개 API 및 비공개 API)
- 불필요한 네트워크를 차단하여 마이크로서비스에 대한 공격 표면을 제한하라.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/868bb21e-c833-4b26-be73-f2525ccf1704)

## 요약
- OAuth2는 웹 서비스 호출을 보호하기 위해 다양한 메커니즘을 제공하는 토큰 기반의 인가(권한 부여) 프레임워크다. 이러한 메커니즘을 그랜트(grant)라 한다.
- OpenID Connect(OIDC)는 OAuth2 프레임워크에 기반을 둔 상위 계층으로, 애플리케이션(ID)에 로그인한 사용자에 대한 인증 및 프로파일 정보를 제공한다.
- 키클록은 마이크로서비스와 애플리케이션을 위한 오픈 소스 ID 및 액세스 관리 솔루션이다. 키클록의 주된 목표는 코딩이 거의 또는 전혀 없이 서비스와 애플리케이션을 쉽게 보호하는 것이다.
- 애플리케이션마다 키클록 애플리케이션의 고유 이름과 시크릿 키가 있다.
- 각 서비스는 역할에 따라 수행될 행위를 정의해야 한다.
- 스프링 클라우드 시큐리티는 JWT 명세를 지원한다. JWT를 사용하면 사용자가 정의한 필드를 명세에 삽입할 수 있다.
- 마이크로서비스를 보호하려면 인증 및 권한 부여 이상이 필요하다.
- 운영 환경에선 HTTPS를 사용하여 서비스 간 모든 호출을 암호화해야 한다.
- 서비스 게이트웨이를 사용하여 서비스에 도달할 수 있는 접근 지점을 줄여야 한다.
- 서비스가 실행되는 운영 체제의 인바운드 및 아웃바운드 포트 수를 제한하여 서비스에 대한 공격 표면을 제한해야 한다.