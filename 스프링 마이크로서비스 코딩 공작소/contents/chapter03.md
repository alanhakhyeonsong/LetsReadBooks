# 3장. 스프링 부트로 마이크로서비스 구축하기
마이크로서비스 아키텍처를 성공적으로 구축하는 여정은 소프트웨어 개발 조직 내 여러 개인의 관점을 통합하는 것과 관련이 있다. 전체 애플리케이션을 제공하려면 기술 인력보다 더 많은 인력이 필요하기 때문에 마이크로서비스 개발 기반을 성공적으로 다지려면 다음 세 가지 중요한 역할에서 시작할 수 있다.

- 아키텍트: 큰 그림을 염두에 두고 애플리케이션을 개별 마이크로서비스로 분해한 후 마이크로서비스가 솔루션을 제공하기 위한 상호 작용 방식을 이해한다.
- 소프트웨어 개발자: 코드를 작성하고 언어와 개발 프레임워크를 사용하여 마이크로서비스를 제공하는 방법을 이해한다.
- 데브옵스: 운영 및 비운영 환경에 서비스를 배포하고 관리하는 방법을 결정한다. 데브옵스의 신조는 모든 환경에서 일관성과 반복성이다.

## 아키텍트 이야기: 마이크로서비스 아키텍처 설계
소프트웨어 프로젝트에서 아키텍트의 역할은 해결해야 할 문제의 작동 모델을 제공하는 것이다. 아키텍트는 애플리케이션의 각 부분이 잘 조립될 수 있도록 개발자가 작성할 코드에 대한 스케폴드를 제공한다. 다음 세 가지 핵심 업무에 집중한다.

- 비즈니스 문제 분해
- 서비스 세분화 확정
- 서비스 인터페이스 정의

### 비즈니스 문제 분해
복잡함에 직면하면 대부분은 작업 중인 문제를 관리 가능한 덩어리로 쪼개려고 한다. 이렇게 하면 문제의 모든 세부 내용을 기억하지 않아도 되기 때문이다. 그들은 문제를 몇몇 필수적인 부분으로 나눈 후 이들 부분 사이에 존재하는 관계를 찾으려고 한다.

비즈니스 문제를 식별하고 마이크로서비스 후보로 분해하는 데 다음 지침을 사용할 수 있다.

- 비즈니스 문제를 기술하는 데 사용된 명사에 주목하라
- 동사에 주목하라
- 데이터 응집성을 찾아라

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/17bdd0d2-5932-42f0-b908-b530bac58592)

O-stock의 문제 영역을 마이크로서비스 후보로 분해해보자.

- 엠마가 관리하는 계약 정보를 어디에 저장할 것인가?
- 라이선스 정보는 어디에 저장하고 어떻게 관리할 것인가?
- 제니는 PC에 라이선스를 설정한다. 자산을 어디에 저장할 것인가?
- 모든 개념을 고려하면 라이선스가 여러 자산을 보유한 조직에 속해 있음을 알 수 있다. 그렇다면 조직 정보를 어디에 저장할 것인가?

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/2351498b-56ea-439f-84fd-55890e07b2ec)

### 서비스 세분화 확정
데이터 모델을 단순화했다면 애플리케이션에서 필요한 마이크로서비스를 정의하는 과정을 시작할 수 있다. 다음 네 개의 잠재적인 마이크로서비스가 있다.

- 자산
- 라이선스
- 계약
- 조직

우리의 목표는 이러한 주요 기능 부분을 서로 독립적으로 빌드하고 배포할 수 있는 완전한 자립형 유닛으로 추출하는 것이다. 이들 유닛은 데이터베이스를 공유하거나 개별적으로 가질 수 있다. 하지만 데이터 모델에서 서비스를 추출하는 것은 코드를 개별 프로젝트로 다시 패키징하는 것 이상이 필요하다. 또한 이 추출 작업은 서비스가 액세스하는 실제 데이터베이스 테이블을 파악하고 특정 문제 영역의 테이블에만 액세스를 허용하는 것도 포함한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/c76a4d77-cda0-483b-ba10-296a86f9501d)

문제 영역을 개별 조각으로 나눈 후 종종 서비스에 대한 적절한 수준의 **세분화**를 했는지 결정하는 데 어려움을 겪는다. 너무 잘거나 굵은 마이크로서비스는 몇 가지 속성을 드러낸다.

마이크로서비스를 구축할 때 세분화 질문은 필수적이다. 그래서 올바른 세분화 수준에 대한 정답을 구하려고 다음 개념들을 설명한다.

- 마이크로서비스는 광범위하게 시작하고 더 작은 서비스로 리팩터링하는 것이 좋다.
- 서비스 간 교류하는 방식에 중점을 둔다.
- 문제 도메인에 이해가 깊어지면서 서비스 책임도 계속 변한다.

나쁜 마이크로서비스의 징후는 어떤 것일까? 너무 큰 마이크로서비스는 다음 징후가 있다.

- 책임이 너무 많은 서비스
- 다수 테이블에 걸쳐 데이터를 관리하는 서비스
- 테스트가 너무 많은 서비스

그러면 너무 작은 서비스는 어떨까?

- 문제 도메인의 한 부분에 속한 마이크로서비스가 토끼처럼 번식한다.
  - 모든 것이 마이크로서비스가 되면 서비스에서 비즈니스 로직을 구성하는 것이 복잡하고 어려워진다. 작업을 완료하는 데 필요한 서비스 수가 엄청나게 증가하기 때문이다. 흔한 징후는 애플리케이션에 수십 개의 마이크로서비스가 존재하고 각 서비스가 하나의 데이터베이스 테이블과 통신할 때 나타난다.
- 마이크로서비스가 지나치게 상호 의존적이다.
- 마이크로서비스가 단순한 CRUD 서비스 집합이 된다.

마이크로서비스 아키텍처는 처음부터 올바른 설계를 얻기 어렵기 때문에 진화적 사고 프로세스로 개발되어야 한다. 그러므로 첫 서비스들을 잘게 나누기보다. **크게 나누어서 시작하는 것이 더 좋다.**

독단적 설계를 하지 않는 것도 중요하다. 서비스에 물리적 제약이 있을 수 있다. 두 개별 서비스 사이에 너무 많은 호출이 발생하거나 서비스의 도메인 경계가 명확하지 않다면 데이터를 조인하는 집계 서비스를 만들어야 한다. 끝으로 완벽한 설계를 얻고 싶어 시간을 낭비하고 노력에 비해 아무것도 보여 주지 못하는 것보다 실용적 접근 방식을 취해 설계를 전달하자.

### 서비스 인터페이스 설계
아키텍처에 대한 마지막 조언은 애플리케이션 내 마이크로서비스들의 상호 통신 방식의 정의에 관한 것이다. 마이크로서비스로 비즈니스 로직을 구축할 때 서비스의 인터페이스는 직관적이어야 하고 개발자는 애플리케이션의 서비스 중 한두 개를 완전히 이해함으로써 모든 서비스가 어떻게 동작하는지 규칙을 습득해야 한다. 서비스 인터페이스 설계에 대해 일반적으로 다음 지침을 사용할 수 있다.

- REST 철학을 수용하라.
- URI를 사용하여 의도를 전달하라.
- 요청과 응답에 JSON을 사용하라.
- HTTP 상태 코드로 결과를 전달하라.

모든 기본 지침은 서비스 인터페이스를 쉽게 이해하고 소비할 수 있게 만드는 것이 목표다.

## 마이크로서비스를 사용하지 말아야 할 때
### 분산 시스템 구축의 복잡성
마이크로서비스는 분산되고 세분화되어 있어 모놀리식 애플리케이션에서 없던 복잡성이 발생한다. 또한 마이크로서비스 아키텍처에선 높은 운영 성숙도도 필요하다. 따라서 조직에서 고도로 분산된 애플리케이션을 성공시키는 데 필요한 자동화와 운영 작업(모니터링, 확장 등)에 기꺼이 투자하지 않는 한 마이크로서비스 사용을 고려하지 않는 편이 좋다.

### 서버 또는 컨테이너 스프롤
마이크로서비스의 가장 일반적인 배포 모델은 컨테이너당 하나의 마이크로서비스 인스턴스를 배포하는 것이다. 대규모 마이크로서비스 기반 애플리케이션에서 운영 환경에서만 구축 및 관리해야 하는 서버나 컨테이너는 50~100개 정도일 수 있다. 그리고 클라우드에서 이들 서비스를 실행하는 데 드는 비용이 저렴하더라도 서버를 관리하고 모니터링하는 운영 작업은 엄청나게 복잡할 수 있다.

### 애플리케이션 타입
마이크로서비스는 재사용성을 추구하며 고도의 회복성과 확장성이 필요한 대규모 애플리케이션을 구축하는 데 매우 유용하다. 하지만 부서 수준의 소규모 애플리케이션이나 적은 사용자 기반의 애플리케이션을 만들 때 마이크로서비스와 같은 분산 모델로 구축한다면 연관된 복잡성 때문에 그 가치보다 더 많은 비용이 발생할 수 있다.

### 데이터 트랜잭션과 일관성
마이크로서비스를 검토하기 시작할 때 서비스와 서비스 소비자의 데이터 사용 패턴을 충분히 생각해야 한다. 마이크로서비스는 적은 수의 테이블을 추상화하며, 데이터 저장소에 단순한 쿼리 생성, 추가, 실행 등 '운영성' 작업을 수행하는 메커니즘으로 잘 동작한다. 애플리케이션이 여러 데이터 소스에 걸쳐 복잡한 데이터를 집계하고 변환해야 한다면 마이크로서비스의 분산된 특성으로 이 작업은 어려워진다. 마이크로서비스는 어쩔 수 없이 과도한 책임을 떠안고 성능 문제에서도 취약하게 된다.

## 데브옵스 이야기: 혹독한 런타임 구축
- 마이크로서비스는 일체형이어야 한다.
- 마이크로서비스는 구성 가능해야 한다.
- 마이크로서비스 인스턴스는 클라이언트에 투명해야 한다.
- 마이크로서비스는 자기 상태를 전달해야 한다.

이 네 가지 원칙은 마이크로서비스 개발에서 존재할 수 있는 역설을 드러낸다. 마이크로서비스는 크기와 범위가 작지만 분산되어 있고, 자체 컨테이너에서 독립적으로 실행되므로 애플리케이션에 구동하는 부품은 더 많아진다. 이 때문에 애플리케이션은 정교한 조정 기술을 필요로 하고 더 많은 장애 기회를 갖게 된다.

데브옵스 관점에서 마이크로서비스와 관련된 운영상 요구 사항을 사전에 해결하고, 이러한 네 가지 원칙을 마이크로서비스를 빌드하고 환경에 배포할 때마다 발생하는 표준 수명 주기 이벤트로 변환해야 한다. 이 네 가지 원칙은 다음에 나오는 운영 수명 주기에 매핑할 수 있다.

- 서비스 조립: 동일한 서비스 코드와 런타임이 정확히 동일한 방식으로 배포되도록 반복성과 일관성을 보장하면서 서비스를 패키징하고 배포하는 방법이다.
- 서비스 부트스트래핑: 마이크로서비스를 사람의 개입 없이 모든 환경에서 빠르게 시작하고 배포할 수 있도록 런타임 코드에서 애플리케이션 코드와 환경별 구성 코드를 분리하는 방법이다.
- 서비스 등록 및 디스커버리: 새 마이크로서비스 인스턴스가 배포될 때 애플리케이션 클라이언트가 새 서비스 인스턴스를 발견할 수 있는 방법이다.
- 서비스 모니터링: 마이크로서비스 환경에서 높은 가용성이 요구되므로 한 서비스에 여러 인스턴스를 실행하는 것이 일반적이다. 데브옵스 관점에서 마이크로서비스 인스턴스를 모니터링해야 하며 장애가 발생한 서비스 인스턴스를 우회해서 라우팅하고 종료되는지 확인해야 한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/5c96b175-28dc-4b57-89e3-5b7d06b8440e)

### 서비스 조립: 마이크로서비스의 패키징과 배포
데브옵스 관점에서 마이크로서비스 아키텍처의 핵심 개념은 애플리케이션의 환경 변화에 대응하여 마이크로서비스의 많은 인스턴스를 신속히 배포할 수 있다는 것이다. (갑작스런 사용자 요청의 유입, 인프라스트럭처 문제 등에 대응)

이를 위해 마이크로서비스는 정리된 모든 의존성을 포함한 단일 산출물로 패키징되고 설치될 수 있어야 한다. 마이크로서비스를 호스팅하는 런타임 엔진(HTTP 서버나 애플리케이션 컨테이너)도 이들 의존성에 포함된다.

일관된 빌드, 패키징, 배포 과정이 1단계인 서비스 조립 단계다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/6ae2ca7c-55e9-406e-b60f-db6c4679bf38)

다행히 거의 모든 자바 마이크로서비스 프레임워크는 코드와 함께 패키징하고 배포할 수 있는 런타임 엔진을 포함한다. 예를 들어 스프링 부트 예제에서 메이븐과 스프링 부트는 내장형 톰캣 엔진을 포함하여 JAR 실행 파일을 빌드한다. 아래 명령어 예에서 라이선싱 서비스를 JAR 실행 파일로 빌드하고 JAR를 실행한다.

```bash
mvn clean package && java -jar target/licensing-service-0.0.1-SNAPSHOT.jar
```

어떤 운영 팀에는 런타임 환경을 바로 JAR 파일에 내장하는 개념이 애플리케이션 배포 방법에서 큰 변화가 될 수 있다. 전통적인 자바 웹 애플리케이션에서 애플리케이션은 애플리케이션 서버에 배포된다. 이 모델에서 애플리케이션 서버는 그 자체로 하나의 개체라서 애플리케이션과 독립적으로 서버의 구성을 감독하는 시스템 관리자 팀이 관리했다.

애플리케이션 서버의 구성을 애플리케이션과 분리하면 배포 과정에서 문제점이 발생되는데, 이것은 많은 조직에서 애플리케이션 서버의 구성 정보를 소스 제어 저장소에서 관리하지 않고 사용자 인터페이스나 자체 관리 스크립트로 관리하기 때문이다. 결국 애플리케이션 서버 환경에서 구성 불일치가 너무 쉽게 발생하여 표면적으로 무작위 장애를 갑자기 일으킨다.

### 서비스 부트스트래핑: 마이크로서비스의 구성 관리
서비스 부트스트래핑은 마이크로서비스가 처음 시작하고 애플리케이션 구성 정보를 로드할 때 일어난다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/ab779834-f4de-455b-a99f-0fadb64ec22c)

모든 애플리케이션 개발자가 알고 있든 애플리케이션의 런타임 동작을 구성 가능하게 만들어야 할 때가 있다. 일반적으로 이 작업은 애플리케이션과 함께 배포된 프로퍼티 파일에서 구성 데이터를 읽거나 관계형 데이터베이스 같은 데이터 저장소에서 데이터를 읽어 오는 것이 해당된다.

마이크로서비슨느 대개 동일한 종류의 구성을 요구한다. 차이점은 클라우드에서 실행되는 마이크로서비스 애플리케이션에는 수백 또는 수천 개의 마이크로서비스가 실행될 수 있다는 것이다. 서비스가 전 세계로 확장되면 이 문제는 더 복잡해진다. 지리적으로 분산된 서비스 수가 많기 때문에 새로운 구성 데이터를 가져오기 위해 서비스를 재배포하는 일은 수행하기 어렵다. 서비스 외부의 데이터 저장소에 데이터를 저장하면 이 문제가 해결되지만, 클라우드의 마이크로서비스 상황에선 다음 몇 가지 고유한 난제가 있다.

- 구성 데이터는 구조가 단순한 편이라서 보통 자주 읽고 간혹 쓴다. 관계형 데이터베이스는 단순한 키-값 조합보다 훨씬 더 복잡한 데이터 모델을 관리하는 용도로 설계되었기 때문에 이 상황에선 과분하다.
- 데이터는 정기적으로 액세스되지만 드물게 변경되므로 데이터의 읽기 지연 시간은 낮아야 한다.
- 데이터 저장소는 고가용성을 유지하고 데이터를 읽는 서비스에 가까워야 한다. 구성 데이터 저장소는 애플리케이션의 단일 장애 지점이기 때문에 완전히 다운되면 안 된다.

### 서비스 등록과 디스커버리: 클라이언트가 마이크로서비스와 통신하는 방법
마이크로서비스 소비자 관점에서 마이크로서비스는 위치 투명성을 가져야 한다. 클라우드 기반 환경에서 서버는 일시적이기 때문이다. 이는 서비스를 호스팅하는 서버가 일반적으로 기업 데이터 센터에서 실행되는 서비스보다 수명이 짧다는 것을 의미한다. 클라우드 기반 서비스는 자기 서버에 완전히 새로운 IP 주소를 할당받아 신속하게 시작되고 종료될 수 있다.

서비스를 수명이 짧고 폐기 가능한 상태로 다루자는 주장 덕에 마이크로서비스 아키텍처는 많은 서비스 인스턴스를 실행하며 높은 수준의 확장성과 가용성을 얻을 수 있다. 그리고 상황이 허락되는 한 신속하게 서비스 요구와 회복탄력성을 관리할 수 있다. 모든 서비스에는 고유하고 비영구적인 IP 주소가 할당되어 있다. '일시적' 서비스의 단점은 끊임없이 서비스 시작과 종료를 반복하는 상황에서 대규모 서비스를 수동 또는 직접 관리하면서 장애를 초래할 수 있다는 것이다.

마이크로서비스 인스턴스는 제3자 에이전트에 자신을 등록해야 하는데, 이 등록 과정을 **서비스 디스커버리**라고 한다. 마이크로서비스 인스턴스가 서비스 디스커버리 에이전트에 등록될 때, 인스턴스는 에이전트에 다음 두 가지 정보를 제공한다.

- 물리적 IP 주소(또는 서비스 인스턴스의 도메인 주소)
- 애플리케이션이 서비스를 찾을 때 사용되는 논리적 이름

특정 서비스 디스커버리 에이전트의 경우 상태 확인을 수행하는 데 사용할 호출 가능한 URL을 등록할 때 서비스에 요구하기도 한다. 이제 서비스 클라이언트는 디스커버리 에이전트와 통신하여 서비스 위치를 찾는다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/b41deb99-d92c-4e64-8faa-459e956377c5)

### 마이크로서비스의 상태 전달
서비스 디스커버리 에이전트는 클라이언트를 서비스 위치로 안내하는 교통 경찰 역할만 하는 것은 아니다. 클라우드 기반 마이크로서비스엔 애플리케이션에서 실행 중인 서비스 인스턴스가 많고, 조만간 그 서비스 인스턴스 중 하나가 고장날 수 있다. 서비스 디스커버리 에이전트는 등록된 각 서비스 인스턴스 상태를 모니터링하고 라우팅 테이블에서 실패한 서비스 인스턴스를 제거하여 클라이언트가 실패한 서비스 인스턴스와 통신하지 않도록 한다.

마이크로서비스가 시작된 후 서비스 디스커버리 에이전트는 해당 서비스가 가용한지 확인하고자 지속적으로 모니터링하고 상태 확인 인터페이스를 ping 한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/49046000-7efe-42d6-9bda-27aecbe4efcd)

일관된 상태 확인 인터페이스를 만들어 클라우드 기반 모니터링 도구를 사용하여 문제를 탐지하고 적절히 대응할 수 있다. 서비스 디스커버리 에이전트가 문제가 있는 서비스 인스턴스를 발견하면 고장 난 인스턴스를 종료시키거나 새로운 서비스를 추가하는 등 정상화 조치를 할 수 있다.

REST를 사용하는 마이크로서비스 환경에서 상태 확인 인터페이스를 만드는 가장 단순한 방법은 JSON 페이로드와 HTTP 상태 코드를 응답하는 HTTP 엔드포인트를 노출하는 것이다. 스프링 부트 기반이 아닌 마이크로서비스에선 서비스 상태를 반환하는 엔드포인트를 작성하는 일은 대개 개발자 책임인 경우가 많다.

하지만 스프링 부트에선 엔드포인트를 노출하기 어렵지 않고, 스프링 액추에이터 모듈을 포함하도록 빌드 파일만 수정하면 된다.

## 모든 관점 통합하기
클라우드의 마이크로서비스는 언뜻 보기엔 단순해 보인다. 하지만 성공하려면 아키텍트, 개발자, 데브옵스 엔지니어의 관점을 모아 종합된 비전을 달성하는 관점의 통합이 필요하다. 각 역할 관점의 핵심은 다음과 같다.

- 아키텍트: 비즈니스 문제의 자연스러운 윤곽을 찾는 데 집중한다. 비즈니스 문제 영역을 설명하고 스토리를 들어본다면, 대상 마이크로서비스 후보가 드러날 것이다. 처음부터 세분화된 많은 서비스에서 시작하는 것보다 크게 나눈 마이크로서비스에서 시작해서 작은 서비스로 리팩터링하는 것이 낫다는 것도 기억하자. 대부분의 좋은 아키텍처와 마찬가지로 마이크로서비스도 창발적이며 사전에 세세히 계획되는 것은 아니다.
- 소프트웨어 엔지니어: 서비스가 작다 해서 좋은 설계 원칙을 포기하라는 것은 아니다. 서비스 안의 각 계층마다 책임이 분리된 계층화된 서비스를 구축하는 데 집중하라. 코드에서 프레임워크를 만들려는 유혹을 피하고 완전히 독립적인 마이크로서비스를 지향하라. 성급하게 프레임워크를 설계하고 채택하면 애플리케이션 수명 주기 후반에 막대한 유지 보수 비용을 초래할 수 있다.
- 데브옵스 엔지니어: 서비스는 외부와 단절된 것이 아니다. 서비스의 수명 주기를 조기에 수립하라. 데브옵스 관점에서 서비스 빌드와 배포를 자동화하는 방법뿐 아니라 서비스 상태를 모니터링하고 문제가 발생할 때 대응하는 방법도 주목해야 한다. 대개 서비스를 운영하는 것은 비즈니스 로직을 작성하는 것보다 더 많은 작업과 고려가 필요하다.

## 요약
- 마이크로서비스의 성공을 위해 아키텍트, 소프트웨어 개발자, 데브옵스 이 세 팀의 관점을 통합해야 한다.
- 마이크로서비스는 강력한 아키텍처 패러다임이지만 장단점이 있다. 모든 애플리케이션이 마이크로서비스 애플리케이션일 필요는 없다.
- 아키텍트 관점에서 마이크로서비스는 작고 독립적이며 분산되어 있다. 마이크로서비스는 그 경계가 좁고 소규모 데이터를 관리해야 한다.
- 개발자 관점에서 마이크로서비스는 일반적으로 REST 스타일 디자인을 사용해서 구축되고 데이터를 주고받을 수 있는 페이로드로 JSON을 사용한다.
- 국제화의 주요 목표는 다양한 형식과 언어로 콘텐츠를 제공하는 애플리케이션을 개발하는 것이다.
- HATEOAS는 애플리케이션 상태 엔진인 하이퍼미디어의 줄임말이다. 스프링 HATEOAS는 HATEOAS 원칙을 따르는 API를 생성할 수 있는 작은 프로젝트다.
- 데브옵스 관점에서 마이크로서비스를 패키징, 배포, 모니터링하는 방법은 매우 중요하다. 스프링 부트를 사용하면 추가 모듈의 설치 없이 기본적으로 서비스를 실행 가능한 하나의 JAR 파일로 제공할 수 있다. 이렇게 생성된 JAR 파일에 포함된 Tomcat 서버가 서비스를 호스팅한다.
- 스프링 부트 프레임워크에 포함된 스프링 액추에이터는 서비스의 런타임 정보와 함께 서비스의 운영 상태 정보도 제공한다.