# 6장. 서비스 디스커버리
분산 아키텍처에선 호스트 이름과 머신이 위치한 IP 주소를 알아야 한다. 이 개념은 공식적으로 '서비스 디스커버리'로 알려져 있다.

서비스 디스커버리는 애플리케이션이 사용하는 모든 원격 서비스의 주소가 포함된 프로퍼티 파일을 관리하는 것처럼 단순하거나 UDDI(Universal Description, Discovery, and Integration) 저장소처럼 정형화된 것일 수 있다. 서비스 디스커버리는 다음 두 가지 핵심적인 이유로 마이크로서비스의 클라우드 기반 애플리케이션에 매우 중요하다.

- 수평 확장: 대개 이 패턴은 애플리케이션 아키텍처에서 클라우드 서비스 내 더 많은 서비스 인스턴스 및 컨테이너를 추가하는 것과 같은 조정을 요구한다.
  - 필요에 따라 새로운 서비스 인스턴스를 확장할 수 있고, 이러한 배포를 추상화하는 데 도움이 되며 서비스 소비자가 배포에 영향을 받지 않게 해준다.
- 회복성: 이 패턴은 비즈니스에 영향을 주지 않고 아키텍처와 서비스 내부의 문제로 충격을 흡수하는 능력을 의미한다. 마이크로서비스 아키텍처에선 한 서비스의 문제가 전체로 확산되어 서비스 소비자에게 전파되는 것을 막는데, 매우 신중해야 한다.
  - 인스턴스가 비정상이거나 가용하지 못한 상태가 되면 대부분의 서비스 디스커버리 엔진은 그 인스턴스를 가용 서비스 목록에서 제거한다.

## 서비스 위치 확인
애플리케이션이 여러 서버에 분산된 자원을 호출할 경우 이 자원들의 물리적 위치를 알고 있어야 한다. 클라우드가 아닌 환경에서 서비스 위치 확인은 대개 DNS와 네트워크 로드 밸런서의 조합으로 해결되었다. 이러한 전통적인 시나리오에서 애플리케이션은 조직의 다른 부분에 위치한 서비스를 호출해야 할 때 서비스의 고유 경로와 일반적인 DNS 이름을 사용하여 호출을 시도했다. DNS 이름은 F5 로드 밸런서 등 상용 로드 밸런서나 HAProxy 등 오픈 소스 로드 밸런서 위치로 정의된다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/9794c3ad-87f4-469f-8df2-0ddfdb834902)

전통적 시나리오에서 서비스 소비자에게서 요청받은 로드 밸런서 라우팅 테이블 항목에는 서비스를 호스팅하는 한 개 이상의 서버 목록이 있다. 로드 밸런서는 이 목록에서 서버 하나를 골라 요청을 전달한다.

이러한 모델은 사방이 벽으로 둘러싸인 회사 데이터 센터 안에서 실행되는 애플리케이션과 고정적인 서버에서 실행되는 비교적 적은 수의 서비스에서 잘 동작하지만 클라우드 기반의 마이크로 서비스 애플리케이션에선 잘 동작하지 않는다.

- 고가용성 로드 밸런서를 만들 수 있더라도 전체 인프라스트럭처에서 보면 단일 장애 지점이다.
- 서비스를 하나의 로드 밸런서 클러스터에 집중시키면 여러 서버에 부하를 분산하는 인프라스트럭처의 수평 확장 능력이 제한된다.
- 전통적인 로드 밸런서 대부분은 고정적으로 관리된다.
- 로드 밸런서가 프록시 역할을 하므로 서비스 소비자 요청은 물리적 서비스에 매핑되어야 한다.

로드 밸런서는 중앙 집중식 네트워크 인프라스트럭처로 처리할 수 있는 대부분의 애플리케이션 크기와 규모를 가진 기업 환경에서 잘 작동한다. 그리고 로드 밸런서는 SSL 종료를 처리하고 서비스 포트 보안을 관리하는 데 여전히 중요한 역할을 한다. 로드 밸런서는 뒷단의 모든 서버에 대한 들어오고 나가는 포트의 접근을 제한할 수 있다. 이런 '최소 네트워크 접근' 개념은 종종 PCI 규정 준수 처럼 산업 표준 인증에 대한 요구 사항을 충족하려 할 때 중요한 요소가 된다.

하지만 대규모 트랜잭션과 이중화를 처리해야 하는 클라우드에선 중앙 집중식 네트워크 인프라스트럭처는 효율적으로 확장되지도 않고 비용 효율도 낮아서 제대로 작동하지 않는다.

## 클라우드에서 서비스 디스커버리
클라우드 기반 마이크로서비스 환경에서 해결책은 다음과 같은 특성을 가진 서비스 디스커버리 메커니즘을 사용하는 것이다.

- 고가용성: 서비스 디스커버리는 서비스 디스커버리 클러스터의 노드 간 서비스 검색 정보가 공유되는 핫 클러스터링 환경을 지원할 수 있어야 한다. 한 노드가 가용하지 않으면 클러스터 내 다른 노드가 그 역할을 대신해야 한다.
- P2P: 서비스 디스커버리 클러스터의 모든 노드는 서비스 인스턴스의 상태를 상호 공유한다.
- 부하 분산: 서비스 디스커버리는 요청을 동적으로 분산시켜 관리하고 있는 모든 서비스 인스턴스에 분배해야 한다.
- 회복성: 서비스 디스커버리 클라이언트는 서비스 정보를 로컬에 캐싱해야 한다.
- 결함 내성: 서비스 디스커버리가 비정상 서비스 인스턴스를 탐지하면 클라이언트 요청을 처리하는 가용 서비스 목록에서 해당 인스턴스를 제거해야 한다.

### 서비스 디스커버리 아키텍처
서비스 디스커버리를 논의하려면 다음 네 가지 개념을 이해해야 한다. 대개 이러한 일반적인 개념은 모든 서비스 디스커버리 구현체에 적용된다.

- 서비스 등록: 서비스 디스커버리 에이전트에 등록하는 방법이다.
- 클라이언트의 서비스 주소 검색: 서비스 클라이언트가 서비스 정보를 검색하는 방법이다.
- 정보 공유: 노드 간 서비스 정보를 공유하는 방법이다.
- 상태 모니터링: 서비스가 서비스 디스커버리에 상태를 전달하는 방법이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/d44cee81-e252-48a1-aa66-935850a108ee)

서비스 디스커버리의 주요 목표는 **서비스의 물리적 위치를 수동으로 구성할 필요 없이 위치를 알려 줄 수 있는 아키텍처를 구축하는 것이다.** 서비스 인스턴스가 추가 및 제거되는 방식과 서비스 디스커버리 에이전트를 업데이트하는 방법, 사용자 요청을 처리하는 데 사용할 수 있는 방법을 보여준다.

위 그림에선 앞서 설명한 네 가지 개념의 흐름과 서비스 디스커버리 패턴을 구현할 때 흔히 발생하는 일을 볼 수 있다. 일반적으로 서비스 디스커버리 인스턴스 앞에는 로드 밸런서를 두지 않는다.

- 서비스 인스턴스는 시작할 때 서비스 검색 인스턴스가 자신을 액세스하는 데 사용할 물리적 위치, 경로, 포트를 등록한다.
- 서비스의 각 인스턴스엔 고유 IP 주소와 포트가 있지만 동일한 서비스 ID로 등록된다.
- 서비스는 일반적으로 하나의 서비스 디스커버리 인스턴스에만 등록된다.
- 각 서비스 인스턴스는 자기 상태를 서비스 디스커버리 서비스에 푸시하거나 가져온다. 정상 상태를 전달하지 못한 서비스는 가용 서비스 인스턴스 풀에서 제거된다.

맨 처음 접근 방법은 클라이언트가 오로지 서비스 디스커버리 엔진에만 완전히 의존하여 서비스를 호출할 때마다 서비스 위치를 확인하는 것이다. 불행히도 이는 서비스 클라이언트가 서비스를 찾고 호출하는 데 서비스 디스커버리 엔진에 완전히 의존하기 때문에 취약한 방법이다.

더욱 견고한 방법은 **클라이언트 측 로드 밸런싱**으로 알려진 방법을 사용하는 것이다. 이 메커니즘은 존별 또는 라운드 로빈 같은 알고리즘을 사용하여 호출할 서비스의 인스턴스를 호출한다. '라운드 로빈 알고리즘식 로드 밸런싱'을 이야기할 때 우리는 클라이언트 요청을 여러 서버에 분산시키는 방법을 의미한다. 이는 클라이언트 요청을 차례로 각 서버에 전달하는 것이다.

유레카와 함께 클라이언트 측 로드 밸런싱을 사용하는 장점은 서비스 인스턴스가 다운되면, 인스턴스가 레지스트리에서 제거된다는 것이다. 이 작업이 완료되면 클라이언트 측 로드 밸런서는 레지스트리 서비스와 지속적으로 통신하여 자동으로 레지스트리를 업데이트한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/52816759-9c59-4bb5-b414-9bb8a54858f0)

위 모델에서 서비스를 소비하는 클라이언트는 서비스를 호출해야 할 때 다음 작업을 한다.

1. 서비스 소비자가 요청하는 모든 인스턴스를 위해 디스커버리 서비스와 소통한 후 데이터를 서비스 소비자의 로컬 머신에 저장한다.
2. 클라이언트가 서비스를 호출할 때마다 서비스 소비자는 캐시에서 서비스 위치 정보를 검색한다. 일반적으로 클라이언트 측 캐싱은 서비스 호출이 여러 서비스 인스턴스에 분배되도록 라운드 로빈 부하 분산 알고리즘처럼 단순한 알고리즘을 사용한다.
3. 클라이언트는 주기적으로 서비스 디스커버리 서비스와 소통해서 서비스 인스턴스에 대한 캐시를 갱신한다. 클라이언트 캐시는 궁극적으로 일관적이지만 클라이언트가 서비스 디스커버리 인스턴스에 접속할 때 비정상 서비스 인스턴스를 호출할 위험은 항상 존재한다.

### 스프링과 넷플릭스 유레카를 사용한 서비스 디스커버리
스프링 클라우드에서 설정은 큰 일이 아니다. 스프링 클라우드와 넷플릭스 유레카의 서비스 디스커버리 엔진을 사용하여 서비스 디스커버리 패턴을 구현한다. 클라이언트 측 로드 밸런싱을 위해 스프링 클라우드 로드 밸런서를 사용한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/03de654b-146c-468c-9808-897a7a19d657)

조직 서비스의 실제 위치는 서비스 디스커버리 레지스트리에 보관된다. 이 예에서 조직 서비스의 두 인스턴스를 서비스 디스커버리 레지스트리에 등록한 후 클라이언트 측 로드 밸런싱을 사용하여 각 서비스 인스턴스에서 레지스트리를 검색하고 캐시한다.

1. 서비스 부트스트래핑 시점에 라이선싱 및 조직 서비스는 유레카 서비스에 등록한다. 이 등록 과정에서 시작하는 서비스의 서비스 ID와 해당 서비스 인스턴스의 물리적 위치 및 포트 번호를 유레카에 알려준다.
2. 라이선싱 서비스가 조직 서비스를 호출할 때 스프링 클라우드 로드 밸런서를 사용하여 클라이언트 측 로드 밸런싱을 제공한다. 이 로드 밸런서는 유레카 서비스에 접속하여 서비스 위치 정보를 검색하고 로컬에 캐시한다.
3. 스프링 클라우드 로드 밸런서는 유레카 서비스를 주기적으로 ping 해서 로컬 캐시의 서비스 위치를 갱신한다.

## 스프링 유레카 서비스 구축
책의 내용은 구버전이라 [공식 문서](https://docs.spring.io/spring-cloud-netflix/reference/spring-cloud-netflix.html)를 보도록 하자.

```yaml
server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

- `eureka.instance.hostname` : 유레카 서비스의 인스턴스 호스트 이름을 설정한다.
- `eureka.client.registerWithEureka` : 스프링 부트로 된 유레카 애플리케이션이 시작할 때 컨피그 서버를 유레카에 등록하지 않도록 설정한다.
- `eureka.client.fetchRegistry` : `false`로 지정하면 유레카 서비스가 시작할 때 레지스트리 정보를 로컬에 캐싱하지 않도록 설정한다. 유레카 클라이언트를 실행할 때 유레카에 등록할 스프링 부트 서비스를 위한 이 값을 변경할 수 있다.
- `eureka.client.serviceUrl.defaultZone` : 모든 클라이언트에 대한 서비스 URL을 제공한다. URL은 `eureka.instance.hostname`과 `server.port` 프로퍼티 두 개의 조합으로 되어 있다.
- `eureka.server.waitTimeInMsWhenSyncEmpty` : 서버가 요청을 받기 전 대기 시간을 설정한다.

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
```

## 스프링 유레카에 서비스 등록
스프링 부트 기반의 마이크로서비스를 유레카에 등록하는 작업은 매우 간단하다.

```yaml
spring:
  application:
    name: organization-service
    profiles:
      active: dev
  cloud:
    config:
      uri: http://localhost:8071
```

유레카에 등록할 모든 서비스는 위와 같은 형식으로 등록하면 된다.

유레카에 이 서비스를 등록하려면 해당 `application.yml` 파일의 옵션을 아래와 같이 수정한다.

```yaml
server:
  port: 8761

eureka:
  instance:
    hostname: localhost
    preferIpAddress: true
  client:
    registerWithEureka: true
    fetchRegistry: true
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

`eureka.instance.preferIpAddress`는 서비스의 호스트 이름이 아닌 IP 주소를 유레카에 등록하도록 지정하는 것이다.

DNS 기반의 호스트 이름으로 할당되는 서버 기반 환경에선 잘 잘동하지만 컨테이너 기반의 배포 환경에서 컨테이너는 DNS 엔트리가 임의로 생성한 호스트 이름을 할당해서 시작되므로 `true`로 두는게 좋다. 이 프로퍼티를 설정하면 클라이언트가 IP 주소로 전달받도록 유레카에 알려 준다.

## 요약
- 서비스 디스커버리 패턴을 사용하여 서비스의 물리적 위치를 추상화한다.
- 유레카 같은 서비스 디스커버리 엔진은 서비스 클라이언트에 영향을 주지 않고 해당 환경에서 서비스 인스턴스를 원활하게 추가하고 삭제할 수 있다.
- 클라이언트 측 로드 밸런싱을 사용하면 서비스 호출을 수행하는 클라이언트에서 서비스의 물리적 위치를 캐싱하여 더 높은 성능 및 회복성을 제공할 수 있다.
- 유레카는 스프링 클라우드와 함께 사용할 때 쉽게 구축하고 구성할 수 있는 넷플릭스 프로젝트다.
- 스프링 클라우드와 넷플릭스 유레카에서 서비스를 호출하는 데 다음 세 가지 다른 메커니즘을 사용할 수 있다.
  - 스프링 클라우드 Discovery Client
  - 스프링 클라우드 로드 밸런서를 지원하는 RestTemplate
  - 넷플릭스 Feign 클라이언트