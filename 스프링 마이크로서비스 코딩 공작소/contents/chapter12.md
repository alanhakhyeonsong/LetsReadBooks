# 12장. 마이크로서비스 배포
마이크로서비스의 주요 장점은 마이크로서비스가 상호 독립적으로 운영 환경에 빠르게 빌드, 수정, 배되는 작은 코드 단위라는 것이다. 서비스 크기가 작으면 새로운 제품 기능(및 치명적인 버그 수정)이 빠른 속도로 전달될 수 있다. 여기에서 속도는 핵심이다. 속도가 빠르다는 것은 제품 기능 개발 및 버그 수정과 재배포 사이에 마찰이 거의 없음을 나타내기 때문이다. 배포 소요 시간은 며칠이 아닌 수분 내여야 한다. 이를 위해 코드를 빌드하고 배포하는데 사용할 메커니즘이 필요하다.

- 자동화: 빌드/배포 과정에 사람의 개입이 없어야 한다. 소프트웨어 빌드, 머신 이미지 프로비저닝, 서비스 배포의 모든 과정이 자동화되어야 하고, 이 과정은 소스 저장소에 코드를 커밋하는 행위로 시작되어야 한다.
- 반복성: 소프트웨어의 빌드 및 배포 프로세스는 반복 가능해야 한다. 즉, 빌드 및 배포가 시작될 때마다 동일한 일이 수행된다. 프로세스의 변동성은 추적하고 해결하기 어려운 미묘한 버그의 원인이 될 때가 많다.
- 완전성: 배포된 산출물의 결과는 서비스를 위한 '완전한' 런타임 환경을 포함하는 가상 머신이나 컨테이너 이미지(ex. Docker) 전체가 되어야 한다. 이것은 인프라스트럭처에 대한 생각에서 중요한 변화다.  
머신 이미지 프로비저닝은 스크립트로 완전히 자동화되어야 하며, 소스 코드와 마찬가지로 소스 제어 되어야 한다. 마이크로서비스 환경에서 이러한 책임은 일반적으로 운영 팀에서 서비스를 소유한 개발 팀으로 이동한다. 마이크로서비스 개발의 핵심 사상 중 하나는 개발자가 서비스에 대한 완전한 운영 책임을 갖게 하는 것이다.
- 불변성: 서비스가 포함된 머신 이미지가 빌드되고 나면 이미지를 배포한 후 이미지의 런타임 구성을 건드리거나 변경해서는 안 된다. 변경이 필요하다면 소스 제어로 관리되는 스크립트에서 변경해야 하며, 서비스 및 인프라스트럭처는 빌드 프로세스를 다시 거쳐야 한다.  
런타임 구성(ex. GC 설정, 스프링 프로파일 등)은 환경 변수로 이미지에 전달되어야 하며, 애플리케이션 구성은 컨테이너와 분리되어야 한다. (Spring Cloud Config)

## 빌드/배포 파이프라인 아키텍처
![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/f21d5e2e-1e65-4a24-85d0-a92829570de7)

위 그림은 지속적 통합(CI) 구현에 사용되는 일반적인 빌드/배포 패턴을 기반으로 하므로 다소 친숙할 것이다.

1. 개발자는 소스 저장소에 코드를 커밋한다.
2. 빌드 도구는 변경 사항에 대해 소스 제어 저장소를 모니터링하고 변경이 감지되면 빌드한다.
3. 빌드하는 동안 애플리케이션의 단위 및 통합 테스트가 실행되고 모두 통과하면 배포 가능한 소프트웨어 산출물이 생성된다. (JAR, WAR, EAR)
4. 그런 다음 JAR, WAR, EAR가 다른 서버(일반적으로 개발 서버)에 실행 중인 애플리케이션 서버에 배포될 수 있다.

코드 배포가 준비될 때까지 빌드/배포 파이프라인은 유사한 프로세스를 따른다. 지속적 전달(CD)를 추가한다.

1. 개발자는 소스 저장소에 코드를 커밋한다.
2. 빌드/배포 엔진은 변경 사항에 대해 소스 코드 저장소를 모니터링한다. 코드가 커밋되면 빌드/배포 엔진은 코드를 체크하고 빌드 스크립트를 실행한다.
3. 빌드 스크립트가 코드를 컴파일하고 단위 및 통합 테스트를 수행한 후 서비스는 실행 가능한 산출물로 컴파일된다.
4. 실행 가능한 JAR가 빌드된 후 마이크로서비스가 배포된 머신 이미지를 굽는다. 이 과정에서 가상 머신 이미지나 컨테이너가 생성되고 여기에 서비스가 설치된다. 가상 머신 이미지가 시작되면 서비스도 시작하고 요청받을 준비가 된다.
5. 새 환경에 공식적으로 배포되기 전에 머신 이미지는 시작되고, 모든 것이 정상적으로 수행되는지 확인하고자 이미지에 대한 일련의 플랫폼 테스트를 수행한다. 이 테스트를 통과하면 머신 이미지가 새 환경에 배포되어 사용할 수 있게 된다.
6. 새로운 환경으로 서비스가 승격되면 정확히 하위 환경에서 사용된 머신 이미지를 시작해야 한다.

CD(Continuous Delivery)를 사용하면 서버가 생성된 후 설치된 소프트웨어(운영 체제를 포함한)는 변경되지 않는다. 동일한 머신 이미지를 승격하고 사용함으로써 서버가 한 환경에서 다음 환경으로 이동할 때 서버의 불변성을 보장한다.

빌드/배포 프로세스는 네 가지 핵심 패턴을 기반으로 한다. 이 패턴들은 마이크로서비스와 클라우드 기반 애플리케이션을 구축하는 개발 팀의 집단 경험에서 태어났다.

- 지속적 통합/지속적 전달(CI/CD)
- 코드형 인프라스트럭처(Infrastructure as Code)
- 불변 서버

## 클라우드에 O-stock 핵심 인프라스트럭처 설정
AWS 서비스를 토대로 구성하고 있다. 개략적인 구성 이미지만 첨부하고 자세한 이야기는 책을 통해 살펴보자.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/60e1b241-5687-41e1-ab8d-6a0c0f8efa2b)

1. 모든 O-Stock 서비스(데이터베이스 및 레디스 클러스트 제외)는 도커 컨테이너로 배포되며, 컨테이너들은 EKS 클러스터의 단일 노드에서 실행된다. EKS는 도커 클러스터를 실행하는 데 필요한 서버를 구성하고 설정한다.
2. 아마존 클라우드에 배포하면서 도커 기반의 PostgreSQL 데이터베이스와 레디스 서버 대신에 Amazon RDS, Amazon ElastiCache 서비스를 사용한다. 도커에서 Postgres 및 레디스 데이터 저장소를 계속 실행할 수 있지만 한 인프라스트럭처에서 다른 인프라스트럭처로 옮기는 것이 얼마나 쉬운지 생각해보자.
3. 데스크톱 배포와 달리 서버의 모든 트래픽이 API 게이트웨이를 통과해야 한다. 아마존의 보안 그룹을 사용하여 배포된 EKS 클러스터의 8072 포트 번호만 외부에서 액세스할 수 있도록 허용한다.
4. 서비스를 보호하고자 여전히 스프링의 OAuth2 서버를 사용한다. 조직 및 라이선싱 서비스에서 액세스하기 전에 사용자는 인증 서비스로 인증하고 모든 서비스 호출에 유효한 OAuth2 토큰을 제시해야 한다.
5. Kafka 서버를 포함한 모든 서버의 전용 도커 포트는 외부에서 공개적으로 액세스되지 않는다. EKS 컨테이너 내부에서만 해당 포트 액세스가 가능하다.

## 빌드/배포 파이프라인 인 액션
![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/d64bb679-b648-4f75-9e83-42aad867ecfe)

- GitHub
- Jenkins
- Maven/Spotify Docker Plugin or Spring Boot Docker
- Docker
- Amazon ECR(Elastic Container Registry)
- Amazon EKS Container Service