# 4장. 아키텍처

## MySQL 엔진 아키텍처

![MySQL의 전체 구조](https://velog.velcdn.com/images/songs4805/post/9d878e36-5f24-448e-8cbb-08f638ec87b8/image.png)

![](https://velog.velcdn.com/images/songs4805/post/1e86c697-7c1b-409a-aeb9-fa4f90fa1342/image.png)

- MySQL 엔진: 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다.
- MySQL 스토리지 엔진: 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분. MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다. 테이블 마다 스토리지 엔진을 선택할 수 있으나, InnoDB가 압도적이며 기본값이다.
- 핸들러 API: MySQL 스토리지 엔진이 MySQL 엔진을 위해 열어놓은 API. 스토리지 엔진 자체.

![](https://velog.velcdn.com/images/songs4805/post/04987c3d-0b51-4aaf-822b-a6b297b3c09b/image.png)

- 포그라운드 스레드(클라이언트 스레드): 연결 요청이 왔을 때 처리를 위해 할당하는 스레드. 다른 스레드와 독립적
- 백그라운드 스레드: MyISAM은 사용자 스레드가 쓰기 스레드 역할까지 담당해서 응답시간이 늦다. InnoDB는 백그라운드 쓰기를 담당한다.
  - Insert Buffer를 병합하는 스레드
  - **로그를 디스크로 기록하는 스레드**
  - **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드**
  - 데이터를 버퍼로 읽어 오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드

> **사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다.** 그래서 일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있으며, InnoDB 또한 이런 방식으로 처리한다. 하지만 MyISAM은 그렇지 않고 사용자 쓰레드가 쓰기 작업까지 함께 처리하도록 설계되어 있다. 따라서 InnoDB는 `INSERT`, `UPDATE`, `DELETE` 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때 까지 기다리지 않아도 된다. 하지만 MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.

- 글로벌 메모리 영역: 시스템 변수에 설정된 만큼 OS로부터 할당받는 모든 스레드가 공유하는 공간. 할당 시 주의 필요. 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼.
- 로컬 메모리 영역(세션 메모리 영역): 사용자 스레드가 할당되어 요청을 처리하는 과정에서 스레드마다 독립적으로 할당되는 공간. 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼.