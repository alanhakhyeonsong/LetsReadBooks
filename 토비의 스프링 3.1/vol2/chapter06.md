# 6장. 테스트 컨텍스트 프레임워크
스프링의 POJO와 DI를 이용한 프로그래밍 모델이 가져온 가장 큰 혜택 중 하나는 바로 테스트다. POJO 프로그래밍 모델은 단위 테스트를 손쉽게 작성할 수 있는 환경을 제공해주고, 기술에 종속적이지 않은 코드를 작성하게 해준다. IoC와 DI로 인해, 서버에 배치하지 않고도 스프링 컨테이너만으로 DB까지 참여하는 이상적인 통합 테스트가 가능해진다.

## 테스트 컨텍스트 프레임워크
스프링은 테스트에 사용되는 애플리케이션 컨텍스트를 생성하고 관리하고 테스트에 적용해주는 기능을 가진 테스트 프레임워크를 제공한다. 이를 **테스트 컨텍스트 프레임워크**라고 부른다. 이는 스프링의 IoC/DI를 지원하는 애플리케이션 컨텍스트를 테스트에서 효과적으로 사용하게 해준다. 이를 사용하면, 서버에서와 거의 동일한 구성으로 동작하는 통합 테스트를 손쉽게 만들 수 있다.

### 테스트 프레임워크와 컨텍스트 테스트
> 책의 기준으론 JUnit 4를 기준으로 설명하고 있다. 스프링의 구 버전이기도 하지만, 근본적인 동작 원리를 생각하며 책을 읽고 요즘 스프링과 스프링 부트에선 어떻게 달라졌는지를 추가적으로 학습하자.

#### 테스트용 애플리케이션 컨텍스트 캐싱과 설정파일
JUnit 4에선 특정 클래스를 상속하지 않아도 테스트 코드를 작성할 수 있다. 테스트 메소드에 `@Test` 애노테이션만 붙여주면 메소드가 속한 클래스는 테스트 클래스가 되며, `@Test`가 붙은 모든 메소드가 각각 하나의 독립적인 테스트가 된다. **JUnit은 테스트 메소드를 실행할 때마다 매번 테스트 클래스의 새로운 오브젝트를 만든다. 따라서 모든 테스트는 서로 영향을 주지 않으며 독립적으로 실행됨을 보장한다.**

**문제는 테스트가 독립적이라고 해서 매번 스프링 컨텍스트, 즉 컨테이너를 새로 만드는 건 매우 비효율적인 방법이라는 점이다.** 스프링 컨텍스트는 매우 가벼운 오브젝트며 설정을 읽고 분석하는 등의 작업은 매우 빠르게 진행된다. 수백 개의 빈이 정의되어 있더라도 그 오브젝트를 만들고 의존관계를 주입하는 데는 시간이 얼마 걸리지 않는다. 반면 일부 빈 오브젝트 초기화 작업에 적지 않은 시간을 소모하기도 한다.
> Hibernate와 같은 ORM은 초기에 엔티티에 대한 정보를 가져와 세션을 지원할 준비 작업을 하고 스레드를 생성하는 등의 많은 부가 작업을 필요로 한다.

이런 초기화 작업이 테스트마다 반복되면 테스트에 많은 부담을 줄 수 있다.

**스프링은 테스트가 사용하는 컨텍스트를 캐싱해서 여러 테스트에서 하나의 컨텍스트를 공유할 수 있는 방법을 제공한다.** 동일한 컨텍스트 구성을 갖는 테스트끼리는 같은 컨텍스트를 공유하는 것이다. **테스트용 컨텍스트의 공유는 테스트 클래스 내의 메소드 사잉서만 가능한 게 아니라, 여러 테스트 클래스 사이에서도 가능하다.** 모든 테스트가 동일한 테스트용 컨텍스트 구성을 갖는다면 테스트가 수천 개라 하더라도 단 하나의 애플리케이션 컨텍스트만 만들어서 사용할 수 있다. 따라서 테스트는 매우 빠르게 실행됨이 보장된다.

<img width="681" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/8648d77e-94e2-429a-a66f-761e3ed472a4">

**테스트에 테스트 컨텍스트 프레임워크를 적용하려면 테스트 클래스에 두 가지 애노테이션을 부여해줘야 한다.**

- `@RunWith` 애노테이션을 이용해 JUnit 테스트를 실행하는 러너를 스프링이 제공하는 것으로 변경해준다. 이는 JUnit의 확장 포인트를 이용한 방법이다.
- 컨텍스트의 설정 파일을 지정한다. 같은 테스트 클래스 안의 테스트 메소드들은 하나의 설정 파일로 만들어지는 애플리케이션 컨텍스트를 공유한다.

테스트 클래스 사이에선 동일한 설정 파일을 가진 테스트끼리 애플리케이션 컨텍스트를 공유한다. 만약 `Test1` 클래스부터 `Test10` 클래스까지 모든 클래스가 동일한 컨텍스트를 공유하려면, 애노테이션을 이용해 지정해주는 설정파일을 일치시켜야 한다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("/test-applicationContext")
public class Test1 {

    @Test
    public void testMethod1() { ... }

    @Test
    public void testMethod2() { ... }
}
```

`Test1` 테스트를 실행하면 테스트 메소드의 개수만큼 `Test1` 클래스의 오브젝트가 반복적으로 만드러진다. 하지만 `/test-applicationContext.xml`을 설정파일로 하는 애플리케이션 컨텍스트는 단 한 개만 만들어진다.

새로운 테스트 클래스를 추가했다 하더라도 `@ContextConfiguration`을 통해 지정한 설정 파일이 동일하다면 `Test1`에서 만들어진 테스트용 컨텍스트를 공유한다. 따라서 새로운 애플리케이션 컨텍스트가 만들어지지 않는다.

`@ContextConfiguration`엔 여러 개의 XML 설정 파일을 지정할 수도 있다. 여러 개의 설정 파일을 지정한 경우에는 설정 파일의 구성이 동일한 테스트끼리만 테스트 컨텍스트를 공유한다.

`@ContextConfiguration`에 설정파일 이름을 생략하면 어떻게 될까? 이땐 현재 클래스 이름에 `-context.xml`이 붙은 파일이 디폴트 설정 파일 이름으로 사용된다. 아래의 테스트 클래스의 패키지가 `me.ramos.myproject.text`라면 이 테스트에 적용되는 테스트 컨텍스트는 이름이 `/me/ramos/myproject/test/Test4-context.xml`인 설정파일을 가진 것으로 간주된다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
public class Test4 { ... }
```

위와 같이 디폴트 설정파일 이름을 사용하는 것은 일반적으론 좋은 방법은 아니다. 테스트 클래스마다 독립적인 설정파일이 적용되며 그에 따라 새로운 애플리케이션 컨텍스트가 만들어지기 때문이다. 하지만 간단한 학습 테스트나 몇 개의 빈만을 조합해서 별도로 컨텍스트를 구성하고 싶을 때는 디폴트 이름을 사용하는 방법이 유용하다.

**설정 파일 위치는 클래스패스로 지정한다.** 클래스패스 루트로부터의 경로를 지정할 때는 `/`로 시작하면 된다. 현재 테스트 클래스와 같은 클래스패스의 파일을 지정하고 싶다면 `/`를 생략하고 파일 이름을 바로 적으면 된다.

#### 컨텍스트 설정의 상속과 컨텍스트 로더
**JUnit 4의 장점은 테스트 클래스가 특정 클래스를 상속하도록 강제하지 않는다는 것이다. 따라서 클래스를 구성할 때 필요하면 상속구조를 활용할 수도 있다.** 슈퍼클래스와 서브클래스에서 모두 `@ContextConfiguration`을 이용해 컨텍스트 파일을 지정했다면 어떻게 될까? 컨텍스트 파일 정보는 상속된다. 따라서 서브클래스의 컨텍스트 파일 정보는 슈퍼클래스에서 정의된 것까지 포함된다.

```java
@ContextConfiguration("common-context.xml")
public class SuperTest { ... }

@ContextConfiguration("sub-context.xml")
public class SubTest extends SuperTest { ... }
```

`SubTest`의 설정 파일은 최종적으로 두 개가 된다. 슈퍼클래스의 컨텍스트 파일 설정을 무시하고 새롭게 정의하고 싶다면 `@ContextConfiguration`의 `inheritLocations`를 `false`로 바꿔주면 된다. `@ContextConfiguration`을 이용하면 테스트 컨텍스트를 로딩하는 방식도 변경할 수 있다. 기본적으론 `GenericXmlContextLoader`를 이용해 XML 파일을 읽어 테스트 컨텍스트를 만드는 방법이 적용되어 있다. 다른 방식으로 테스트 컨텍스트를 설정하려면 `ContextLoader` 인터페이스를 구현한 클래스를 만들고 이를 `@ContextConfiguration`의 `loader` 엘리먼트에 지정해주면 된다.

### 테스트 코드의 테스트 컨텍스트 활용
**테스트 컨텍스트 프레임워크의 '컨텍스트'는 애플리케이션 컨텍스트가 아니다.** 테스트에서 사용되는 애플리케이션 컨텍스트를 생성하고 관리해주는 오브젝트를 가리키는 용어다. 하지만 테스트가 사용하는 애플리케이션 컨텍스트도 간단히 테스트 컨텍스트라고도 한다.

#### 테스트 컨텍스트로부터 DI 받기
**테스트 클래스는 테스트 컨텍스트로부터 애플리케이션 컨텍스트와 그에 담긴 빈을 제공 받아 테스트 코드에서 사용한다.** 애플리케이션 컨텍스트를 제공받는 방법은 스프링답게 DI를 사용한다. 마치 `@Configurable`이 적용된 도메인 오브젝트처럼, 테스트 클래스도 그 자체로는 빈은 아니지만 `@Autowired`, `@Resource` 등을 사용해 애플리케이션 컨텍스트의 빈 DI를 받을 수 있다.

일반 빈 클래스에서 애플리케이션 컨텍스트를 직접 DI 받을 땐 `@Autowired`를 사용해 `ApplicationContext` 타입의 빈을 가져오게 했다. 스프링이 컨텍스트를 초기화할 때 자기 자신을 `ApplicationContext` 타입의 빈으로 등록해줬기 때문이다. 마찬가지로 테스트 클래스에서도 다음 선언으로 테스트 클래스에 할당된 테스트용 애플리케이션 컨텍스트를 전달받을 수 있다. 그 외에도 모든 컨텍스트 내의 원하는 빈 역시 제공받을 수 있다. `@Autowired`, `@Resource`를 필드, 메소드, setter 등에 적용해서 DI 받아 테스트에서 사용할 수 있다.

```java
@ContextConfiguration(...)
public class Test1 {

    @Autowired Bean bean;

    @Resource Bean myBean;

    Bean bean1;
    Bean bean2;

    @Autowired
    public void setBean(Bean bean) {  this.bean1 = bean; }

    @Autowired
    public void init(Bean bean) { this.bean2 = bean; }

    //...
}
```

테스트 클래스에서 사용할 수 있는 DI용 애노테이션은 `@Qualifier`, `@Inject`, `@Named`, `@Provider`, `@Required` 등이 있다. JPA를 사용하는 경우라면 `@PersistenceContext`, `@PersistenceUnit`도 사용 가능하다.

테스트 클래스의 오브젝트는 테스트 메소드마다 새로 만들어지므로 DI 작업도 매번 일어난다. 따라서 클래스 내의 모든 테스트 메소드에서 공통적으로 필요한 빈 위주로 DI 설정을 해두면 좋다. 특정 테스트 메소드에서만 많은 빈을 가져다 사용해야 한다면, 필드 레벨에 정의해두는 것보다는 `ApplicationContext`를 DI 받은 후에 메소드에서 직접 `getBean()`을 이용해 가져오는 방법도 고려해보자.

#### 공유 컨텍스트 사용 시 주의할 점
캐싱 기법을 통한 컨텍스트 공유의 장점도 있지만 단점도 있다. **컨텍스트를 공유하는 테스트 메소드는 컨텍스트가 자신이 독점하는 것이 아니므로 그 구성이나 내부 정보를 함부로 변경해서는 안된다.** 가능하면 어떤 변경도 못하게 하는 것이 좋다. 혹시 특정 작업을 시작했다면 반드시 원 상태로 복귀하고 테스트를 마치게 해야 한다.

**테스트는 그 실행 순서와 환경에 영향을 받지 않아야 한다.** (테스트의 FIRST 원칙을 생각해보자.) **테스트 픽스처는 물론이고 테스트 오브젝트도 매번 새로운 오브젝트를 만들어 사용하도록 권장되고, JUnit은 이 방식을 따르고 있기 때문에 매우 안전한 테스트 결과를 얻을 수 있다.**

문제는 컨텍스트를 테스트마다 만들면 성능과 효율 면에서 너무 큰 부담이라 이를 공유하는 방식을 사용한다는 점이다. 따라서 공유하는 컨텍스트는 매우 조심해서 다뤄야 한다. 컨텍스트 내의 빈 오브젝트는 아니지만 외부 리소스를 변경하는 경우도 역시 주의해야 한다. 컨텍스트 내의 빈을 테스트하는 중에 특정 파일을 생성하는 기능을 테스트했다면 테스트가 끝난 후에 파일을 제거해주는 것이 좋다. DB를 사용하는 테스트도 이후 진행되는 테스트의 결과에 영향을 주지 않도록 만들어야 한다. 또는 테스트 스스로가 자신이 테스트하는 데 필요한 DB나 리소스, 빈의 상태를 초기화하는 작업을 직접 수행하게 할 수도 있다.

어쩔 수 없이 컨텍스트의 빈 오브젝트를 조작하고 수정하는 작업이 꼭 필요한 테스트가 있을 수도 있다. 일부러 예외적인 상황을 만들거나 설정파일의 DI 구조를 강제로 바꿔가면서 테스트할 때도 있기 때문이다. 이런 경우엔 테스트 메소드에 `@DirtiesContext` 애노테이션을 붙여주면 된다.

```java
@Test
@DirtiesContext
public void test1() { ... }
```

**이 애노테이션이 붙은 테스트가 수행되고 나면 스프링은 현 테스트 컨텍스트를 강제로 제거한다.** 테스트를 통해 더럽혀진 컨텍스트이므로 더 이상 공유하지 못하도록 만드는 것이다. 이후 설정 파일이 같은 컨텍스트를 사용하는 테스트가 진행된다면, 이때는 새로운 컨텍스트가 만들어진다. 따라서 다른 테스트엔 영향을 주지 않고 안전하게 컨텍스트를 조작하는 테스트를 만들 수 있다.

또한 `@DirtiesContext`는 클래스 레벨에 부여할 수도 있다. 이 경우는 기본적으로 테스트 내의 모든 메소드의 테스트가 끝난 후에 컨텍스트가 제거된다. `@DirtiesContext`의 `classMode` 엘리먼트를 `ClassMode.AFTER_EACH_TEST_METHOD`로 바꿔주면 모든 테스트 메소드에 `@DirtiesContext`를 적용한 것처럼 동작한다.

## 트랜잭션 지원 테스트
### 테스트의 트랜잭션 지원 필요성
스프링 테스트 컨텍스트 프레임워크로 DB를 사용하는 기능을 테스트하는 것은 간단하다. 테스트용 설정파일에 테스트에 사용할 DB를 지정한 `DataSource`를 등록해주는 정도면 준비는 충분하다. DAO가 사용되는 기능을 호출해서 실행하기만 하면 된다. 트랜잭션 경계로 설정해둔 서비스 계층의 빈 오브젝트를 가져와 실행하면 트랜잭션까지 깔끔하게 적영돼서 테스트가 진행될 것이다.

**하지만 DB가 사용되는 테스트에선 단순히 컨텍스트에 구성된 빈의 메소드를 호출하는 것으로는 충분하지 않다. 테스트에서 트랜잭션을 조작하거나 지원하는 기능이 필요한 경우가 있기 때문이다.**

#### DAO 단독 테스트
**스프링의 데이터 액세스 기술로 만든 DAO는 기본적으로 트랜잭션 동기화가 필요하다.** 따라서 트랜잭션을 시작해주는 AOP가 있는 서비스 계층을 통해 접근하지 않으면 DAO 실행이 안 되는 문제가 발생한다.

JDBC의 경우엔 `JdbcTemplate`을 사용했다면 시작된 트랜잭션이 없으면 직접 트랜잭션을 시작해주기에 문제가 안 된다. DAO 메소드 단위로 트랜잭션이 시작되고 종료돼도 상관없다면 이 방법으로 충분하다.

문제는 JPA나 Hibernate 등으로 만든 DAO는 트랜잭션이 시작되지 않은 채로 엔티티 매니저나 세션을 사용하면 예외가 발생한다는 점이다.

```java
@Autowired
JpaDao dao;

@Test
public void query() {
    List<User> users = dao.findUsers();
}
```

`jpaDao`는 JPA로 만든 DAO 코드인데, 트랜잭션이 적용된 서비스 계층으로부터 시작해서 호출된다면 아무런 문제가 없다. 하지만 다음과 같이 테스트에서 직접 DAO의 메소드를 호출하면 `javax.persistence.TransactionRequiredException` 예외가 발생한다. 미리 시작된 트랜잭션이 없다는 예외이다.

DAO 테스트를 작성하는 일은 쉽지 않다. 트랜잭션을 자동으로 시작해주는 JDBC DAO의 경우에도 두 개 이상의 DAO 메소드의 작업을 하나의 트랜잭션으로 묶는 테스트는 작성할 수 없다. 그렇다고 DAO 단독 테스트를 하기 위해 서비스 계층을 매번 이용하거나 트랜잭션이 적용된 테스트용 서비스 계층 코드를 만드는 것도 매우 번거롭다. 따라서 DAO를 직접 손쉽게 테스트할 수 있는 방법이 필요하다.

#### 롤백 테스트
두 번째 문제는 테스트 DB다. **DB가 참여하는 테스트의 가장 큰 어려움은 테스트용 DB를 어떻게 구축하고 이를 관리하는가에 있다.** 테스트에서 단지 조회만 한다면 DB의 초기 데이터만 잘 준비해두면 되겠지만, 테스트 과정에서 DB의 내용을 수정하는 경우에는 문제가 복잡해진다. 테스트는 어떤 순서로 실행되든 그 결과가 항상 일정해야 하고 외부 리소스나 환경에 영향을 받지 않아야 한다는 원칙은 DB가 참여하는 테스트에도 적용된다. 그렇다고 해서 테스트마다 DB를 초기화하는 작업을 반복하면 매우 부담스럽다.

스프링 컨텍스트를 공유해서 테스트할 때는 컨텍스트를 처음 상태로 계속 유지해야 하는 것처럼, DB가 참여하는 테스트도 계속 초기 테스트 데이터가 유지되도록 만들 방법을 찾아야 한다. 한 가지 방법은 테스트에서 진행되는 모든 DB 작업을 하나의 트랜잭션으로 묶어 진행하고, 테스트를 마칠 때 트랜잭션을 모두 롤백시키는 것이다. 이를 **롤백 테스트**라고 부른다.

이런 테스트는 서로 영향을 주지 않은 채로 독립적으로 실행할 수 있다. 어차피 롤백될 것이므로 테스트 내에선 어떤 식으로든 DB를 조작해도 상관없다. 아예 DB 테이블의 데이터를 모두 삭제하고 새로운 테스트 데이터를 넣어도 된다.

### 트랜잭션 지원 테스트 작성 방법