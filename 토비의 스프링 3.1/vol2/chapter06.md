# 6장. 테스트 컨텍스트 프레임워크
스프링의 POJO와 DI를 이용한 프로그래밍 모델이 가져온 가장 큰 혜택 중 하나는 바로 테스트다. POJO 프로그래밍 모델은 단위 테스트를 손쉽게 작성할 수 있는 환경을 제공해주고, 기술에 종속적이지 않은 코드를 작성하게 해준다. IoC와 DI로 인해, 서버에 배치하지 않고도 스프링 컨테이너만으로 DB까지 참여하는 이상적인 통합 테스트가 가능해진다.

## 테스트 컨텍스트 프레임워크
스프링은 테스트에 사용되는 애플리케이션 컨텍스트를 생성하고 관리하고 테스트에 적용해주는 기능을 가진 테스트 프레임워크를 제공한다. 이를 **테스트 컨텍스트 프레임워크**라고 부른다. 이는 스프링의 IoC/DI를 지원하는 애플리케이션 컨텍스트를 테스트에서 효과적으로 사용하게 해준다. 이를 사용하면, 서버에서와 거의 동일한 구성으로 동작하는 통합 테스트를 손쉽게 만들 수 있다.

### 테스트 프레임워크와 컨텍스트 테스트
> 책의 기준으론 JUnit 4를 기준으로 설명하고 있다. 스프링의 구 버전이기도 하지만, 근본적인 동작 원리를 생각하며 책을 읽고 요즘 스프링과 스프링 부트에선 어떻게 달라졌는지를 추가적으로 학습하자.

#### 테스트용 애플리케이션 컨텍스트 캐싱과 설정파일
JUnit 4에선 특정 클래스를 상속하지 않아도 테스트 코드를 작성할 수 있다. 테스트 메소드에 `@Test` 애노테이션만 붙여주면 메소드가 속한 클래스는 테스트 클래스가 되며, `@Test`가 붙은 모든 메소드가 각각 하나의 독립적인 테스트가 된다. **JUnit은 테스트 메소드를 실행할 때마다 매번 테스트 클래스의 새로운 오브젝트를 만든다. 따라서 모든 테스트는 서로 영향을 주지 않으며 독립적으로 실행됨을 보장한다.**

**문제는 테스트가 독립적이라고 해서 매번 스프링 컨텍스트, 즉 컨테이너를 새로 만드는 건 매우 비효율적인 방법이라는 점이다.** 스프링 컨텍스트는 매우 가벼운 오브젝트며 설정을 읽고 분석하는 등의 작업은 매우 빠르게 진행된다. 수백 개의 빈이 정의되어 있더라도 그 오브젝트를 만들고 의존관계를 주입하는 데는 시간이 얼마 걸리지 않는다. 반면 일부 빈 오브젝트 초기화 작업에 적지 않은 시간을 소모하기도 한다.
> Hibernate와 같은 ORM은 초기에 엔티티에 대한 정보를 가져와 세션을 지원할 준비 작업을 하고 스레드를 생성하는 등의 많은 부가 작업을 필요로 한다.

이런 초기화 작업이 테스트마다 반복되면 테스트에 많은 부담을 줄 수 있다.

**스프링은 테스트가 사용하는 컨텍스트를 캐싱해서 여러 테스트에서 하나의 컨텍스트를 공유할 수 있는 방법을 제공한다.** 동일한 컨텍스트 구성을 갖는 테스트끼리는 같은 컨텍스트를 공유하는 것이다. **테스트용 컨텍스트의 공유는 테스트 클래스 내의 메소드 사잉서만 가능한 게 아니라, 여러 테스트 클래스 사이에서도 가능하다.** 모든 테스트가 동일한 테스트용 컨텍스트 구성을 갖는다면 테스트가 수천 개라 하더라도 단 하나의 애플리케이션 컨텍스트만 만들어서 사용할 수 있다. 따라서 테스트는 매우 빠르게 실행됨이 보장된다.

<img width="681" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/8648d77e-94e2-429a-a66f-761e3ed472a4">

**테스트에 테스트 컨텍스트 프레임워크를 적용하려면 테스트 클래스에 두 가지 애노테이션을 부여해줘야 한다.**

- `@RunWith` 애노테이션을 이용해 JUnit 테스트를 실행하는 러너를 스프링이 제공하는 것으로 변경해준다. 이는 JUnit의 확장 포인트를 이용한 방법이다.
- 컨텍스트의 설정 파일을 지정한다. 같은 테스트 클래스 안의 테스트 메소드들은 하나의 설정 파일로 만들어지는 애플리케이션 컨텍스트를 공유한다.

테스트 클래스 사이에선 동일한 설정 파일을 가진 테스트끼리 애플리케이션 컨텍스트를 공유한다. 만약 `Test1` 클래스부터 `Test10` 클래스까지 모든 클래스가 동일한 컨텍스트를 공유하려면, 애노테이션을 이용해 지정해주는 설정파일을 일치시켜야 한다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("/test-applicationContext")
public class Test1 {

    @Test
    public void testMethod1() { ... }

    @Test
    public void testMethod2() { ... }
}
```

`Test1` 테스트를 실행하면 테스트 메소드의 개수만큼 `Test1` 클래스의 오브젝트가 반복적으로 만드러진다. 하지만 `/test-applicationContext.xml`을 설정파일로 하는 애플리케이션 컨텍스트는 단 한 개만 만들어진다.

새로운 테스트 클래스를 추가했다 하더라도 `@ContextConfiguration`을 통해 지정한 설정 파일이 동일하다면 `Test1`에서 만들어진 테스트용 컨텍스트를 공유한다. 따라서 새로운 애플리케이션 컨텍스트가 만들어지지 않는다.

`@ContextConfiguration`엔 여러 개의 XML 설정 파일을 지정할 수도 있다. 여러 개의 설정 파일을 지정한 경우에는 설정 파일의 구성이 동일한 테스트끼리만 테스트 컨텍스트를 공유한다.

`@ContextConfiguration`에 설정파일 이름을 생략하면 어떻게 될까? 이땐 현재 클래스 이름에 `-context.xml`이 붙은 파일이 디폴트 설정 파일 이름으로 사용된다. 아래의 테스트 클래스의 패키지가 `me.ramos.myproject.text`라면 이 테스트에 적용되는 테스트 컨텍스트는 이름이 `/me/ramos/myproject/test/Test4-context.xml`인 설정파일을 가진 것으로 간주된다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
public class Test4 { ... }
```

위와 같이 디폴트 설정파일 이름을 사용하는 것은 일반적으론 좋은 방법은 아니다. 테스트 클래스마다 독립적인 설정파일이 적용되며 그에 따라 새로운 애플리케이션 컨텍스트가 만들어지기 때문이다. 하지만 간단한 학습 테스트나 몇 개의 빈만을 조합해서 별도로 컨텍스트를 구성하고 싶을 때는 디폴트 이름을 사용하는 방법이 유용하다.

**설정 파일 위치는 클래스패스로 지정한다.** 클래스패스 루트로부터의 경로를 지정할 때는 `/`로 시작하면 된다. 현재 테스트 클래스와 같은 클래스패스의 파일을 지정하고 싶다면 `/`를 생략하고 파일 이름을 바로 적으면 된다.

#### 컨텍스트 설정의 상속과 컨텍스트 로더
**JUnit 4의 장점은 테스트 클래스가 특정 클래스를 상속하도록 강제하지 않는다는 것이다. 따라서 클래스를 구성할 때 필요하면 상속구조를 활용할 수도 있다.** 슈퍼클래스와 서브클래스에서 모두 `@ContextConfiguration`을 이용해 컨텍스트 파일을 지정했다면 어떻게 될까? 컨텍스트 파일 정보는 상속된다. 따라서 서브클래스의 컨텍스트 파일 정보는 슈퍼클래스에서 정의된 것까지 포함된다.

```java
@ContextConfiguration("common-context.xml")
public class SuperTest { ... }

@ContextConfiguration("sub-context.xml")
public class SubTest extends SuperTest { ... }
```

`SubTest`의 설정 파일은 최종적으로 두 개가 된다. 슈퍼클래스의 컨텍스트 파일 설정을 무시하고 새롭게 정의하고 싶다면 `@ContextConfiguration`의 `inheritLocations`를 `false`로 바꿔주면 된다. `@ContextConfiguration`을 이용하면 테스트 컨텍스트를 로딩하는 방식도 변경할 수 있다. 기본적으론 `GenericXmlContextLoader`를 이용해 XML 파일을 읽어 테스트 컨텍스트를 만드는 방법이 적용되어 있다. 다른 방식으로 테스트 컨텍스트를 설정하려면 `ContextLoader` 인터페이스를 구현한 클래스를 만들고 이를 `@ContextConfiguration`의 `loader` 엘리먼트에 지정해주면 된다.

### 테스트 코드의 테스트 컨텍스트 활용
**테스트 컨텍스트 프레임워크의 '컨텍스트'는 애플리케이션 컨텍스트가 아니다.** 테스트에서 사용되는 애플리케이션 컨텍스트를 생성하고 관리해주는 오브젝트를 가리키는 용어다. 하지만 테스트가 사용하는 애플리케이션 컨텍스트도 간단히 테스트 컨텍스트라고도 한다.

#### 테스트 컨텍스트로부터 DI 받기
**테스트 클래스는 테스트 컨텍스트로부터 애플리케이션 컨텍스트와 그에 담긴 빈을 제공 받아 테스트 코드에서 사용한다.** 애플리케이션 컨텍스트를 제공받는 방법은 스프링답게 DI를 사용한다. 마치 `@Configurable`이 적용된 도메인 오브젝트처럼, 테스트 클래스도 그 자체로는 빈은 아니지만 `@Autowired`, `@Resource` 등을 사용해 애플리케이션 컨텍스트의 빈 DI를 받을 수 있다.

일반 빈 클래스에서 애플리케이션 컨텍스트를 직접 DI 받을 땐 `@Autowired`를 사용해 `ApplicationContext` 타입의 빈을 가져오게 했다. 스프링이 컨텍스트를 초기화할 때 자기 자신을 `ApplicationContext` 타입의 빈으로 등록해줬기 때문이다. 마찬가지로 테스트 클래스에서도 다음 선언으로 테스트 클래스에 할당된 테스트용 애플리케이션 컨텍스트를 전달받을 수 있다. 그 외에도 모든 컨텍스트 내의 원하는 빈 역시 제공받을 수 있다. `@Autowired`, `@Resource`를 필드, 메소드, setter 등에 적용해서 DI 받아 테스트에서 사용할 수 있다.

```java
@ContextConfiguration(...)
public class Test1 {

    @Autowired Bean bean;

    @Resource Bean myBean;

    Bean bean1;
    Bean bean2;

    @Autowired
    public void setBean(Bean bean) {  this.bean1 = bean; }

    @Autowired
    public void init(Bean bean) { this.bean2 = bean; }

    //...
}
```

테스트 클래스에서 사용할 수 있는 DI용 애노테이션은 `@Qualifier`, `@Inject`, `@Named`, `@Provider`, `@Required` 등이 있다. JPA를 사용하는 경우라면 `@PersistenceContext`, `@PersistenceUnit`도 사용 가능하다.

테스트 클래스의 오브젝트는 테스트 메소드마다 새로 만들어지므로 DI 작업도 매번 일어난다. 따라서 클래스 내의 모든 테스트 메소드에서 공통적으로 필요한 빈 위주로 DI 설정을 해두면 좋다. 특정 테스트 메소드에서만 많은 빈을 가져다 사용해야 한다면, 필드 레벨에 정의해두는 것보다는 `ApplicationContext`를 DI 받은 후에 메소드에서 직접 `getBean()`을 이용해 가져오는 방법도 고려해보자.

#### 공유 컨텍스트 사용 시 주의할 점
캐싱 기법을 통한 컨텍스트 공유의 장점도 있지만 단점도 있다. **컨텍스트를 공유하는 테스트 메소드는 컨텍스트가 자신이 독점하는 것이 아니므로 그 구성이나 내부 정보를 함부로 변경해서는 안된다.** 가능하면 어떤 변경도 못하게 하는 것이 좋다. 혹시 특정 작업을 시작했다면 반드시 원 상태로 복귀하고 테스트를 마치게 해야 한다.

**테스트는 그 실행 순서와 환경에 영향을 받지 않아야 한다.** (테스트의 FIRST 원칙을 생각해보자.) **테스트 픽스처는 물론이고 테스트 오브젝트도 매번 새로운 오브젝트를 만들어 사용하도록 권장되고, JUnit은 이 방식을 따르고 있기 때문에 매우 안전한 테스트 결과를 얻을 수 있다.**

문제는 컨텍스트를 테스트마다 만들면 성능과 효율 면에서 너무 큰 부담이라 이를 공유하는 방식을 사용한다는 점이다. 따라서 공유하는 컨텍스트는 매우 조심해서 다뤄야 한다. 컨텍스트 내의 빈 오브젝트는 아니지만 외부 리소스를 변경하는 경우도 역시 주의해야 한다. 컨텍스트 내의 빈을 테스트하는 중에 특정 파일을 생성하는 기능을 테스트했다면 테스트가 끝난 후에 파일을 제거해주는 것이 좋다. DB를 사용하는 테스트도 이후 진행되는 테스트의 결과에 영향을 주지 않도록 만들어야 한다. 또는 테스트 스스로가 자신이 테스트하는 데 필요한 DB나 리소스, 빈의 상태를 초기화하는 작업을 직접 수행하게 할 수도 있다.

어쩔 수 없이 컨텍스트의 빈 오브젝트를 조작하고 수정하는 작업이 꼭 필요한 테스트가 있을 수도 있다. 일부러 예외적인 상황을 만들거나 설정파일의 DI 구조를 강제로 바꿔가면서 테스트할 때도 있기 때문이다. 이런 경우엔 테스트 메소드에 `@DirtiesContext` 애노테이션을 붙여주면 된다.

```java
@Test
@DirtiesContext
public void test1() { ... }
```

**이 애노테이션이 붙은 테스트가 수행되고 나면 스프링은 현 테스트 컨텍스트를 강제로 제거한다.** 테스트를 통해 더럽혀진 컨텍스트이므로 더 이상 공유하지 못하도록 만드는 것이다. 이후 설정 파일이 같은 컨텍스트를 사용하는 테스트가 진행된다면, 이때는 새로운 컨텍스트가 만들어진다. 따라서 다른 테스트엔 영향을 주지 않고 안전하게 컨텍스트를 조작하는 테스트를 만들 수 있다.

또한 `@DirtiesContext`는 클래스 레벨에 부여할 수도 있다. 이 경우는 기본적으로 테스트 내의 모든 메소드의 테스트가 끝난 후에 컨텍스트가 제거된다. `@DirtiesContext`의 `classMode` 엘리먼트를 `ClassMode.AFTER_EACH_TEST_METHOD`로 바꿔주면 모든 테스트 메소드에 `@DirtiesContext`를 적용한 것처럼 동작한다.

## 트랜잭션 지원 테스트
### 테스트의 트랜잭션 지원 필요성
스프링 테스트 컨텍스트 프레임워크로 DB를 사용하는 기능을 테스트하는 것은 간단하다. 테스트용 설정파일에 테스트에 사용할 DB를 지정한 `DataSource`를 등록해주는 정도면 준비는 충분하다. DAO가 사용되는 기능을 호출해서 실행하기만 하면 된다. 트랜잭션 경계로 설정해둔 서비스 계층의 빈 오브젝트를 가져와 실행하면 트랜잭션까지 깔끔하게 적영돼서 테스트가 진행될 것이다.

**하지만 DB가 사용되는 테스트에선 단순히 컨텍스트에 구성된 빈의 메소드를 호출하는 것으로는 충분하지 않다. 테스트에서 트랜잭션을 조작하거나 지원하는 기능이 필요한 경우가 있기 때문이다.**

#### DAO 단독 테스트
**스프링의 데이터 액세스 기술로 만든 DAO는 기본적으로 트랜잭션 동기화가 필요하다.** 따라서 트랜잭션을 시작해주는 AOP가 있는 서비스 계층을 통해 접근하지 않으면 DAO 실행이 안 되는 문제가 발생한다.

JDBC의 경우엔 `JdbcTemplate`을 사용했다면 시작된 트랜잭션이 없으면 직접 트랜잭션을 시작해주기에 문제가 안 된다. DAO 메소드 단위로 트랜잭션이 시작되고 종료돼도 상관없다면 이 방법으로 충분하다.

문제는 JPA나 Hibernate 등으로 만든 DAO는 트랜잭션이 시작되지 않은 채로 엔티티 매니저나 세션을 사용하면 예외가 발생한다는 점이다.

```java
@Autowired
JpaDao dao;

@Test
public void query() {
    List<User> users = dao.findUsers();
}
```

`jpaDao`는 JPA로 만든 DAO 코드인데, 트랜잭션이 적용된 서비스 계층으로부터 시작해서 호출된다면 아무런 문제가 없다. 하지만 다음과 같이 테스트에서 직접 DAO의 메소드를 호출하면 `javax.persistence.TransactionRequiredException` 예외가 발생한다. 미리 시작된 트랜잭션이 없다는 예외이다.

DAO 테스트를 작성하는 일은 쉽지 않다. 트랜잭션을 자동으로 시작해주는 JDBC DAO의 경우에도 두 개 이상의 DAO 메소드의 작업을 하나의 트랜잭션으로 묶는 테스트는 작성할 수 없다. 그렇다고 DAO 단독 테스트를 하기 위해 서비스 계층을 매번 이용하거나 트랜잭션이 적용된 테스트용 서비스 계층 코드를 만드는 것도 매우 번거롭다. 따라서 DAO를 직접 손쉽게 테스트할 수 있는 방법이 필요하다.

#### 롤백 테스트
두 번째 문제는 테스트 DB다. **DB가 참여하는 테스트의 가장 큰 어려움은 테스트용 DB를 어떻게 구축하고 이를 관리하는가에 있다.** 테스트에서 단지 조회만 한다면 DB의 초기 데이터만 잘 준비해두면 되겠지만, 테스트 과정에서 DB의 내용을 수정하는 경우에는 문제가 복잡해진다. 테스트는 어떤 순서로 실행되든 그 결과가 항상 일정해야 하고 외부 리소스나 환경에 영향을 받지 않아야 한다는 원칙은 DB가 참여하는 테스트에도 적용된다. 그렇다고 해서 테스트마다 DB를 초기화하는 작업을 반복하면 매우 부담스럽다.

스프링 컨텍스트를 공유해서 테스트할 때는 컨텍스트를 처음 상태로 계속 유지해야 하는 것처럼, DB가 참여하는 테스트도 계속 초기 테스트 데이터가 유지되도록 만들 방법을 찾아야 한다. 한 가지 방법은 테스트에서 진행되는 모든 DB 작업을 하나의 트랜잭션으로 묶어 진행하고, 테스트를 마칠 때 트랜잭션을 모두 롤백시키는 것이다. 이를 **롤백 테스트**라고 부른다.

이런 테스트는 서로 영향을 주지 않은 채로 독립적으로 실행할 수 있다. 어차피 롤백될 것이므로 테스트 내에선 어떤 식으로든 DB를 조작해도 상관없다. 아예 DB 테이블의 데이터를 모두 삭제하고 새로운 테스트 데이터를 넣어도 된다.

### 트랜잭션 지원 테스트 작성 방법
#### 트랜잭션 매니저
**스프링의 모든 트랜잭션은 트랜잭션 매니저를 이용해 만들어지고 관리된다. 따라서 트랜잭션 매니저를 이용할 수 있으면 트랜잭션도 제어할 수 있다.** 어떤 데이터 액세스 기술을 사용했든 상관없이 `PlatformTransactionManager` 타입의 트랜잭션 매니저 빈이 등록되어 있을 것이다. 먼저 트랜잭션 매니저 빈을 다음과 같이 테스트 클래스에서 DI 받는다.

```java
@Autowired
PlatformTransactionManager transactionManager;
```

테스트에선 `TransactionTemplate`과 `TransactionCallback`을 이용해 트랜잭션 경계를 설정한 후에 DB를 사용하는 빈을 호출해 테스트를 진행한다.

```java
@Autowired
JpaDao dao;

@Test
public void txTest() {
    new TransactionTemplate(transactionManager).execute(
        new TransactionCallback<Object>() {
            public Object doInTransaction(TransactionStatus status) {
                status.setRollbackOnly(); // 예외가 발생하지 않아도 트랜잭션 종료 시 트랜잭션이 롤백되도록 설정

                // execute()에 의해 시작된 트랜잭션 안에서 모든 DB 작업이 진행된다.
                dao.deleteAll();
                dao.add(new Member(10, "Spring", 7.8));
                assertThat(dao.count(), is(1));

                return null;
            }
        }
    );
}
```

트랜잭션 매니저를 이용해 트랜잭션 템플릿을 만들고, `execute()`를 실행해 같은 트랜잭션 안에서 동작해야 하는 코드를 콜백에 담아 전달한다. 트랜잭션이 시작한 후에 DAO 코드가 실행되기 때문에 JPA DAO는 아무런 문제 없이 동작한다.

`TransactionStatus` 오브젝트의 `setRollbackOnly()`에 주목하자. 이 메소드를 실행하면 해당 트랜잭션은 무조건 롤백된다. 트랜잭션 작업을 강제로 롤백하게 해서 롤백 테스트를 만드는 경우 유용하게 쓸 수 있다. 런타임 예외를 던져 트랜잭션을 롤백시키는 방법도 있겠지만 `setRollbackOnly()`를 사용하는 방법이 훨씬 깔끔하다. 이 테스트 메소드가 끝나고 나면 테스트에서 사용한 DAO가 수정한 DB 데이터는 모두 테스트를 실행하기 이전 상태로 복구될 것이다.

#### `@Transactional` 테스트
테스트에서 트랜잭션 매니저를 DI 받아 트랜잭션 템플릿과 함께 사용하는 방법은 테스트 코드가 지저분해진다는 단점이 있다. 템플릿/콜백 방식에서 나타나는 장황한 코드로 인해 테스트 코드를 이해하기도 조금 불편해진다.

그렇다면 테스트에선 서비스 계층처럼 AOP를 적용해 테스트에서 트랜잭션을 적용할 수는 없을까? 테스트 오브젝트에 AOP를 적용하는 건 불가능하다. 스프링 AOP의 적용 대상은 컨텍스트에 등록된 빈 오브젝트 뿐이다. 따라서 JUnit이 오브젝트를 생성하고 관리하는 테스트 클래스의 오브젝트는 AOP 적용 대상이 될 수 없다.

**하지만 스프링의 테스트 컨텍스트 프레임워크는 마치 AOP를 적용한 것과 유사한 방식으로 트랜잭션 기능을 테스트 메소드에 적용할 수 있게 해준다.** 트랜잭션을 적용하고 싶은 메소드가 있으면 다음과 같이 `@Transactional` 애노테이션을 메소드에 부여해주면 된다. 이렇게 되면 코드가 간결해지는 효과가 있다.

```java
@Test
@Transactional
publci void txTest() {
    dao.deleteAll();
    dao.add(new Member(10, "Spring", 7.8));
    assertThat(dao.count(), is(1));
}
```

`@Transactional`은 AOP에 의해 동작하는 것이 아니라고 했다. 따라서 XML 설정에 애노테이션 방식의 트랜잭션을 위한 설정을 해줄 필요는 없다. 트랜잭션 매니저는 물론 빈으로 등록되어 있어야 한다. **테스트에 `@Transactional`을 사용하면 기본적으로 `transactionManager`라는 이름의 트랜잭션 매니저 빈이 등록되어 있다고 간주하고 이를 가져와 트랜잭션 제어에 사용한다.**

`@Transactional`이 부여된 테스트 메소드에서 트랜잭션 AOP가 적용된 서비스 계층의 오브젝트 메소드를 호출하는 것도 가능하다. 이땐 테스트의 `@Transactional`에 의해 시작된 트랜잭션에 서비스 계층의 트랜잭션이 참여하게 된다. 트랜잭션 전파 방식의 적용을 받기 때문이다. 이를 이용해서 서비스 계층의 트랜잭션 속성과 다른 속성을 테스트의 이 애노테이션에 적용해놓고 서비스 계층을 호출하는 테스트도 만들 수 있다. 이를 잘 이용하면 트랜잭션 전파 방식을 따라 다른 트랜잭션 안에 참여할 때 어떻게 동작하는지 확인해보는 테스트 또한 만들 수 있다.

**테스트의 `@Transactional`은 서비스 계층의 코드에 적용된 것과 중요한 다른 점이 있다. 바로 강제롤백 옵션이 설정된 트랜잭션으로 만들어진다는 점이다.** 단지 이 애노테이션을 부여하는 것만으로 `TransactionStatus`의 `setRollbackOnly()`가 호출되는 것과 동일한 방식으로 동작한다. `@Rollback` 애노테이션을 이용해 롤백이 적용되지 않도록 만들어 줄 수도 있다. 참고로 `@Before`, `@After` 메소드 역시 트랜잭션 안에서 실행된다. 만약 트랜잭션이 시작되기 전이나 완전히 종료도니 후에 해야하는 작업이 있다면, `@BeforeTransaction`, `@AfterTransaction`이 붙은 메소드를 사용하자.

#### ORM 롤백 트랜잭션 테스트의 주의사항
Hibernate나 JPA를 사용하는 롤백 테스트를 만들 때는 주의할 점이 있다. ORM은 기본적으로 모든 작업 결과를 바로 DB에 반영하지 않는다. 가능한 한 오랫동안 메모리에 변경사항을 저장하고 있다가 꼭 필요한 시점에서 DB에 반영한다. **최적화를 위한 트랜잭션 내의 캐싱 기법**이라 볼 수 있다.

ORM의 엔티티 오브젝트를 이용한 작업을 SQL로 만들어 DB로 보내는 것을 flush라 한다. 기본적으로 ORM은 자동플러시 모드로 동작한다. 이 모드에선 트랜잭션이 커밋되거나, 캐시에 저장해둔 정보가 반영되는 `SELECT` 쿼리를 실행해야 하거나, 코드에서 `flush()`를 실행해서 강제로 플러시하도록 만들 때만 트랜잭션 내의 캐시에 저장해뒀던 ORM 작업 결과를 SQL로 만들어 DB에서 실행시킨다.

ORM의 캐시와 자동플러시 모드로 인해 다음과 같은 테스트를 작성할 위험이 발생한다.

```java
@Test
@Transactional
public void multiAdd() {
    User user = new User(...);
    hibernateDao.add(user);
    assertThat(user, is(hibernateDao.get(user.getId())));
}
```

얼핏 보면 DB에 `User` 엔티티를 하나 저장하고, 이를 다시 조회해서 비교하는 테스트로 보인다. 하지만 실제로는 DB에 아무것도 전달되지 않은 채로 테스트가 끝난다. 물론 테스트는 성공한 것으로 나온다. 엔티티에 대한 ORM 매핑 정보가 잘못됐거나 DB에 중복된 정보가 들어가 오류가 발생할 상황이라도 테스트는 성공으로 끝날 것이다.

**Hibernate 같은 ORM은 일단 엔티티를 추가하면 `INSERT` 문을 준비해서 메모리 캐시에 보관만 해둔다. DB에 `INSERT`를 실행하는 것은 최대한 뒤로 미룬다.** 그런데 여기서 기본키로 조회하는 `get()`같은 메소드를 실행하면 먼저 메모리 내의 캐시에서 엔티티를 찾는다. 캐시엔 방금 등록한 객체가 있으므로 그냥 반환한다. 문제는 이 상태에서 테스트가 끝나면 스프링은 트랜잭션을 롤백시킨다는 점이다. Hibernate는 롤백된 트랜잭션의 작업을 DB에 반영할 필요가 없으니 메모리 캐시의 엔티티 오브젝트를 제거하고 작업을 끝내버린다. 결국 한 번도 SQL이 만들어져 전달되지 않고 테스트가 종료되는 것이다. 따라서 제대로 DAO에 대한 테스트가 진행됐다 볼 수 없다.

**이럴 때는 테스트 코드 내부에서 강제로 `flush()`를 호출하는 방법을 사용해야 한다.**

```java
User user = new User(...);
hibernateDao.add(user);
SessionFactory.getCurrentSession().flush();

assertThat(user, is(hibernateDao.get(user.getId())));
```

`get()` 같은 경우는 기본키로 검색하는 것이라 `INSERT`문이 실행되서 매핑에 대한 검증이 됐다면 다른 문제는 없다고 불 수 있긴 하지만, 그래도 `get()`에 의해 `SELECT` 쿼리가 실행되게 하고 싶다면 내부 캐시를 강제로 비우도록 `clear()` 메소드를 호출해줄 수 있다.

```java
SessionFactory.getCurrentSession().clear();
```

DAO를 직접 테스트하지 않고 서비스 계층 오브젝트를 거치는 경우에도 이런 문제점을 염두에 둬야 한다. ORM에선 테스트에서 의도적으로라도 한 번은 `flush()`를 실행하는 것이 좋다.

## 스프링 3.1의 컨텍스트 테스트 프레임워크
### 자바 코드 설정정보와 프로파일 활용
#### @Configuration 클래스 테스트
스프링 3.0의 컨텍스트 테스트 프레임워크는 테스트에서 사용할 애플리케이션 컨텍스트의 설정정보로 XML만 사용할 수 있었지만, 스프링 3.1에선 XML 대신 `@Configuration` 클래스도 사용할 수 있다. `@ContextConfiguration`의 `classes`를 이용해 해당 클래스를 바로 지정해서 사용할 수 있다.

```java
@Configuration
@EnableTransactionManagement
@ComponentScan("myproject")
public class AppConfig {
    // ...
}

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=AppConfig.class)
@Transactional
public class DaoTest {
    @Autowired UserDao userDao;
    // ...

    @Test
    public void userDaoTest() { ... }
}
```

아래와 같이 두 개의 스태틱 `@Configuration` 클래스가 테스트 클래스 내부에 정의됐으면 해당 클래스 모두 테스트용 컨텍스트로 사용된다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
public class MyAppTest {
    // ...

    @Configuration
    static class MyAppConfig { ... }

    @Configuration
    static class MyExtraConfig { ... }
}
```

nested static class로 정의하는 디폴트 설정 클래스들은 `private`이거나 `final`로 선언하면 안된다는 사실을 기억해두자.

만약 XML과 `@Configuration` 둘 다 정의되어 있다면, 어떤 설정 정보를 사용해야 할 지 판단할 수 없으므로 에러가 난다. 아래의 경우 역시 마찬가지다.

```java
@ContextConfiguration(locations="my-context.xml", classes=MyConfig.class)
```

#### @ActiveProfile
빈 설정정보에 프로파일을 적용했다면 테스트에선 어떻게 활성 프로파일을 지정할 수 있을까?

테스트는 서버가 아니라 독립 실행환경으로 동작하므로 표준 환경 오브젝트가 지원하는 환경변수와 시스템 프로퍼티를 이용해 활성 프로파일을 지정할 수 있을 것이다. 테스트를 실행할 때 JVM 옵션으로 `-Dspring.profiles.active=dev`라고 해주면 `dev` 프로파일이 활성화된 컨텍스트가 사용된다.

하지만 환경변수나 시스템 프로퍼티 설정은 번거롭다. 테스트를 실행하는 별도의 스크립트를 따로 만들지 않는다면 환경이 바뀔 때마다 테스트용 활성 프로파일 설정을 다시 해줘야 한다. 또, 한 번에 실행하는 테스트 클래스가 여러 개인데 각기 다른 활성 프로파일을 적용하고 싶다면 환경변수나 시스템 프로퍼티로 일괄 적용하는 방법을 사용할 수 없다.

따라서 스프링 3.1은 간편하게 테스트용 활성 프로파일을 지정할 수 있는 `@ActiveProfiles`를 제공한다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@ActiveProfiles("dev")
public class MyAppTest {
    // ...
}
```

## 정리
- 테스트 컨텍스트 프레임워크를 사용하면 컨텍스트 캐싱을 통해 테스트 성능을 향상시킬 수 있다.
- 테스트 컨텍스트 정보는 상속도 가능하다.
- 테스트 오브젝트는 빈은 아니지만 테스트 컨텍스트의 도움으로 애플리케이션 컨텍스트로부터 테스트에 필요한 빈을 주입받을 수 있. 주요 DI용 애노테이션을 활용할 수 있다.
- DAO를 단독으로 테스트하거나 테스트 작업이 다른 테스트에 영향을 주지 않기 위해서는 롤백 테스트로 만들어야 한다.
- `@Transactional`은 테스트에서 롤백 테스트를 만들 때 사용한다.
- ORM에 대한 테스트는 ORM의 캐시가 동작하는 특징을 잘 이해하고 사용해야 한다.
- DBUnit을 트랜잭션 테스트에 활용하면 테스트 데이터를 손쉽게 등록할 수 있다.