# 3장. 도커 이미지 만들기
![Image](https://github.com/user-attachments/assets/f61e9081-cbb4-4197-91ea-1ffa2225f1fe)

- 하나의 이미지는 여러 이미지가 계층적으로 쌓인 형태로 저장된다.
- 이미지는 도커가 가장 먼저 이미지를 찾기 위해 접근하는 저장소인 Docker Hub로부터 pull을 수행한다.
- 이미지를 제공하는 저장소를 레지스트리라고 한다. Docker Hub는 공개 레지스트리다.
- 도커 이미지는 논리적으론 하나의 대상이다.
  - 애플리케이션 스택 전체가 하나의 파일로 압축된 압축파일을 생각하면 쉽게 이해할 수 있음.
  - 위 이미지의 경우 애플리케이션 코드 외에 Node.js 런타임을 포함한다.
- 이미지를 내려받는 과정을 보면 여러 건의 파일을 동시에 내려받는다는 점에서 단일 파일을 내려받는 과정이 아니다.
  - 각각의 파일을 이미지 레이어라 부른다.
  - 도커 이미지는 물리적으론 여러 개의 작은 파일로 구성돼 있다. 그리고 도커가 이들 파일을 조립해 컨테이너의 내부 파일 시스템을 만든다.
  - 모든 레이어를 내려받고 나면 전체 이미지를 사용할 수 있게 된다.

![Image](https://github.com/user-attachments/assets/a5735082-fd7a-4511-8196-c3bc4d75bc8d)

- `--name` or `-n` : 컨테이너에 원하는 이름을 붙이고 이 이름으로 컨테이너를 지칭.

![Image](https://github.com/user-attachments/assets/845ba35c-3a85-4789-9870-60967a1c72a9)

- 환경 변수 : OS에서 제공하는 키-값 쌍.
- 도커 컨테이너도 별도의 환경 변수를 가질 수 있다. 이 환경 변수는 컨테이너의 호스트명이나 IP 주소처럼 도커가 부여해준다.
  - `--env` or `-e`

![Image](https://github.com/user-attachments/assets/04b14c16-66ce-46b5-89bf-5c7760126f5e)

## Dockerfile 작성하기
- https://docs.docker.com/build/concepts/dockerfile/
- https://docs.docker.com/reference/dockerfile/
---
- **Dockerfile은 애플리케이션을 패키징하기 위한 간단한 스크립트다.**
- 일련의 인스트럭션으로 구성돼 있는데, 인스트럭션을 실행한 결과로 도커 이미지가 만들어진다.
- 자주 쓰이는 작업은 별도의 명령이 마련돼 있으며, 원하는 작업을 직접 작성할 수 있고, 표준 셸 문법도 사용 가능하다.

```
FROM diamol/node

ENV TARGET="blog.sixeyed.com"
ENV METHOD="HEAD"
ENV INTERVAL="3000"

WORKDIR /web-ping
COPY app.js .

CMD ["node", "/web-ping/app.js"]
```

- `FROM` : 모든 이미지는 다른 이미지로부터 출발한다. 이 이미지는 `diamol/node` 이미지를 시작점으로 지정했다.
- `ENV` : 환경 변수 값을 지정하기 위한 인스트럭션. 값을 지정하기 위해 `[key]="[value]"` 형식을 따른다.
- `WORKDIR` : 컨테이너 이미지 파일 시스템에 디렉터리를 만들고, 해당 디렉터리를 작업 디렉터리로 지정하는 인스트럭션. 리눅스와 윈도 컨테이너 모두 구분자로 슬래시를 사용함.
- `COPY` : 로컬 파일 시스템의 파일 혹은 디렉터리를 컨테이너 이미지로 복사하는 인스트럭션이다. `[원본 경로] [복사 경로]` 형식으로 지정한다. 위 스크립트에선 로컬 파일 시스템에 있는 `app.js` 파일을 이미지의 작업 디렉터리로 복사했다.
- `CMD` : 도커가 이미지로부터 컨테이너를 실행했을 때 실행할 명령을 지정하는 인스트럭션이다. 여기선 Node.js 런타임이 애플리케이션을 시작하도록 `app.js`를 지정.

## 컨테이너 이미지 빌드하기
이미지를 빌드하려면 `Dockerfile` 스크립트 외에도 필요한 것이 더 있다. 이미지의 이름, 패키징에 필요한 파일의 경로를 추가로 지정해줘야 한다.

```bash
docker image build --tag web-ping .
```

- `--tag` or `-t` : 이미지의 이름 지정.
- `.` : Dockerfile 및 이미지에 포함 시킬 파일이 위치할 경로. 현재 작업 디렉터리를 의미함.

## 도커 이미지와 이미지 레이어 이해하기
도커 이미지엔 우리가 패키징에 포함시킨 모든 파일이 들어 있다. 이들 파일은 나중에 컨테이너의 파일 시스템을 형성한다. 이 외에도 이미지엔 자신에 대한 여러 메타데이터 정보도 들어 있다. 이 정보 중엔 이미지가 어떻게 빌드됐는지에 대한 간단한 이력도 포함된다. 이 정보를 이용하면 이미지를 구성하는 각 레이어는 무엇이고 이들 레이어가 어떤 명령으로 빌드됐는지 알 수 있다.

```bash
docker image history web-ping
```

- `CREATED BY` : 해당 레이어를 구성한 `Dockerfile` 스크립트의 인스트럭션. 인스트럭션과 이미지 레이어는 1:1 관계를 맺는다.

**도커 이미지는 이미지 레이어가 모인 논리적 대상이다. 레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일이다.** 이미지 레이어는 여러 이미지와 컨테이너에서 공유된다.

![Image](https://github.com/user-attachments/assets/2c1b690e-b7a4-472f-a61e-bcb609cc8165)

![Image](https://github.com/user-attachments/assets/2638f04b-9eea-4e21-8268-de2447ce3d19)

![Image](https://github.com/user-attachments/assets/91dfbbc0-9156-4455-a8fa-6f2d40f6eb5a)

이미지 레이어를 여러 이미지가 공유한다면, 공유되는 레이어는 수정할 수 없어야 한다. 만약 이미지의 레이어를 수정할 수 있다면 그 수정이 레이어를 공유하는 다른 이미지에도 영향을 미치게 된다. 도커는 이미지 레이어를 읽기 전용으로 만들어 두어 이런 문제를 방지한다. 이미지를 빌드하면서 레이어가 만들어지면 레이어는 다른 이미지에서 재사용될 수 있다. 그러나 레이어를 수정할 수는 없다.

## 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화
인스트럭션의 결과가 이전 빌드와 같다면, 이전에 캐시된 레이어를 재사용한다. 이런 방법으로 똑같은 인스트럭션을 다시 실행하는 낭비를 줄일 수 있다.

도커는 캐시에 일치하는 레이어가 있는지 확인하기 위해 해시값을 이용한다. 해시는 입력값이 같은지 확인할 수 있는 일종의 디지털 지문이다. 해시값은 Dockerfile 스크립트의 인스트럭션과 인스트럭션에 의해 복사되는 파일의 내용으로부터 복사되는데, 기존 이미지 레이어에 해시값이 일치하는 것이 없다면 캐시 미스가 발생하고 해당 인스트럭션이 실행된다.

Dockerfile 스크립트의 인스트럭션은 잘 수정하지 않는 인스트럭션이 앞으로 오고 자주 수정되는 인스트럭션이 뒤에 오도록 배치돼야 한다. 이렇게 해야 캐시에 저장된 이미지 레이어를 되도록 많이 재사용할 수 있다. 이미지를 공유하는 과정에서 시간은 물론이고 디스크 용량, 네트워크 대역폭을 모두 절약할 수 있는 방법이다.

![Image](https://github.com/user-attachments/assets/63296cfc-2b8e-49f5-b333-87ce24849a54)

`CMD` 인스트럭션은 스크립트 마지막에 위치할 필요가 없다. 이 인스트럭션은 `FROM` 인스트럭션 뒤라면 어디에 배치해도 무방하다. 또한, 수정할 일이 없다면 초반부에 배치하면 된다. 그리고 `ENV` 인스트럭션 하나로 여러 개의 환경 변수를 정의할 수 있다.

```
FROM diamol/node

CMD ["node", "/web-ping/app.js"]

ENV TARGET="blog.sixeyed.com" \
    METHOD="HEAD" \
    INTERVAL="3000"

WORKDIR /web-ping
COPY app.js .
```