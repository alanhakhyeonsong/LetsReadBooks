# 2장. 도커의 기본적인 사용법
- 컨테이너 패키지 == 도커 이미지
- docker pull → 이미지 내엔 애플리케이션을 실행하는 데 필요한 모든 내용과 함께 애플리케이션을 실행하는 방법의 정의돼 있음. → docker run
- 다른 사람이 패키지를 사용할 수 있도록 공유한 다음, 이 패키지를 내려받은 사람이 컨테이너를 통해 애플리케이션을 실행하는 것.
  - **빌드, 공유, 실행**

## 컨테이너란 무엇인가?
도커 컨테이너는 말 그대로 물건을 담는 컨테이너와 다를 것이 없다. 애플리케이션이 들어 있는 이 상자는 아래와 같다.

![Image](https://github.com/user-attachments/assets/c455123c-6661-4e57-a91a-8eb0488abb95)

**호스트명, IP 주소, 파일 시스템까지 이들은 모두 도커가 만들어낸 가상 리소스다.** 이들이 서로 엮여 애플리케이션이 동작할 수 있는 환경이 만들어진다.

**상자 안에서는 상자 밖의 환경을 볼 수 없다.** 그러나 이 상자는 어떤 컴퓨터 상에서 동작하는 것이고, 이 컴퓨터는 이 상자 말고도 다른 상자를 여러 개 실행할 수 있다. 이들 상자는 서로 독립적인 환경을 갖지만 상자가 실행되는 컴퓨터의 CPU와 메모리, 운영체제를 공유한다.

![Image](https://github.com/user-attachments/assets/486bdec5-b0a6-4d68-ba44-f47010c4928c)

이런 구도가 중요한 이유는 격리와 밀집이라는 얼핏 보면 모순돼 보이는 조건을 동시에 만족할 수 있기 때문이다.
- 밀집이란 컴퓨터에 CPU와 메모리가 허용하는 한 되도록 많은 수의 애플리케이션을 실행하는 것을 의미한다.
- 그러나 서로 다른 여러 애플리케이션을 동시에 실행하는 데는 제약이 따른다. 런타임 버전 이슈나 서로 호환되지 않는 버전의 라이브러리를 사용하는 경우나 한 애플리케이션이 과다한 리소스를 사용해 다른 애플리케이션에 제약이 따르는 경우에 해당한다.
- 가상 머신을 사용한다면, 별도의 OS를 필요로 하는데 각 OS는 애플리케이션이 사용해야 할 CPU와 메모리 자원을 상당량 차지하며, OS의 라이선스 비용과 업데이트 설치 부담이 추가로 생긴다. → 격리는 달성 가능하지만, 밀집은 제공하지 못한다.
- **각각의 컨테이너는 호스트 컴퓨터의 OS를 공유하므로 필요한 리소스가 크게 경감된다.**
  - 실행도 빠르고 같은 호스트 컴퓨터에서 가상 머신에 비해 더 많은 수의 애플리케이션을 실행 가능.
  - 컨테이너 역시 외부와 독립된 환경을 제공하므로 밀집과 격리가 동시에 달성된다.

## 컨테이너를 원격 컴퓨터처럼 사용하기

```bash
docker container run --interactive --tty diamol/base
```

- `--interactive` : 컨테이너에 접속된 상태가 됨.
- `--tty` : 터미널 세션을 통해 컨테이너를 조작한다.

원격 컴퓨터에 접속한 것과 같은 로컬 터미널 세션이 열려 있다는 것과 연결된 컴퓨터가 현재 실행 중인 컨테이너라는 것이다.  
도커 자체는 호스트 컴퓨터의 아키텍처나 운영체제와 상관없이 동일하게 동작하지만, 컨테이너에 들어 있는 애플리케이션은 운영체제나 아키텍처를 가릴 수 있다. 결국 컨테이너의 내용물이 무엇이든 컨테이너를 다루는 방법은 환경과 상관없이 동일하다.

```bash
# 현재 실행 중인 모든 컨테이너에 대한 정보 조회
docker container ls

# 대상 컨테이너에서 실행 중인 프로세스의 목록을 보여준다.
docker container top f1

# 로그 출력
docker container logs f1

# 대상 컨테이너의 상세 정보 출력
docker container inspect f1
```

## 컨테이너를 사용해 웹 사이트 호스팅하기
- 컨테이너 내부의 애플리케이션이 실행 중이어야 컨테이너의 상태도 실행 중이 된다.
- 컨테이너가 종료돼도 컨테이너는 사라지지 않는다.

```bash
docker container run --detach --publish 8088:80 diamol/ch02-hello-diamol-web
```

- `--detach` or `-d` : 컨테이너를 백그라운드에서 실행하며 컨테이너 ID를 출력
- `--publish` or `-p` : 컨테이너의 포트를 호스트 컴퓨터에 공개

도커를 설치하면 호스트 컴퓨터의 네트워크 계층에 도커가 끼어들게 되는데, 그러면 호스트 컴퓨터에서 들고나는 네트워크 트래픽을 모두 도커가 가로채서 그중 필요한 것을 컨테이너에 전달할 수 있다.

**컨테이너는 기본적으로 외부 환경에 노출되지 않는다. 각 컨테이너는 고유의 IP 주소를 갖지만, 이 IP 주소는 도커가 관리하는 내부 가상 네트워크의 주소지 호스트 컴퓨터가 연결된 물리 네트워크에 연결된 것이 아니다.**
- 컨테이너의 포트를 공개한다는 것은 도커가 호스트 컴퓨터의 포트를 주시하다가 해당 포트로 들어오는 트래픽을 컨테이너로 전달해주는 것이다.

![Image](https://github.com/user-attachments/assets/ff9cd2ce-8511-423e-9be3-012553aef325)

```bash
# stats 명령어로 실행중인 컨테이너 상태 확인 (CPU, 메모리, 네트워크, 디스크 사용량)
docker container stats e53

# 컨테이너 삭제
docker container rm --force $(docker container ls --all --quiet)
```

## 도커가 컨테이너를 실행하는 원리
![Image](https://github.com/user-attachments/assets/bdcbb5d5-5338-4a64-ad0a-261a17efab84)

- Docker Engine : 도커의 관리 기능을 맡는 컴포넌트. 로컬 이미지 캐시를 담당하므로 새로운 이미지가 필요하면 이미지를 내려받으며, 기존 이미지가 있다면 전에 내려받은 이미지를 사용한다. 호스트 운영체제와 함께 컨테이너와 가상 네트워크 등 도커 리소스를 만드는 일도 담당한다. 도커 엔진은 항시 동작하는 백그라운드 프로세스다.
- 도커 엔진은 도커 API를 통해 맡은 기능을 수행한다.
- 도커 API는 표준 HTTP 기반 REST API다. 도커 엔진의 설정을 수정하면 이 API를 네트워크를 경유해 외부 컴퓨터로부터 호출할 수 없도록 차단(기본 설정)하거나 허용할 수 있다.
- 도커 CLI : 도커 API의 클라이언트다. `docker` 명령을 사용할 때 실제로 도커 API를 호출하는 것이 도커 CLI.

도커 엔진은 `containerd`라는 컴포넌트를 통해 컨테이너를 실제로 관리하는데, 이는 호스트 운영체제가 제공하는 기능을 통해 컨테이너, 즉 가상 환경을 만든다. CNCF에서 관리하는 오픈소스 프로젝트이며, 컨테이너는 OCI라는 이름으로 공개된 개방형 표준이다.