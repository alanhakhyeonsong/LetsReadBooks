# 2-3장. 개념적인 튜닝 용어
오브젝트들을 스캔하는 유형, 디스크 접근 방식 등 쿼리 튜닝과 관련된 용어들을 정리하자.

## 오브젝트 스캔 유형
오브젝트 스캔 유형은 테이블 스캔과 인덱스 스캔으로 구분한다.
- 테이블 스캔: 인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근하는 유형
- 인덱스 스캔: 인덱스로 테이블 데이터를 찾아가는 유형

### 테이블 풀 스캔
**인덱스를 거치지 않고 테이블로 바로 직행하여 처음부터 끝까지 데이터를 훑어보는 방식**이다. `WHERE` 절의 조건문을 기준으로 활용할 인덱스가 없거나, 전체 데이터 대비 대량의 데이터가 필요할 때 테이블 풀 스캔을 수행할 수 있다.  
다만, 테이블 풀 스캔은 보통 처음부터 끝까지 데이터를 검색하므로 성능 측면에서는 부정적으로 해석된다. 인덱스 없이 사용하는 유일한 방식이다.

![](https://velog.velcdn.com/images/songs4805/post/17f58062-71a7-4d9c-b768-ba66da36cabc/image.png)

### 인덱스 범위 스캔
**인덱스를 범위 기준으로 스캔한 뒤 스캔 결과를 토대로 테이블의 데이터를 찾아가는 방식**이다. SQL문에서 `BETWEEN ~ AND` 구문이나, `<`, `>`, `LIKE` 구문 등 비교 연산 및 구문에 포함될 경우 인덱스 범위 스캔으로 수행한다.  
좁은 범위를 스캔할 때는 성능적으로 매우 효율적인 방식이지만, 넓은 범위를 스캔할 때는 비효율적이다.

![](https://velog.velcdn.com/images/songs4805/post/6f7a9948-70c1-474c-b555-1edb2059196a/image.png)

### 인덱스 풀 스캔
**인덱스를 처음부터 끝까지 수행하는 방식**이다. 단, 테이블에 접근하지 않고 인덱스로 구성된 열 정보만 요구하는 SQL문에서 인덱스 풀 스캔이 수행된다.  
인덱스는 테이블보다 상대적으로 적은 양을 차지하므로 테이블 풀 스캔 방식보단 성능상 유리하다. 그러나 인덱스라는 오브젝트의 전 영역을 모두 검색하는 방식인 만큼 검색 범위를 최대한 줄이는 방향으로 SQL 튜닝을 해야 한다.

![](https://velog.velcdn.com/images/songs4805/post/e4195fa8-d69b-46ca-bd84-6dee5ec47f0c/image.png)

### 인덱스 고유 스캔
**기본 키나 고유 인덱스로 테이블에 접근하는 방식으로, 인덱스를 사용하는 스캔 방식 중 가장 효율적인 스캔 방법이다.** `WHERE` 절에 = 조건으로 작성하며, 해당 조인 열이 기본 키 또는 고유 인덱스의 선두 열로 설정되었을 때 활용한다.

![](https://velog.velcdn.com/images/songs4805/post/b500c5fd-6b7b-41ca-952d-702691455679/image.png)

### 인덱스 루스 스캔
**인덱스의 필요한 부분들만 골라 스캔하는 방식**이다. 인덱스 범위 스캔처럼 넓은 범위에 전부 접근하지 않고, `WHERE` 절 조건문 기준으로 필요한 데이터와 필요하지 않은 데이터를 구분한 뒤 불필요한 인덱스 키는 무시한다.

보통 `GROUP BY` 구문이나 `MAX()`, `MIN()` 함수가 포함되면 작동한다. 이미 오름차순으로 정렬된 인덱스에서 최댓값이나 최솟값이 필요한 경우가 해당된다.

![](https://velog.velcdn.com/images/songs4805/post/0779c66a-ef10-4d05-b3dc-82e184f80d89/image.png)

### 인덱스 병합 스캔
**테이블 내에 생성된 인덱스들을 통합해서 스캔하는 방식**이다. `WHERE` 문 조건절의 열들이 서로 다른 인덱스로 존재하면 옵티마이저가 해당하는 인덱스를 가져와서 모두 활용하는 방식을 취한다.

인덱스 병합 스캔은 물리적으로 존재하는 개별 인덱스를 각각 수행하므로 인덱스에 접근하는 시간이 몇 배로 걸린다. 따라서 별개로 생성된 인덱스들은 보통 하나의 인덱스로 통합하여 SQL 튜닝을 수행하거나, SQL 문 자체를 독립된 하나의 인덱스만 수행하도록 변경할 수 있다.

![](https://velog.velcdn.com/images/songs4805/post/e4139225-e12b-4e2e-8674-2d0e9f589fab/image.png)

## 디스크 접근 방식
MySQL은 원하는 데이터를 찾으려고 데이터가 저장된 스토리지의 페이지에 접근한다. **페이지란 데이터를 검색하는 최소 단위로, 페이지 단위로 데이터를 읽고 쓰기를 수행할 수 있다.**
- 시퀀셜 액세스: 서로 연결된 페이지를 차례대로 읽는다.
- 랜덤 액세스: 여기저기 원하는 페이지를 임의로 열어보며 데이터를 읽는다.

![](https://velog.velcdn.com/images/songs4805/post/7675c27c-56c4-4715-a0ec-58a2514266a6/image.png)


### 시퀀셜 액세스
**시퀀셜 엑세스는 물리적으로 인접한 페이지를 차례대로 읽는 순차 접근 방식으로, 보통 테이블 풀 스캔에서 활용한다.** 데이터를 찾고자 이동하는 디스크 헤더의 움직임을 최소화하여 작업 시간과 리소스 점유 비용을 줄일 수 있다.  
테이블 풀 스캔일 때는 인접한 페이지를 여러 개 읽는 다중 페이지 읽기 방식으로 수행한다.

### 랜덤 액세스
**랜덤 액세스는 물리적으로 떨어진 페이지들에 임의로 접근하는 임의 접근 방식으로, 페이지가 위치한 물리적인 위치를 고려하지 않고 접근한다.** 페이지에 접근하는 디스크 헤더가 정해진 순서 없이 이동하는 만큼 디스크의 물리적인 움직임이 필요하고 다중 페이지 읽기가 불가능하기 때문에, **데이터의 접근 수행 시간이 오래 걸린다.**  
따라서 최소한의 페이지에 접근할 수 있도록 접근 범위를 줄이고 효율적인 인덱스를 활용할 수 있도록 튜닝해야 한다.

## 조건 유형
SQL 문의 `WHERE` 절 조건문 기준으로 데이터가 저장된 디스크에 접근한다. 이때 필요한 데이터에 액세스하는 조건문으로 데이터를 가져오고, 가져온 데이터에서 다시 한번 출력할 데이터만 추출한다.

맨 처음 디스크에서 데이터를 검색하는 조건을 액세스 조건이라 하고, 디스크에서 가져온 데이터에서 추가로 추출하거나 가공 및 연산하는 조건을 필터 조건이라 한다.

### 액세스 조건
**디스크에 있는 데이터에 어떻게 접근할 것인지를 다루는 액세스 조건은 SQL 튜닝에서 가장 중요한 핵심 사항이다.**

`WHERE` 절 조건문으로 필요한 데이터만 골라 가져오는 방식은 테이블에 직접 접근할지, 인덱스를 어떻게 활용할 것인지에 관한 문제이다. SQL 조건문이 복잡하고 다양한 만큼 실제 데이터를 가져오기 위해 활용하는 SQL 문의 조건절에는 한계가 있다.  
따라서 옵티마이저는 `WHERE` 절의 특정 조건문을 이용해 소량의 데이터를 가져오고, 인덱스를 통해 시간 낭비를 줄이는 조건절을 선택하여, 스토리지 엔진의 데이터에 접근하고 MySQL 엔진으로 데이터를 가져온다.

### 필터 조건
**필터 조건은 액세스 조건을 이용해 MySQL 엔진으로 가져온 데이터를 기준으로 추가로 불필요한 데이터를 제거하거나 가공하는 조건이다.**

만약 필터 조건에 따라 필터링할 데이터가 없다면 매우 훌륭한 SQL 문이고, 필터 조건으로 필터링되어 제거된 데이터가 다수 존재한다면 상대적으로 비효율적인 SQL 문이다.  
스토리지 엔진에서 MySQL 엔진으로 데이터를 전달하는 오버헤드가 있고, 필터 조건으로 제거될 데이터라면 스토리지 엔진의 데이터에 접근하는 과정에서 같이 제외되는 편이 성능적으로 효율적이기 때문이다.

```sql
SELECT *
	FROM TAB
WHERE ID = 1
	AND CODE = 'A'
```

위와 같은 SQL 문이 있을 때, 조건문으로는 ID = 1 과 CODE = 'A'가 있다. 만약, ID 열로 생성된 인덱스를 활용해서 테이블을 접근한다면 ID = 1이 액세스 조건이 된다. ID 열로 생성된 인덱스를 통해 가져온 데이터들을 CODE = 'A' 조건으로 필터링 작업을 할 것이다. 따라서 CODE = 'A'가 필터 조건이 된다.