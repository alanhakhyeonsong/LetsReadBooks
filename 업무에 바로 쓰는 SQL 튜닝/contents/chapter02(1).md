# 2-1장. 물리 엔진과 오브젝트 용어
DBMS를 구성하는 엔진들과 내부 프로세스, 그리고 데이터를 저장하는 오브젝트를 가리키는 용어들을 정리하자.

## DB 엔진 용어
MySQL이라는 DBMS는 데이터를 저장하고, 저장된 데이터를 가공하는 연산을 수행한다. 이 과정은 식당에서 음식을 주문하는 과정과 크게 다르지 않다.

![](https://velog.velcdn.com/images/songs4805/post/0648661f-3ebd-48c7-8d43-7192b12fad9c/image.jpg)

사용자는 DB에서 원하는 데이터를 가져오고자 SQL 문을 실행한다.  
실행된 SQL 문은 MySQL 엔진에서 문법 에러가 있는지, DB에 존재하는 테이블 대상으로 SQL 문을 작성했는지와 같은 세부 사항을 다양한 문법 및 구문으로 검사한다.(parser 역할)  
이후 사용자가 요청한 데이터를 빠르고 효율적으로 찾아가는 전략적 계획을 수립한다.(optimizer 역할)  
이 계획을 토대로 스토리지 엔진에 위치한 데이터까지 찾아간 뒤 해당 데이터를 MySQL 엔진으로 전달한다. MySQL 엔진은 전달된 데이터에서 불필요한 부분을 필터링(제거, 변경)하고 필요한 연산을 수행한 뒤 사용자에게 최종 결과를 알려준다.

![](https://velog.velcdn.com/images/songs4805/post/f9ffc426-4fdf-4f07-bf4e-2754ac7b1704/image.jpg)

### 스토리지 엔진
**InnoDB, MyISAM, Memory 등 스토리지 엔진은 사용자가 요청한 SQL 문을 토대로 DB에 저장된 디스크나 메모리에서 필요한 데이터를 가져오는 역할을 수행한다.** 이후 해당 데이터를 MySQL 엔진으로 보내준다.  
스토리지 엔진이 데이터를 저장하는 방식에 따라 각각의 스토리지 엔진을 선택하여 사용할 수 있으며, 필요하다면 외부에서 스토리지 엔진 설치 파일을 가져와 활성화하여 즉시 사용할 수 있다.

**일반적으로는 온라인상의 트랜잭션 발생으로 데이터를 처리하는 OLTP(online transaction processing) 환경이 대다수인 만큼 주로 InnoDB 엔진을 사용한다.**  
대량의 쓰기 트랜잭션이 발생하면 MyISAM 엔진을,  
메모리 데이터를 로드하여 빠르게 읽는 효과를 내려면 Memory 엔진을 사용하는 식으로 응용하여 스토리지 엔진을 선택할 수 있다.

다음은 MySQL 8.0 버전에서 기본 제공하는 스토리지 엔진 목록이다.  
참고로, MySQL과 MariaDB가 뿌리는 같으나 제공하는 엔진 목록이 일치하진 않는다. (MariaDB의 Sequence 엔진은 Oracle의 시퀀스 오브젝트와 유사하게 동작함)

- MySQL 8.0 버전

![](https://velog.velcdn.com/images/songs4805/post/5864cc9e-5e97-4d0c-af3f-2755d868901e/image.png)

### MySQL 엔진
MySQL 엔진은 사용자가 요청한 SQL 문을 넘겨받은 뒤 SQL 문법 검사와 적절한 오브젝트 활용 검사를 하고, SQL 문을 최소 단위로 분리하여 원하는 데이터를 빠르게 찾는 경로를 모색하는 역할을 수행한다.

이후 스토리지 엔진으로부터 전달받은 데이터를 대상으로 불필요한 데이터는 제거하거나 가공 및 연산하는 역할을 한다.

SQL 문의 시작 및 마무리 단계에 MySQL 엔진이 관여하며, 스토리지 엔진으로부터 필요한 데이터만을 가져오는 핵심 역할을 담당한다.

## SQL 프로세스 용어
SQL 문은 의외로 복잡한 과정을 거쳐 결괏값을 출력한다.  
사용자가 SQL 문을 수행하면, **파서는 MySQL이 이해할 수 있는 최소 단위로 구성요소를 분리하고 해당 구성요소를 트리로 만든다.** 트리를 만드는 과정에서는 문법 오류가 있는지 검토한다. 트리의 최소 단위는 >, <, = 등의 기호나 SQL 키워드로 분리한다. 만약 트리에 허용되지 않는 문법이 포함된다면 에러 발생과 동시에 실행이 종료된다.

이후 **전처리기는 생성된 트리 결과를 토대로, 이미 만들어진 테이블이나 뷰 등으로 구성되지는 않는지, 존재하지 않는 열을 포함하지는 않는지, 조회 권한이 없는 테이블을 조회하는지 등 유효성을 검증한다.** 만약 유효하지 않은 오브젝트가 있거나 권한이 없는 오브젝트를 호출하면 바로 에러를 발생하여 사용자에게 표시한다.

**옵티마이저는 트리를 구성하는 오브젝트의 데이터를 효율적으로 가져오기 위해 시간은 적게 소요되면서도 비용 효율적인 경로로 데이터를 검색하는 방법에 관한 실행 계획을 수립한다.**

**엔진 실행기는 이전에 수립된 실행 계획으로 스토리지 엔진을 호출해 필요한 데이터를 가져온다.** 이후 엔진 실행기는 스토리지 엔진을 통해서 가져온 데이터 중 불필요한 데이터를 필터링하여 사용자가 원하는 결과를 전달한다.

![](https://velog.velcdn.com/images/songs4805/post/f3ed235e-406e-472e-b779-ac5d24cf9714/image.jpg)

핵심 역할을 수행하는 각 오브젝트를 간단히 정리하면 다음과 같다.

### 파서(parser)
MySQL 엔진에 포함되는 오브젝트로, 사용자가 요청한 SQL 문을 쪼개 최소 단위로 분리하고 트리를 만든다. 트리를 만들면서 문법 검사를 수행한다.

### 전처리기(preprocessor)
MySQL 엔진에 해당하는 오브젝트로, 파서에서 생성한 트리를 토대로 SQL 문에 구조적인 문제가 없는지 파악한다. SQL 문에 작성된 테이블, 열, 함수, 뷰와 같은 오브젝트가 실질적으로 이미 생성된 오브젝트인지, 접근 권한은 부여되어 있는지 확인하는 역할을 한다.

### 옵티마이저(optimizer)
**옵티마이저는 MySQL의 핵심 엔진 중 하나로, DBMS에서 두뇌라고 불러도 과언이 아닐 만큼 핵심적인 역할을 수행한다.** 전달된 파서 트리를 토대로 필요하지 않은 조건은 제거하거나 연산 과정을 단순화한다. 나아가 어떤 순서로 테이블에 접근할지, 인덱스를 사용할지, 사용한다면 어떤 인덱스를 사용할지, 정렬할 때 인덱스를 사용할지 아니면 임시 테이블을 사용할지와 같은 실행 계획을 수립한다.

실행 계획으로 도출할 수 있는 경우의 수가 지나치게 많을 때는 실행 계획을 수립하고 비용을 산정하여 최적의 실행 계획을 선택하기까지 시간이 오래 걸리는 만큼 모든 실행 계획을 판단하진 않는다. 다시 말해, **옵티마이저가 선택한 최적의 실행 계획이 최상의 실행 계획이 아닐 가능성도 있다는 걸 의미한다.**

실행 계획을 수립하는 작업만으로 사용자의 대기 시간과 하드웨어 리소스를 점유하므로, 시간과 리소스에 제한을 두고 실행 계획을 산정해야 한다.

### 엔진 실행기(engine executor)
**엔진 실행기는 MySQL 엔진과 스토리지 엔진 영역 모두에 걸치는 오브젝트로, 옵티마이저에서 수립한 실행 계획을 참고하여 스토리지 엔진에서 데이터를 가져온다.** 이후 MySQL 엔진에서는 읽어온 데이터를 정렬하거나 조인하고, 불필요한 데이터는 필터링 처리하는 추가 작업을 한다.

따라서 **MySQL 엔진의 부하를 줄이려면 스토리지 엔진에서 가져오는 데이터양을 줄이는 것이 매우 중요하다.**

## DB 오브젝트 용어
2차원 형태의 관계형 데이터베이스에서 표는 테이블, 열은 컬럼, 행은 로우라는 용어로 사용한다.

### 테이블(table)
데이터를 저장하는 오브젝트로 행과 열의 정보를 담는다. 관계형 데이터베이스인 MySQL은 2차원 배열 형태로 테이블을 관리한다. 테이블에선 저장 방식과 저장 구조에 따라 스토리지 엔진 속성을 정의할 수 있다. InnoDB 스토리지 엔진은 보통 OLTP 환경에서 주로 사용하는 기본 DB 엔진이며 그 외에도 MyISAM, Memory, Blackhole 엔진 등이 있다.

### 로우(행, row)
테이블에서 동일한 구조의 데이터 항목들의 집합을 가리킨다. 학번, 이름, 생년월일, 연락처, 전공코드의 열로 구성된 학생 테이블에서 `10001/홍길동/20001021/010-123-4567/CS`라는 5개의 데이터 항목이 하나의 행을 이룬다. 다른 행 역시 데이터의 값 자체는 다르지만 데이터 항목의 구조는 동일하다.

행은 하나의 데이터 항목 집합이며 모든 행의 집합을 테이블이라 할 수 있다.

### 컬럼(열, column)
열에 해당하는 용어이다. 사전에 정의한 데이터 유형으로 데이터값을 저장하며, 열별로 다른 데이터 유형을 가질 수 있다. 예를 들어 학생 테이블에서 학번 열은 숫자형 데이터로, 이름은 문자열 유형으로 정의할 수 있다.

### 기본 키(primary key, PK)
특정 행을 대표하는 열을 가리키는 용어로 주 키라고도 한다. 기본 키는 학생 테이블의 학번, 전공 테이블의 전공코드처럼 각 테이블에서 1개 열만으로 생성하지만 상황에 따라 2개 이상의 열을 조합해 기본 키를 구성할 수도 있다. 또한 기본 키는 인덱스 역할도 수행하므로 기본 키를 활용하여 인덱싱할 수 있다.

MySQL/MariaDB에서 기본 키는 클러스터형 인덱스로 작동한다. 이는 기본 키의 구성 열 순서를 기준으로 물리적인 스토리지에 데이터가 쌓인다는 뜻이다. 즉, 비슷한 기본 키 값들이 근거리에 적재되므로 기본 키를 활용하여 인덱스 스캔을 수행하면 테이블 데이터에 더 빠르게 접근할 수 있다.

> 📌 참고: 인덱스의 주의사항  
> 기본 키와 똑같은 인덱스를 생성하면 인덱스가 저장되는 물리적 공간이 낭비되는 한편 데이터의 삽입/삭제/수정에 따른 인덱스 정렬의 오버헤드가 발생한다. 다음은 학셍 테이블을 생성하는 DDL 문으로 학번 인덱스는 불필요한 공간 낭비와 정렬의 오버헤드가 발생하므로 삭제해야 한다는 것을 보여주는 예시이다.

```sql
CREATE TABLE 학생 (
    학번 INT(11) NOT NULL,
    이름 VARCHAR(14) NOT NULL,
    생년월일 DATE NOT NULL,
    연락처 VARCHAR(16) NOT NULL,
    전공코드 VARCHAR(3) NOT NULL,
    PRIMARY KEY (학번),
    INDEX I_학번 (학번)
)
```

### 외래 키(foreign key, FK)
외래 키는 외부에 있는 테이블을 항상 참조하면서, 외부 테이블의 데이터가 변경되면 함께 영향을 받는 관계를 설정하는 키이다. 여기서 외부 테이블을 부모 테이블, 외부 테이블을 참조하는 테이블을 자식 테이블이라 생각하면 된다. (FK를 포함하는 테이블이 부모 테이블)

만약 자식 테이블에 없는 값(부모 테이블의 FK)을 부모 테이블에 데이터로 삽입/수정하려 한다면 에러가 발생한다. 부모 테이블에서 외래 키값에 변경사항이 발생할 때마다 외래 키 설정조건을 항상 검증하므로 데이터 정합성 향상을 위해서라도 외래 키를 설정한다.

### 인덱스(index)
**데이터베이스에서 키값으로 실제 데이터 위치를 식별하고 데이터 접근 속도를 높이고자 생성되는, 키 기준으로 정렬된 오브젝트이다.**

테이블의 데이터를 처음부터 끝까지 전부 차례로 검색하는 비효율적인 방식을 개선하고자 인덱스를 만든다. 책에서 맨 뒷장에 INDEX라고 첨부된 부록 페이지를 보면 알파벳, 한글 순서대로 정렬된 각 키워드가 어느 곳에 있는지를 구성되어 있는 것이 대표적인 예시이다. 이처럼 정렬된 각 키워드가 어느 곳에 있는지를 인덱스라는 이름으로 구성하면, 키워드 검색으로 원하는 페이지를 빠르게 찾을 수 있다. 이런 방식을 DBMS에 차용한 게 인덱스이다.

![](https://velog.velcdn.com/images/songs4805/post/aec24337-e3ba-46b7-9065-208c26dca644/image.jpg)

위 예시에서 학생 테이블의 인덱스는 이름 컬럼의 데이터 기준으로 정렬되는 키 오브젝트이다. 해당 인덱스의 이름 정보로 테이블의 데이터를 검색하는 작업은 매우 쉽다. 따라서 저장된 데이터를 검색할 일이 많을 때는 인덱스를 설계하고 생성하는 과정이 매우 중요하다.

대부분의 인덱스를 이야기 한다면 비고유 인덱스를 일컫는다.

- 고유 인덱스

인덱스를 구성하는 열들의 데이터가 유일하다. 차례로 정렬되는 인덱스 열의 데이터는 서로 중복되지 않고 유일성을 유지한다. 만약 동일한 데이터가 생성되면 고유 인덱스의 중복 체크 과정에서 에러가 발생한다. 또한 중복이 없는 열들을 고유 인덱스로 생성하려 한다면 중복이 있는지 검증하는 절차를 거쳐야 하므로, 불필요한 중복 검증 과정이 추가되니 주의해야 한다.

```sql
ALTER TABLE 학생
ADD UNIQUE INDEX 연락처_인덱스(연락처);
```

- 비고유 인덱스

고유 인덱스에서 데이터의 유일한 속성만 제외한 키이다. 데이터가 신규 입력되어 인덱스가 재정렬되더라도 인덱스 열의 중복 체크를 거치지 않고 단순한 정렬 작업을 수행한다.

```sql
ALTER TABLE 학생
ADD INDEX 이름_인덱스(이름);
```

### 뷰(view)
가상 테이블이라 이해하면 된다. 물리적으로 잡히지 않는 유령과 같은 오브젝트이다.

예를 들어, 학생 테이블의 데이터가 변경되면 학생_뷰에서도 바로 변경된 데이터를 조회할 수 있다. 반대로 학생_뷰에서 데이터를 변경하면 학생 테이블의 해당 데이터도 즉시 변경된다.

학생 테이블의 개인정보를 외부에 직접적으로 공개하지 않고도 학생_뷰를 만들어 제한된 정보만을 제공할 수 있다. 시스템을 안전하게 운영하고 개발할 수 있는 환경을 제공하는 만큼 보안성 측면에서 뷰의 가치가 부각될 수 있다.

```sql
CREATE VIEW 학생_뷰 AS
SELECT 학번, 이름
  FROM 학생;
```

생성된 뷰를 대상으로 개발자는 `SELECT * FROM 학생_뷰;` 구문을 작성해 마치 테이블인 것처럼 활용할 수 있다. 그 결과 `SELECT 학번, 이름 FROM 학생;` 구문처럼 테이블에 직접 접근하는 쿼리를 활용할 때와 동일하다.

📌 뷰를 사용하는 이유?  
일부 데이터에 대해서만 데이터를 공개하고, 노출에 민감한 데이터에 대해서는 제약을 설정할 수 있는 보안성 때문이다. 한편 여러 개의 테이블을 병합(join)해서 활용할 때는 성능을 고려한 최적화된 뷰를 생성함으로써 일관된 성능을 제공할 수 있다.