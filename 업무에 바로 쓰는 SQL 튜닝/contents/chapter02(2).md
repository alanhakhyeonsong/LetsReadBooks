# 2-2장. 논리적인 SQL 개념 용어
SQL 문 작성에 필요한 주변 오브젝트와 SQL 문의 상호관계, 연관성과 알고리즘에 관한 논리적 개념 용어를 정리해보자.

## 서브쿼리 위치에 따른 SQL 용어
**서브쿼리(subquery)란 쿼리 안의 보조쿼리를 가리키는 용어이다.** 가장 바깥쪽의 `SELECT` 문인 메인쿼리를 기준으로 내부에 `SELECT` 문을 추가로 작성해서 서브쿼리를 만든다.  
작성하는 위치에 따라 부르는 용어가 다르다.

```sql
SELECT (SELECT ... FROM ...) # SELECT 절: 스칼라 서브쿼리
  FROM (SELECT ... FROM ...) # FROM 절: 인라인 뷰
WHERE 컬럼명 IN (SELECT ... FROM ...) # WHERE 절: 중첩 서브쿼리
```

### 스칼라 서브쿼리
메인쿼리의 `SELECT` 절에 있는 또 다른 `SELECT` 절을 말한다. 메인쿼리의 `SELECT` 절에서는 최종 출력하려는 열들이 나열되므로, 출력 데이터 1건과 스칼라 서브쿼리의 결과 건수가 일치해야 한다. 만약 스칼라 서브쿼리의 결괏값이 2개 이상 나온다면 에러가 발생할 것이다.  
**즉, 스칼라 서브쿼리의 결괏값은 1행 1열의 구조로 출력되어야 한다.**

보통 스칼라 서브쿼리는 출력되는 데이터 건수가 1건이어야 하므로 집계함수(`max`, `min`, `avg`, `sum`, `count` 둥)가 자주 쓰인다.
```sql
SELECT 이름,
       (SELECT COUNT(*)
          FROM 학생 AS 학생2
        WHERE 학생2.이름 = 학생1.이름) 카운트
FROM 학생 AS 학생1;
```

### 인라인 뷰
메인쿼리의 `FROM` 절에 있는 또 다른 `SELECT` 절을 말한다. `FROM` 절 내부에서 일시적으로 뷰를 생성하는 방식이므로 인라인 뷰라 불린다. 인라인 뷰의 결과는 내부적으로 메모리 또는 디스크에 임시 테이블을 생성하여 활용한다.
```sql
SELECT 학생2.학번, 학생2.이름
  FROM (SELECT *
          FROM 학생
        WHERE 성별 = '남') 학생2;
```

### 중첩 서브쿼리
메인쿼리의 `WHERE` 절에 있는 또 다른 `SELECT` 절을 말한다. `WHERE` 절에서 단순한 값을 비교 연산하는 대신, 서브쿼리를 추가하여 비교 연산하기 위해 중첩 서브쿼리를 사용한다.  
`WHERE` 절에서 중첩 서브쿼리와 비교할 때는 보통 비교 연산자를 비롯해 `IN`, `EXISTS`, `NOT IN`, `NOT EXISTS` 문을 많이 사용한다.
```sql
SELECT *
  FROM 학생
WHERE 학번 = (SELECT MAX(학번) FROM 학생)
```

## 메인쿼리와의 관계성에 따른 SQL 용어
서브쿼리와 메인쿼리의 관계성에 따른 SQL 용어를 정리해보자. 서브쿼리는 그 자체가 독립적인 형태로 존재할 수도 있고 메인쿼리와 끈끈한 관계를 유지하며 존재할 수도 있다.

### 비상관 서브쿼리
**비상관 서브쿼리(non correlated subquery)는 메인쿼리와 서브쿼리 간에 관계성이 없음을 의미한다.** 서브쿼리가 독자적으로 실행한 뒤 메인쿼리에게 그 결과를 던져주는 형태인 것이다.

다시 말해, 비상관 서브쿼리에서는 서브쿼리가 먼저 실행된 뒤 그 결과를 메인쿼리가 활용한다. **서브쿼리 실행 → 메인쿼리 실행의 순서로 실행된다.**

```sql
SELECT *
  FROM 학생
WHERE 학번 IN (SELECT 학번
                FROM 학생
              WHERE 성별 = '남')
```
위 예시는 `성별 = '남'` 조건으로 학생 테이블에서 데이터를 가져온 뒤 그 결과를 메인쿼리의 학생 테이블로 전달하여 최종 데이터를 출력한다.  
// DB 버전 및 옵티마이저에 따라 서브쿼리가 제거되고 하나의 메인쿼리로 통합되는 뷰 병합, 즉 SQL 재작성이 작동할 수도 있다.

### 상관 서브쿼리
**상관 서브쿼리(correlated subquery)는 메인쿼리와 서브쿼리 간에 관계성이 있음을 의미한다.** 서브쿼리가 수행되려면 메인쿼리의 값을 받아야 하므로 서브쿼리와 메인쿼리는 서로 끈끈한 관계를 유지한다.  
상관 서브쿼리는 `SELECT` 절에 작성하는 스칼라 서브쿼리와 `WHERE` 절에 작성하는 중첩 서브쿼리일 때 발생한다.

![](https://velog.velcdn.com/images/songs4805/post/5012c5ba-21dc-4df2-b50b-2ca4de641d0c/image.jpg)

메인쿼리에서 `학생.학번` 데이터를 전달받은 뒤 서브쿼리가 수행되고, 그 결과를 다시 메인쿼리로 전달한다.

전체적인 수행순서는 **메인쿼리 실행(학생.학번 데이터 가져오기) → 서브쿼리 실행(지도교수.학번 = 학생.학번) → 다시 메인쿼리 실행한 뒤 결과 출력(`SELECT * FROM 학생~`)** 과 같다.  
// 이때도 역시 뷰 병합이 작동될 수도 있다.

## 반환 결과에 따른 SQL 용어
서브쿼리의 결과 유형은 수치적 기준으로 구분할 수 있다.

### 단일행 서브쿼리
**단일행 서브쿼리는 서브쿼리 결과가 1건의 행으로 반환되는 쿼리이다.** 메인 쿼리 조건절에서는 `=`, `<`, `>` 등의 연산자와 비교한다. 주로 스칼라 서브쿼리와 동일하다고 볼 수 있다.

![](https://velog.velcdn.com/images/songs4805/post/1d5c95c3-7df9-4a70-837c-63a889207234/image.jpeg)

### 다중행 서브쿼리
**다중행 서브쿼리는 서브쿼리 결과가 여러 건의 행으로 반환되는 쿼리이다.** 그에 따라 메인쿼리의 조건절에는 `IN` 구문으로 서브쿼리에서 반환되는 값들을 받는다.

![](https://velog.velcdn.com/images/songs4805/post/49405e35-2349-4888-bef4-c904f8ad6973/image.jpeg)

위 예시는 다중행 서브쿼리에서 전공코드별 학번 최댓값들을 반환된다. 이후 메인쿼리가 수행되고 최종 결과가 출력된다.

### 다중열 서브쿼리
**다중열 서브쿼리에서는 서브쿼리 결과가 여러 개의 열과 행으로 반환된다.** 그에 따라 메인쿼리의 조건절에서는 `IN` 구문과 함께 서브쿼리에서 반환될 열들을 동일하게 나열해 서브쿼리 결과를 받는다.

![](https://velog.velcdn.com/images/songs4805/post/7679c6de-dfab-44e3-a70e-f7d2f392fa65/image.jpeg)

## 조인 연산방식 용어
DB에는 다수의 테이블이 있고 필요한 데이터도 여기저기 흩어져 있다. 이때 필요한 데이터끼리 결합할 때 조인이라는 방식을 사용한다. 분리된 데이터 간의 공통된 정보, 즉 동일한 열값 또는 키값 기준으로 데이터를 논리적으로 연결할 수 있다.

학생 테이블과 지도교수 테이블은 기본적으로 1:1 관계를 유지하며, 지도교수가 확정되지 않은 학생은 지도교수 테이블에 해당 학번이 없을 수 있고, 자퇴한 학생의 정보는 지도교수 테이블에 데이터가 아직 남아있을 수 있다는 예시로 조인 방식을 정리해보자.

![](https://velog.velcdn.com/images/songs4805/post/4f66f429-9ede-4336-acfe-c4e6de91a87c/image.png)

### 내부 조인
**내부 조인은 말 그대로 교집합에 해당하는 방식으로, 양쪽에 모두 존재하는 데이터만 반환한다.** 예를 들어, 위 예제에서 내부 조인을 수행하면 `1,2,4`라는 3개의 학번이 출력된다.

내부 조인을 명시적 조인으로 표현한 SQL 문은 다음과 같다. `JOIN` 키워드에는 조인 대상 테이블을 작성하고 `ON` 절에는 조인할 비교조건을 작성한다.

```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
  FROM 학생
  JOIN 지도교수
    ON 학생.학번 = 지도교수.학번
```

내부 조인에 대해 눈에 보이지 않는 암시적 조인으로 SQL 문을 작성한 예제는 다음과 같다.
```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
  FROM 학생, 지도교수
 WHERE 학생.학번 = 지도교수.학번
```

### 왼쪽 외부 조인
**왼쪽 외부 조인(left outer join)은 왼쪽 테이블(먼저 작성된 테이블) 기준으로 오른쪽 테이블(나중에 작성된 테이블)과 조인을 수행하지만, 조인 조건과 일치하지 않더라도 왼쪽 테이블의 결과는 최종 결과에 포함된다.** 예제에서 학생 테이블에만 존재하는 학번 3은 지도교수 테이블에 포함되지 않는데도 출력된다.

```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
  FROM 학생
  LEFT OUTER JOIN 지도교수
               ON 학생.학번 = 지도교수.학번
```
학번 3은 지도교수 테이블에 없는 데이터이므로 교수명 열에는 NULL 값으로 출력된다.

### 오른쪽 외부 조인
**오른쪽 외부 조인(right outer join)은 오른쪽 테이블(나중에 작성된 테이블) 기준으로 왼쪽 테이블(먼저 작성된 테이블)과 조인을 하지만, 조인 조건과 일치하지 않더라도 오른쪽 테이블의 결과는 최종 결과에 포함된다.** 왼쪽 외부 조인의 방식과 정반대 방식으로 동작한다.

```sql
SELECT 지도교수.학번, 학생.이름, 지도교수.교수명
  FROM 학생
  RIGHT OUTER JOIN 지도교수
                ON 학생.학번 = 지도교수.학번
```
학번 99번 데이터는 학생 테이블에는 없고, 지도교수 테이블에만 있으므로 학생 테이블의 이름 열에는 NULL 값으로 출력된다.

**사람의 인지적 특성상 보통 왼쪽 → 오른쪽을 정방향으로 인식하므로, 쿼리에서 왼쪽에 위치한 테이블 기준으로 조인을 수행하는 왼쪽 외부 조인을 주로 사용한다.**

### 교차 조인
**교차 조인(cross join)은 수학적 관점에서 봤을 때 데카르트 곱(cartesian product)이라고 하는 곱집합 개념으로, 조인에 참여하는 테이블에서 발생할 수 있는 모든 조합을 찾아내어 반환한다.** 모든 경우의 수가 출력 대상이므로 내부 조인에 비해 수십 배에서 수백 배 이상 많은 데이터양을 얻을 수 있다. 조인 연산과정의 시간적, 공간적 리소스 점유 측면에서 오버헤드가 발생하는 만큼 주의해야 한다.

위 예제에선 학생 테이블의 4개 학번과 지도교수 테이블의 4개 학번을 곱해 총 16가지의 결과가 출력될 것이다.

```sql
SELECT 학생.학번, 학생.이름, 지도교수.학번, 지도교수.교수명
  FROM 학생
 CROSS JOIN 지도교수

SELECT 학생.학번, 학생.이름, 지도교수.학번, 지도교수.교수명
  FROM 학생, 지도교수
```

### 자연 조인
**자연 조인(natural join)은 2개 테이블에 동일한 열명이 있을 때 조인 조건절을 따로 작성하지 않아도 자동으로 조인을 수행해주는 방식이다.** 조인이 제대로 성사되면 내부 조인과 동일한 결과가 출력된다. 이때 조인하는 열들의 데이터 유형이 서로 달라도 자연 조인이 수행된다.

// `NATURAL JOIN` 키워드를 작성하면 조인 조건절을 알아서 찾아주므로 직접적인 조인 조건문은 작성하지 않는다.
```sql
SELECT 학생.*, 지도교수.*
  FROM 학생
NATURAL JOIN 지도교수
```

두 테이블에 공통으로 존재하는 열명이 하나도 없다면, 교차 조인으로 수행된다.  **따라서 자연 조인은 열명 변경에 따라 출력 결과가 달라지며 의도치 않은 결과로 출력될 가능성이 높아 일반적으로 잘 활용하지 않는다. 대부분 의도한 조인 방식을 명시하는 내부 조인이나 외부 조인을 활용한다.**

## 조인 알고리즘 용어
다수의 테이블에서 조인을 수행할 때는 동시에 여러 개의 테이블에 접근할 수 없는 만큼 접근하는 우선순위를 정하게 된다. 다수의 테이블에서 첫 번째로 접근할 테이블, 두 번째로 접근할 테이블, 세 번째로 접근할 테이블 등 내부적으로 순번을 정하고, 차례로 테이블에 접근한 결과를 다음 순번의 테이블로 전달한다.

테이블에 접근하는 선후 관계에 따라 **드라이빙 테이블**과 **드리븐 테이블**이라는 용어로 구분한다. 각 테이블에 접근해 조인을 수행하는 알고리즘도 여러 가지 방식이 있다.

### 드라이빙 테이블과 드리븐 테이블
```sql
SELECT 학생.학번, 학생.이름, 비상연락망.관계, 비상연락망.연락처
  FROM 학생
  JOIN 비상연락망
    ON 학생.학번 = 비상연락망.학번
 WHERE 학생.학번 IN (1, 100)
```
위 코드와 같이 학생 정보가 저장된 학생 테이블과 학생 가족 정보가 저장된 비상연락망 테이블이 있다고 가정한다. 학생의 학번이 1과 100에 해당할 때만 학생 정보와 비상연락망 정보를 조회하는 SQL 문이다.

`학생.학번 IN (1, 100)` 조건이 있으므로 학생 테이블의 데이터를 먼저 찾아 볼 것이다. 그 결과로 이번에는 비상연락망 테이블에서 학번 1과 100을 검색한다. 이처럼 2개 테이블로 분리된 데이터에서 원하는 결과를 추려 결합하는 조인을 수행할 때, 테이블에 동시 접근할 수는 없으므로 테이블의 데이터에 접근하는 우선순위가 존재한다.  
이 예제에서 먼저 접근하는 테이블인 드라이빙 테이블(outer table)은 학생 테이블, 그 결과를 통해 뒤늦게 데이터를 검색하는 드리븐 테이블(inner table)은 비상연락망 테이블이다.

**드라이빙 테이블에서 많은 건수가 반환되면 해당 결과를 가지고 드리븐 테이블에 접근하게 되는 만큼 사실상 드라이빙 테이블을 무엇으로 선정할지는 매우 중요한 문제이다.** 가능하면 적은 결과가 반환될 것으로 예상되는 드라이빙 테이블을 선정하고, 조인 조건절의 열이 인덱스로 설정되도록 구성해야 한다.

### 중첩 루프 조인
**중첩 루프 조인(nested loop join, NL 조인)은 드라이빙 테이블의 데이터 1건당 드리븐 테이블을 반복해 검색하며 최종적으로는 양쪽 테이블에 공통된 데이터를 출력한다.**

만약 기본 키와 인덱스가 없는 두 테이블이 존재하는 상황에서 극단적인 중첩 루프 조인을 수행한다면 학번 1을 학생 테이블에서 검색하려고 학생 테이블의 데이터 100건에 모두 접근한 뒤 이후 학번 1과 동일한 데이터를 가졌는지 비교해보려고 비상연락망 테이블의 데이터 1000건에 모두 접근한다.  
학번 100의 학생 정보 역시 같은 방식을 100+1000 건의 데이터에 접근해서 총 2200건의 데이터에 접근하게 된다.

![](https://velog.velcdn.com/images/songs4805/post/21b03548-1f5d-42b9-8c3a-e39c045d7bb0/image.jpeg)

학생 테이블에 학번 열로 인덱스가 생성되어 있고, 비상연락망 테이블에도 학번 열로 인덱스가 생성되어 있는 환경을 가정하고 앞에서 수행한 SQL 문을 똑같이 수행하면 각 테이블에 생성된 인덱스로 데이터에 접근한다.

이를 정량적 수치로 표현하면 학번 1인 데이터 (1+2)와 학번 100인 데이터 (1+1)를 찾기 위해 총 6건의 데이터에 접근하게 된다.  
// 인덱스의 다음 값을 확인하고 접근 대상이 되는지 여부를 판단하는 것도 실제로는 접근 횟수에 포함되어야 하지만 여기서는 생략했다.

![](https://velog.velcdn.com/images/songs4805/post/c7cc4a34-7b00-4bbe-953b-ecea0c8e428c/image.jpeg)

**사실 인덱스는 인덱스로 정의된 열 기준으로 순차 정렬되지만, 인덱스를 이용해 테이블의 데이터를 찾아가는 과정에서 임의 접근 방식인 랜덤 액세스가 발생한다.** 따라서 랜덤 액세스를 줄일 수 있도록 데이터의 액세스 범위를 좁히는 방향으로 인덱스를 설계하고 조건절을 작성해야 한다.

단, 랜덤 액세스를 유발하는 인덱스는 기본 키가 아닌 비고유 인덱스일 경우에 해당한다. 기본 키는 클러스터형 인덱스이므로 기본 키의 순서대로 테이블의 데이터가 적재되어 있어 조회 효율이 매우 높다.

### 블록 중첩 루프 조인
학생 테이블이 드라이빙 테이블이고, 비상연락망 테이블은 인덱스 없이 생성되어 있다고 가정하고 중첩 루프 조인을 수행한다면 다음과 같이 수행된다.

![](https://velog.velcdn.com/images/songs4805/post/3045a05e-1e5b-4a47-a72e-58bd19f5cd69/image.jpeg)

학생 인덱스로 학번 1 데이터를 찾은 뒤, 인덱스가 없는 비상연락망 테이블의 전체 데이터에 모두 접근해야 한다. 이후 학생 테이블에서 학번 데이터 100을 찾고, 또다시 비상연락망 테이블은 전체 데이터 1000건에 접근한다.  
즉, 인덱스가 없는 드리븐 테이블에 대해 매번 전체 데이터를 비효율적으로 검색해야 한다.

**중첩 루프 조인의 효율성을 높이고자 탄생한 것이 바로 블록 중첩 루프 조인(BNL 조인)이다.** 드라이빙 테이블에 **조인 버퍼(join buffer)라는 개념을 도입하여 조인 성능의 향상을 꾀할 수 있다.**

![](https://velog.velcdn.com/images/songs4805/post/7e3143b7-87c4-455b-8e5a-754bbe35394d/image.jpeg)

1. 드라이빙 테이블인 학생 테이블에서 학번 1과 학번 100에 해당하는 데이터를 검색
2. 검색된 데이터를 조인 버퍼에 가득 채워질 때까지 적재
3. 조인 버퍼와 비상연락망 테이블의 데이터를 비교
4. 조인 버퍼와 데이터를 조인하는 식을 반복하여 비상연락망 데이터에 모두 접근

이처럼 조인 버퍼의 데이터들과 비상연락망 테이블의 한 번의 테이블 풀 스캔으로 원하는 데이터를 모두 찾을 수 있다. **비상연락망 테이블의 테이블 풀 스캔을 줄이는 게 목적으로, 성능 저하를 개선하는 조인 알고리즘 방식이다.**

### 배치 키 액세스 조인
중첩 루프 조인 방식은 필연적으로 데이터 접근 시 인덱스에 의한 **랜덤 액세스가 발생**하므로, 액세스할 데이터의 범위가 넓다면 비효율적인 조인 방식이다.

이러한 **랜덤 액세스의 단점을 해결하고자 접근할 데이터를 미리 예상하고 가져오는 데 착안한 조인 알고리즘을 배치 키 액세스 조인(batched key access join, BKA 조인)이라 한다.**

- 드라이빙 테이블의 조인 버퍼 개념을 그대로 사용한다.
- 드리븐 테이블에 필요한 데이터를 미리 예측하고 정렬된 상태로 담는 랜덤 버퍼의 개념을 도입한다.
- 드리븐 테이블의 데이터를 예측하고 정렬된 상태로 버퍼에 적재하는 기능을 **다중 범위 읽기(multi range read, MRR)** 라 한다.

**미리 예측된 데이터를 가져와 정렬된 상태에서 랜덤 버퍼에 담기 때문에, 드리븐 테이블에 대해 랜덤 액세스가 아닌 시퀀셜 액세스를 수행하는 방식이다.**

![](https://velog.velcdn.com/images/songs4805/post/22753178-976d-4f4e-8654-5e3a4d1dcec7/image.jpeg)

### 해시 조인
해시 조인(hash join)은 MySQL 8.0.18 버전부터 지원되는 조인 방식이다.

조인에 참여하는 각 테이블의 데이터를 내부적으로 해시값으로 만들어 내부 조인을 수행한다. 해시값으로 내부 조인을 수행한 결과는 조인 버퍼에 저장되므로 조인 열의 인덱스를 필수로 요구하지 않아도 된다.

![](https://velog.velcdn.com/images/songs4805/post/1a01dca8-7c87-4476-9cf0-0c51fde1b970/image.jpeg)

이와 같은 해시 조인은 보통 대용량 데이터의 동등 비교 연산에서 확인할 수 있으나, 아직은 MySQL/MariaDB에서 핵심적인 조인 알고리즘으로 처리되지 못하는게 현실이다.