# 8장. 경계 간 매핑하기
각 계층의 모델을 매핑하는 것에 대해 다양한 논쟁이 있다.

- 매핑에 찬성하는 개발자: 두 계층 간에 매핑을 하지 않으면 양 계층에서 같은 모델을 사용해야 하는데 이렇게 하면 두 계층이 강하게 결합된다.
- 매핑에 반대하는 개발자: 두 계층 간에 매핑을 하게 되면 보일러플레이트 코드를 너무 많이 만들게 된다. 많은 유스케이스들이 오직 CRUD만 수행하고 계층에 걸쳐 같은 모델을 사용하기 때문에 계층 사이의 매핑은 과하다.

## '매핑하지 않기' 전략


웹 계층에선 웹 컨트롤러가 `SendMoneyUseCase` 인터페이스를 호출해서 유스케이스를 실행한다. 이 인터페이스는 `Account`를 인자로 가진다. 즉, 웹 계층과 애플리케이션 계층 모두 `Account` 클래스에 접근해야 한다는 것을 의미한다. (두 계층이 같은 모델을 사용함)  
반대쪽의 영속성 계층과 애플리케이션 계층도 같은 관계다.

계층별 모델 클래스에 특별한 요구사항이 있을 수 있다. 웹 계층에서 REST로 모델을 노출시켰다면 모델을 JSON으로 직렬화하기 위한 애너테이션을 특정 필드에 추가할 수 있다. ORM 프레임워크를 사용한다면 데이터베이스 매핑을 위한 특정 애너테이션이 필요할 것이다.

도메인과 애플리케이션 계층은 웹이나 영속성과 관련된 특수한 요구사항에 관심이 없음에도 불구하고 `Account` 도메인 모델 클래스는 이런 모든 요구사항을 다뤄야 한다. 결과적으로 `Account` 클래스는 웹, 애플리케이션, 영속성 계층과 관련된 이유로 인해 변경돼야 하므로 **단일 책임 원칙**을 위반한다.

모든 계층이 정확히 같은 구조의, 정확히 같은 정보를 필요로 한다면 '매핑하지 않기' 전략은 완벽한 전략이다.

그러나, 애플리케이션 계층이나 도메인 계층에서 웹과 영속성 문제를 다루게 되면 곧바로 다른 전략을 취해야 한다.

저자의 경험에 의하면 시간이 흐르면서 간단한 CRUD 유스케이스가 값비싼 매핑 전략이 필요한 비즈니스 유스케이스로 바뀌어 갈 수 있다고 한다.

## '양방향' 매핑 전략

각 계층은 도메인 모델과는 완전히 다른 구조의 전용 모델을 가지고 있다. 웹 계층에선 웹 모델을 인커밍 포트에서 필요한 도메인 모델로 매핑하고, 인커밍 포트에 의해 반환된 도메인 객체를 다시 웹 모델로 매핑한다. 영속성 계층은 아웃고잉 포트가 사용하는 도메인 모델과 영속성 모델 간의 매핑과 유사한 매핑을 담당한다.

두 계층 모두 양방향으로 매핑하기 때문에 '양방향' 매핑이라 한다.

장점은 다음과 같다.

- 각 계층이 전용 모델을 가지고 있다
- 각 계층이 전용 모델을 변경하더라도 다른 계층에 영향이 없다
- 웹 모델 데이터 표현에 최적화
- 도메인 모델은 유스케이스를 잘 구현할 수 있는 구조
- 영속성 모델은 데이터베이스에 객체를 저장하기 위해 ORM이 필요로 하는 구조
- 단일 책임 원칙을 만족한다
- 매핑하지 않기 전략 다음으로 간단한 전략

한편, 단점은 다음과 같다.

- 너무 많은 보일러 플레이트 코드 생성
- 프레임워크의 도움을 받아도 매핑코드 구현하는데 시간이 걸린다
- 프레임워크가 제네릭 코드와 리플렉션 뒤로 숨길 경우 디버깅에 어려움
- 도메인 모델이 계층 경계를 넘어 통신하는데 사용
- 인커밍 포트와 아웃고잉 포트는 도메인 객체를 입력 파라미터와 반환값으로 사용한다
- 도메인 모델이 바깥 계층의 요구에 따른 변경에 취약

완벽하게 들어맞는 매핑 전략은 없다. 이를 무조건 지켜야하는 법칙으로 여긴다면 상황에 따라 개발 진행속도를 더디게 만든다.

## '완전' 매핑 전략


이 매핑 전략에선 **각 연산마다** 별도의 입출력 모델을 사용한다. 계층 경계를 넘어 통신 할 때 도메인 모델을 사용하는 대신 `SendMoneyUseCase` 포트의 입력 모델로 동작하는 `SendMoneyCommand`처럼 각 작업에 특화된 모델을 사용한다. 이런 모델을 가리켜 `command`, `request` 혹은 이와 비슷한 단어로 표현한다.

웹 계층은 입력을 애플리케이션 계층의 커맨드 객체로 매핑할 책임을 가지고 있다. 각 유스케이스는 전용 필드와 유효성 검증 로직을 가진 전용 커맨드를 가진다.

애플리케이션 계층은 커맨드 객체를 유스케이스에 따라 도메인 모델을 변경하기 위해 필요한 무엇인가로 매핑할 책임을 가진다. 한 계층을 다른 여러 개의 커맨드로 매핑하는 데는 하나의 웹 모델과 도메인 모델 간의 매핑보다 더 많은 코드가 필요하다. 하지만 이렇게 매핑하면 여러 유스케이스의 요구사항을 함께 다뤄야 하는 매핑에 비해 구현하고 유지보수하기가 훨씬 쉽다.

이 매핑 전략을 전역 패턴으로 추천하진 않고, 웹 계층과 애플리케이션 계층 사이에서 상태 변경 유스케이스의 경계를 명확하게 할 때 가장 빛을 발한다. 애플리케이션 계층과 영속성 계층 사이에선 매핑 오버헤드 때문에 사용하지 않는 것이 좋다.

매핑 전략은 여러 가지를 섞어쓸 수 있고, 섞어 써야만 한다. 어떤 매핑 전략도 모든 계층에 걸쳐 전역 규칙일 필요가 없다.

## '단방향' 매핑 전략

이 전략에선 모든 계층의 모델들이 같은 인터페이스를 구현한다. 이 인터페이슨느 관련 있는 특성(attribute)에 대한 getter를 제공해서 도메인 모델의 상태를 캡슐화 한다.

장점은 다음과 같다.

- 풍부한 행동이 있는 도메인 모델
- 애플리케이션 계층 내의 서비스에서 행동에 접근할 수 있다
- 바깥 계층으로 전달 시 매핑 없어 가능
  - 도메인 객체가 인커밍/아웃고잉 포트가 기대하는 대로 상태 인터페이스를 구현하고 있기 때문

바깥 계층에선 상태 인터페이스를 이용할지, 계층 전용 모델로 매핑해야 할지 결정할 수 있다. 행동을 변경하는 것이 상태 인터페이스에 의해 노출돼 있지 않기 때문에 실수로 도메인 객체의 상태를 변경하는 일은 발생하지 않는다.

애플리케이션 계층에선 이 객체를 실제 도메인 모델로 매핑해서 도메인 모델의 행동에 접근할 수 있게 된다. 이 매핑은 factory라는 DDD 개념과 잘 어울린다.

> factory: 어떤 특정한 상태로부터 도메인 객체를 재구성할 책임을 가지고 있다.

이 전략은 계층 간의 모델이 비슷할 때 가장 효과적이다. 예시로 읽기 전용 연산의 경우 상태 인터페이스가 필요한 모든 정보를 제공하기 때문에 웹 계층에서 전용 모델로 매핑할 필요가 전혀 없다.

## 언제 어떤 매핑 전략을 사용할 것인가?
이 질문의 답은 '그때그때 다르다'이다.

각 매핑 전략이 저마다 장단점을 갖고 있기 때문에 한 전략을 전체 코드에 대한 어떤 경우에도 변하지 않는 전역 규칙으로 정의하려는 충동을 이겨내야 한다. 소프트웨어는 시간이 지나며 변화를 거듭하기 때문에, 언제든 매핑 전략이 변경될 수 있다. 팀 내에서 상황에 따른 매핑 전략 가이드라인이 필요하다. 가이드라인을 성공적으로 적용하려면 팀원들이 이를 숙지하고 있어야 한다. 팀 차원에선 이를 지속적으로 논의하고 수정해야 한다.

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
각 유스케이스에 대해 좁은 포트를 사용하면 유스케이스마다 다른 매핑 전략을 사용할 수 있고, 다른 유스케이스에 영향을 미치지 않으면서 코드를 개선할 수 있기 때문에 특정 상황, 특정 시점에 최선의 전략을 선택할 수 있다.

상황별로 매핑 전략을 선택하는 것은 모든 상황에 같은 매핑 전략을 사용하는 것보다 분명 더 어렵고 더 많은 커뮤니케이션을 필요로 하겠지만 매핑 가이드라인이 있는 한, 코드가 정확히 해야 하는 일만 수행하면서도 더 유지보수하기 쉬운 코드로 팀에 보상이 되어 돌아올 것이다.