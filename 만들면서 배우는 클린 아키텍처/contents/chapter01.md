# 1장. 계층형 아키텍처의 문제는 무엇일까?
일반적인 웹 애플리케이션의 계층형 아키텍처는 다음과 같다.

<p align="center">
  <img src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/d8066fe5-23cc-4eb8-81cf-049a152365f5">
</p>

사실 계층형 아키텍처는 견고한 아키텍처 패턴이다. 계층을 잘 이해하고 구성한다면 웹 계층이나 영속성 계층에 독립적으로 도메인 로직을 작성할 수 있다. 원한다면 도메인 로직에 영향을 주지 않고 웹 계층과 영속성 계층에 사용된 기술을 변경할 수 있다. 기존 기능에 영향을 주지 않고 새로운 기능을 추가할 수도 있다.

잘 만들어진 계층형 아키텍처는 선택의 폭을 넓히고, 변화하는 요구사항과 외부 요인에 빠르게 적을할 수 있게 해준다.

## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다
정의에 따르면 전통적인 계층형 아키텍처의 토대는 데이터베이스다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/b6c6a4c5-7e13-4039-ad4a-d99e819b4b31)

웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 자연스레 데이터베이스에 의존하게 된다. 모든 것이 영속성 계층을 토대로 만들어진다. 이런 방식은 다양한 이유로 문제를 초래한다.

비즈니스 관점에선 상태(state)가 아니라 행동(behavior)을 중심으로 모델링한다. 다른 무엇보다도 도메인 로직을 먼저 만들어야 한다. 하지만, 우리는 대체로 도메인 로직이 아닌 데이터베이스를 토대로 아키텍처를 만들고 있다. 그렇기에 DB 모델링 → 도메인 로직의 순서로 개발했을 것이다.

데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM 프레임워크를 사용하기 때문이다.

ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 둔다. 계층은 아래 방향으로만 접근 가능하기 때문에 도메인 계층에선 이러한 엔티티에 접근할 수 있다. 하지만 이렇게 되면 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다. 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인해 도메인 로직뿐만 아니라 eager loading/lazy loading, 데이터베이스 트랜잭션, 캐시 플러시 등 영속성 계층과 관련된 작업들을 해야만 한다.

영속성 코드가 사실상 도메인 코드에 녹아들어가서 둘 중 하나만 바꾸는 것이 어려워진다. 이는 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 정확히 반대되는 상황이다.

## 지름길을 택하기 쉬워진다
전통적인 계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은, 특정한 계층에선 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다는 것이다. 만약 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 컴포넌트를 계층 아래로 내려버리면 된다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/fee9f5d9-8f67-4e46-9cbe-87a413855831)

영속성 계층은 수년에 걸친 개발과 유지보수로 결국 위 그림과 같이 될 확률이 높다. 영속성 계층은 컴포넌트를 아래 계층으로 내릴수록 비대해진다. 어떤 계층에도 속하지 않는 것처럼 보이는 헬퍼 컴포넌트나 유틸리티 컴포넌트들이 이처럼 아래 계층으로 내릴 가능성이 큰 후보다.

## 테스트하기 어려워진다
계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 **계층을 건너뛰는 것이다.** 엔티티의 필드를 단 하나만 조작하면 되는 경우에 웹 계층에서 바로 영속성 계층에 접근하려는 생각을 가진 사람이 나타날 수 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/2d11a0bd-3b48-4912-b65a-9472c7441704)

이에 따른 문제점은 다음과 같다.
- 도메인 로직을 웹 계층에 구현하게 된다. 유스케이스가 확장된다면 더 많은 도메인 로직을 웹 계층에 추가해서 애플리케이션 전반에 걸쳐 책임이 섞이고 핵심 도메인 로직들이 퍼져나갈 확률이 높다.
- 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 mocking해야 한다. 결과적으로 단위 테스트의 복잡도가 올라간다.

## 유스케이스를 숨긴다
기능을 추가하거나 변경할 적절한 위치를 찾는 일이 빈번하기 때문에 아키텍처는 코드를 빠르게 탐색하는 데 도움이 돼야 한다. 계층형 아키텍처 상의 규칙 위반이 수 차례 발생한다면, 기능을 추가하거나 변경할 때 적절한 위치를 찾기 어려워 많은 시간이 소모될 것이다.

계층형 아키텍처는 도메인 서비스의 '너비'에 관한 규칙을 강제하지 않는다. 따라서 제품의 볼륨이 커짐에 따라 '너비'가 넓은 서비스가 만들어질 수 있다. 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다. 그럼 서비스를 테스트하기도 어려워지고 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.

## 동시 작업이 어려워진다
여러 명의 개발자가 하나의 유스케이스에 매달려 작업한다 가정해보면 계층형 아키텍처에선 보편적으로 영속성 계층이 우선 개발되어야 하고 그에 따른 도메인 계층, 사용자 요청을 처리하는 웹 계층 순으로 개발이 되어야 하기 때문에 데이터베이스 주도 설계로 개발된 보편적인 프로젝트에선 개발자 수와 개발속도가 비례하진 않는다.

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
계층형 아키텍처로 만들든 다른 아키텍처 스타일로 만들든, 계층형 아키텍처의 함정을 염두에 두면 지름길을 택하지 않고 유지보수하기에 더 쉬운 솔루션을 만드는 데 도움이 될 것이다.