# Chapter 3. 관찰 가능성과 디버깅
- 관찰 가능성 신호는 신호가 지닌 가치에 따라 가용성에 기여하는 부류와 디버그 가능성을 높이는 부류로 나눈다.
  - 잘 집계된 애플리케이션 메트릭은 가장 유용한 가용성 신호
  - 분산 추적과 로그는 디버깅 가능성 신호

## 관찰 가능성의 세 주축과 두 분류
관찰 가능성은 **로그, 분산 추적, 메트릭**을 주축으로 형성된다. 각자 고유한 특성을 지닌 텔레메트리 형태지만 용도는 크게 가용성 증명 또는 근원 식별 디버깅으로 나뉜다.

- 텔레메트리 데이터는 계속 쌓인다. 어떤식으로든 용량을 줄이지 않으면 그에 따라 데이터 유지 비용도 증가한다. → 텔레메트리 데이터를 감소시킬 전략이 필요하다.
  - 집계 : 모든 측정 결과를 집계해 통계를 미리 계산한다.
    - 요청 수준에서 세분성을 희생시키는 방식으로 표현을 압축한다.
  - 샘플링 : 일부 측정 결과만 선택적으로 유지한다.
    - 요청 수준 세분성을 유지한 채 시스템 성능에 대한 전지적 조망 능력을 희생시킨다.
  - 처리량이 매우 적은 시스템이 아닌 한, 요청 수준 세분화와 완전한 표현성을 둘 다 유지하기엔 비용이 너무 많이든다.

**디버깅과 관찰 가능성 도구를 통해 특정 정보의 완전한 세분성을 유지하는 것이 핵심이다.**

- 메트릭이 도출한 가용성 신호는 문제 지점을 가리킨다. 데이터를 차원적으로 탐색하면 문제의 근본 원인을 식별할 수 있다.
  - 인스턴스에 따라 신호를 분리하면 문제가 발생한 인스턴스가 드러난다.
  - 가끔 전지역적인 장애가 발생하거나 특정 애플리케이션 버전이 문제를 일으킨다.
- 분산 추적이나 로그는 패턴이 뚜렷하게 보이지 않는 문제의 근본적 원인을 식별하는 핵심 열쇠가 된다.

이벤트 수준 텔레메트리로 로그를 남기고 추적하면 디버깅이 원활해지고, 메트릭을 관찰하면 가용성을 입증할 수 있다.

### 로그
- 모든 소프트웨어 스택에 존재한다. 최종적인 저장 위치나 구조에 관계없이 공통적으로 보이는 뚜렷한 특징이 있다.
- 로그의 양은 시스템 처리량에 비례한다.
  - 로그로 측정하는 코드 실행 경로가 많을수록 더 많은 로그 데이터가 발행된다. 샘플링한다 해도 이 비례 관계는 변함이 없다.
- 로그 콘텍스트 영역은 하나의 이벤트에 해당한다.
  - 로그 데이터는 특정 상호작용의 실행 콘텍스트를 제공한다.
  - 개별 로그 이벤트를 집계해 시스템의 전반적인 성능을 추론할 때 로그 집계는 사실상 메트릭의 역할을 한다.
- 로그의 존재 의의는 명백히 디버깅에 있다. 정교한 로그 분석 패키지는 로그 집계 과정을 거쳐 시스템의 가용성을 도출한다.
- 로그 데이터를 유지하고, 지속적으로 집계하고, 작업 페이로드를 할당하면 그에 상응하는 비용이 발생한다.

### 분산 추적
- 원격 추적 로그는 실행 단위로 기록하지만 한편으로 시스템 각 부분에 일어나는 개별 이벤트를 인과적으로 연결하는 특성이 있다.
- 분산 추적 시스템은 사용자와 시스템 사이의 상호 작용을 시작점으로 끝점까지 관찰한다.
- 특정 요청이 성능 저하를 발생시키면 엔드투엔드 추적 관찰을 통해 시스템의 어느 부분이 저하되었는지 확인할 수 있다.
- 원격 추적은 일반적인 로그보다 샘플링 비율이 더 높다. 그러나 추적 데이터 역시 로그 데이터처럼 시스템 처리량에 비례해 저장 용량이 늘어난다.
- 분산 추적이 특히 빛을 발하는 문제 상황은, 전체 시스템이 평상시보다 느려졌지만 신속하게 최적화시킬 요처를 지목할 수 없을 때다.
- 대규모 마이크로서비스 집합을 운영하는 조직은 분산 추적의 도움을 받아 서비스 그래프(서비스 간 종속성)를 이해하고 특정 요청의 처리 과정을 분석할 수 있다.
- 분산 추적은 본질적으로 이벤트 기반으로 작동하므로 디버깅 신호 역할에 적격이다. 그러나 서비스 간 관계 콘텍스트를 전달하는 중요한 역할도 수행한다.

### 메트릭
- 로그와 분산 추적은 메트릭들보다 서로 더 비슷한 면이 있다. 비용을 제어하기 위해 샘플링된다는 점이다.
- 메트릭은 개별적인 상호작용의 정보를 얻기보다는 주로 서비스 수준 지표(SLI)를 이해하는 용도로 쓰이며 전체적으로 집계된 결과를 나타낸다.
- 기존 시스템에 메트릭 측정을 탑재하려면 부분적으로 수작업이 필요하다. 그 외에는 공통 프레임워크와 라이브러리가 기본적으로 제공하는 측정 기능을 활용하면 된다.
- 메트릭 SLI는 서비스 수준 목표가 달성되는지 확인하기 위해 의도적으로 수집하는 지표들이다. 가용성 증명에 활용하기 적합하다.

### 어떤 텔레메트리 방식을 선택할까?
- 추적과 로깅이 모두 디버깅 신호라면 둘 다 사용할 필요가 있을까 싶지만 둘은 엄연히 다르다.
  - 각각의 조회, 검색 요건이 동등하다면 태그와 메타데이터가 포함된 추적 신호가 로그보다 우월하다.
  - 추적은 호출 체인을 연결하는 콘텍스트 정보를 제공하며 전파한다.
- 추적은 메트릭 타이머가 존재하는 모든 위치에 탑재할 수 있다. 그러나 분산 추적은 오로지 실행만 측정한다는 점을 유념하자.
- 실행 시간 측정 시 메트릭과 추적 도구는 서로를 보완하므로 둘 다 사용해도 좋다.
  - 메트릭은 코드 조각의 모든 실행 결과를 집계해 보여주며, 분산 추적은 개별 실행 결과의 샘플 예시를 제공한다.
  - 메트릭은 여기에 더해 카운트와 게이지도 측정한다. 이 부분은 추적으로 완전히 대체할 수 없다.

```
com.mongodb.MongoSocketOpenException: Exception opening socket
  at c.m.c.SocketStream.open(SocketStream.java:63)
  ...
```

- 메트릭, 로깅 가능, 추적 제외  
→ MongoDB 소켓 연결 시도는 메트릭으로 시간을 측정하기 쉽다.`exception=ConnectionException` 같은 예외 요약 태그와 성공/실패 태그를 조합하면 더욱 유용하다. 전체 스택을 추적하지 않아도 요약 태그만으로 충분히 문제를 이해할 수 있으며 그렇지 않은 경우에는 스택 트레이스 로그를 쓰면 된다.  
예를 들어, 요약 태그가 `exception=NullPointerException` 이라면 모니터링 시스템이 이러한 예외를 그룹으로 묶고 경고를 보내도록 한다. 그 후 스택 트레이스 로그를 조사하면 문제를 쉽게 식별할 수 있다.

```
:57:13 main INFO c.m.PaymentsController - [GET] Payment 123456 retrieved in 37ms.
```
- 추적, 메트릭 가능, 로깅 제외  
→ 지불 기능에 대한 정보를 남기는 이 로그는 완전히 제거해도 좋다. 메트릭과 분산 추적을 도입하면 지불 기능에 관련된 주요 정보가 모두 수집된다. 개별 지불의 선별적 정보뿐만 아니라 모든 지불 정보를 취합해 추론할 수 있다. 가령 지불 기능이 대부분 40ms 안에 완료되고 가끔 이보다 수십 배 느린 요청이 발생한다고 가정하자. 메트릭을 쓰면 이러한 상황을 한눈에 파악할 수 있다.

```
:58:00 main INFO c.m.PaymentsController - Payment near cache contains 2 entries.
```

- 메트릭 가능, 추적, 로깅 제외  
→ 빈번하게 수행되는 지불 기능의 near 캐시는 게이지 메트릭으로 엄밀하게 모니터링할 수 있다. 게이지 기능은 추적으로 대체할 수 없으며 로그 기록은 게이지 측정과 중복된다.

추적은 로깅보다 우선시되어야 한다. 수집하는 정보는 같지만 콘텍스트가 더 풍부하기 때문이다. 시스템의 정상 작동 여부부터 판단해야 하므로 추적과 메트릭의 역할이 겹칠 때는 메트릭으로 시작한다. 텔레메트리로 문제를 해결하는 것은 그 다음이다. 추적은 메트릭 측정이 탑재된 위치에서 시작한다. 메트릭 태그의 상위 집합을 추적에 적용하면 추적 정보의 가치를 더 높일 수 있다.

## 분산 추적 컴포넌트
