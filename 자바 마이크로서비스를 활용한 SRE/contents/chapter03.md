# Chapter 3. 관찰 가능성과 디버깅
- 관찰 가능성 신호는 신호가 지닌 가치에 따라 가용성에 기여하는 부류와 디버그 가능성을 높이는 부류로 나눈다.
  - 잘 집계된 애플리케이션 메트릭은 가장 유용한 가용성 신호
  - 분산 추적과 로그는 디버깅 가능성 신호

## 관찰 가능성의 세 주축과 두 분류
관찰 가능성은 **로그, 분산 추적, 메트릭**을 주축으로 형성된다. 각자 고유한 특성을 지닌 텔레메트리 형태지만 용도는 크게 가용성 증명 또는 근원 식별 디버깅으로 나뉜다.

- 텔레메트리 데이터는 계속 쌓인다. 어떤식으로든 용량을 줄이지 않으면 그에 따라 데이터 유지 비용도 증가한다. → 텔레메트리 데이터를 감소시킬 전략이 필요하다.
  - 집계 : 모든 측정 결과를 집계해 통계를 미리 계산한다.
    - 요청 수준에서 세분성을 희생시키는 방식으로 표현을 압축한다.
  - 샘플링 : 일부 측정 결과만 선택적으로 유지한다.
    - 요청 수준 세분성을 유지한 채 시스템 성능에 대한 전지적 조망 능력을 희생시킨다.
  - 처리량이 매우 적은 시스템이 아닌 한, 요청 수준 세분화와 완전한 표현성을 둘 다 유지하기엔 비용이 너무 많이든다.

**디버깅과 관찰 가능성 도구를 통해 특정 정보의 완전한 세분성을 유지하는 것이 핵심이다.**

- 메트릭이 도출한 가용성 신호는 문제 지점을 가리킨다. 데이터를 차원적으로 탐색하면 문제의 근본 원인을 식별할 수 있다.
  - 인스턴스에 따라 신호를 분리하면 문제가 발생한 인스턴스가 드러난다.
  - 가끔 전지역적인 장애가 발생하거나 특정 애플리케이션 버전이 문제를 일으킨다.
- 분산 추적이나 로그는 패턴이 뚜렷하게 보이지 않는 문제의 근본적 원인을 식별하는 핵심 열쇠가 된다.

이벤트 수준 텔레메트리로 로그를 남기고 추적하면 디버깅이 원활해지고, 메트릭을 관찰하면 가용성을 입증할 수 있다.

### 로그
- 모든 소프트웨어 스택에 존재한다. 최종적인 저장 위치나 구조에 관계없이 공통적으로 보이는 뚜렷한 특징이 있다.
- 로그의 양은 시스템 처리량에 비례한다.
  - 로그로 측정하는 코드 실행 경로가 많을수록 더 많은 로그 데이터가 발행된다. 샘플링한다 해도 이 비례 관계는 변함이 없다.
- 로그 콘텍스트 영역은 하나의 이벤트에 해당한다.
  - 로그 데이터는 특정 상호작용의 실행 콘텍스트를 제공한다.
  - 개별 로그 이벤트를 집계해 시스템의 전반적인 성능을 추론할 때 로그 집계는 사실상 메트릭의 역할을 한다.
- 로그의 존재 의의는 명백히 디버깅에 있다. 정교한 로그 분석 패키지는 로그 집계 과정을 거쳐 시스템의 가용성을 도출한다.
- 로그 데이터를 유지하고, 지속적으로 집계하고, 작업 페이로드를 할당하면 그에 상응하는 비용이 발생한다.

### 분산 추적
- 원격 추적 로그는 실행 단위로 기록하지만 한편으로 시스템 각 부분에 일어나는 개별 이벤트를 인과적으로 연결하는 특성이 있다.
- 분산 추적 시스템은 사용자와 시스템 사이의 상호 작용을 시작점으로 끝점까지 관찰한다.
- 특정 요청이 성능 저하를 발생시키면 엔드투엔드 추적 관찰을 통해 시스템의 어느 부분이 저하되었는지 확인할 수 있다.
- 원격 추적은 일반적인 로그보다 샘플링 비율이 더 높다. 그러나 추적 데이터 역시 로그 데이터처럼 시스템 처리량에 비례해 저장 용량이 늘어난다.
- 분산 추적이 특히 빛을 발하는 문제 상황은, 전체 시스템이 평상시보다 느려졌지만 신속하게 최적화시킬 요처를 지목할 수 없을 때다.
- 대규모 마이크로서비스 집합을 운영하는 조직은 분산 추적의 도움을 받아 서비스 그래프(서비스 간 종속성)를 이해하고 특정 요청의 처리 과정을 분석할 수 있다.
- 분산 추적은 본질적으로 이벤트 기반으로 작동하므로 디버깅 신호 역할에 적격이다. 그러나 서비스 간 관계 콘텍스트를 전달하는 중요한 역할도 수행한다.

### 메트릭
- 로그와 분산 추적은 메트릭들보다 서로 더 비슷한 면이 있다. 비용을 제어하기 위해 샘플링된다는 점이다.
- 메트릭은 개별적인 상호작용의 정보를 얻기보다는 주로 서비스 수준 지표(SLI)를 이해하는 용도로 쓰이며 전체적으로 집계된 결과를 나타낸다.
- 기존 시스템에 메트릭 측정을 탑재하려면 부분적으로 수작업이 필요하다. 그 외에는 공통 프레임워크와 라이브러리가 기본적으로 제공하는 측정 기능을 활용하면 된다.
- 메트릭 SLI는 서비스 수준 목표가 달성되는지 확인하기 위해 의도적으로 수집하는 지표들이다. 가용성 증명에 활용하기 적합하다.

### 어떤 텔레메트리 방식을 선택할까?
- 추적과 로깅이 모두 디버깅 신호라면 둘 다 사용할 필요가 있을까 싶지만 둘은 엄연히 다르다.
  - 각각의 조회, 검색 요건이 동등하다면 태그와 메타데이터가 포함된 추적 신호가 로그보다 우월하다.
  - 추적은 호출 체인을 연결하는 콘텍스트 정보를 제공하며 전파한다.
- 추적은 메트릭 타이머가 존재하는 모든 위치에 탑재할 수 있다. 그러나 분산 추적은 오로지 실행만 측정한다는 점을 유념하자.
- 실행 시간 측정 시 메트릭과 추적 도구는 서로를 보완하므로 둘 다 사용해도 좋다.
  - 메트릭은 코드 조각의 모든 실행 결과를 집계해 보여주며, 분산 추적은 개별 실행 결과의 샘플 예시를 제공한다.
  - 메트릭은 여기에 더해 카운트와 게이지도 측정한다. 이 부분은 추적으로 완전히 대체할 수 없다.

```
com.mongodb.MongoSocketOpenException: Exception opening socket
  at c.m.c.SocketStream.open(SocketStream.java:63)
  ...
```

- 메트릭, 로깅 가능, 추적 제외  
→ MongoDB 소켓 연결 시도는 메트릭으로 시간을 측정하기 쉽다.`exception=ConnectionException` 같은 예외 요약 태그와 성공/실패 태그를 조합하면 더욱 유용하다. 전체 스택을 추적하지 않아도 요약 태그만으로 충분히 문제를 이해할 수 있으며 그렇지 않은 경우에는 스택 트레이스 로그를 쓰면 된다.  
예를 들어, 요약 태그가 `exception=NullPointerException` 이라면 모니터링 시스템이 이러한 예외를 그룹으로 묶고 경고를 보내도록 한다. 그 후 스택 트레이스 로그를 조사하면 문제를 쉽게 식별할 수 있다.

```
:57:13 main INFO c.m.PaymentsController - [GET] Payment 123456 retrieved in 37ms.
```
- 추적, 메트릭 가능, 로깅 제외  
→ 지불 기능에 대한 정보를 남기는 이 로그는 완전히 제거해도 좋다. 메트릭과 분산 추적을 도입하면 지불 기능에 관련된 주요 정보가 모두 수집된다. 개별 지불의 선별적 정보뿐만 아니라 모든 지불 정보를 취합해 추론할 수 있다. 가령 지불 기능이 대부분 40ms 안에 완료되고 가끔 이보다 수십 배 느린 요청이 발생한다고 가정하자. 메트릭을 쓰면 이러한 상황을 한눈에 파악할 수 있다.

```
:58:00 main INFO c.m.PaymentsController - Payment near cache contains 2 entries.
```

- 메트릭 가능, 추적, 로깅 제외  
→ 빈번하게 수행되는 지불 기능의 near 캐시는 게이지 메트릭으로 엄밀하게 모니터링할 수 있다. 게이지 기능은 추적으로 대체할 수 없으며 로그 기록은 게이지 측정과 중복된다.

추적은 로깅보다 우선시되어야 한다. 수집하는 정보는 같지만 콘텍스트가 더 풍부하기 때문이다. 시스템의 정상 작동 여부부터 판단해야 하므로 추적과 메트릭의 역할이 겹칠 때는 메트릭으로 시작한다. 텔레메트리로 문제를 해결하는 것은 그 다음이다. 추적은 메트릭 측정이 탑재된 위치에서 시작한다. 메트릭 태그의 상위 집합을 추적에 적용하면 추적 정보의 가치를 더 높일 수 있다.

## 분산 추적 컴포넌트
전체 분산 추적은 개별 스팬의 집합이다. 스팬은 최종 사용자 요청을 만족시키는 각 접점의 성능 정보를 담는다. 이런 스팬 정보를 조합해 고드름 그래프를 생성하면 서비스별 상대 소요 시간을 한눈에 파악할 수 있다.

- 스팬은 메트릭처럼 이름과 키-값 태그 쌍을 함께 담는다.
- `https.server.requests` 추적 스팬은 클라우드 리전, API 엔드포인트, HTTP 메소드, 응답 상태 코드 등을 태그 정보로 식별할 수 있다.
- 메트릭과 추적명을 일관되게 유지하는 것이 텔레메트리의 상호 연관성을 유지하는 핵심 요소다.

태그 카디널리티는 분산 추적 시스템의 스토리지 비용이 아닌 **조회** 비용에 영향을 미친다. 추적 시스템은 백엔드에서 태그에 인덱싱 여부를 설정할 수 있으며 zipkin은 태그 자동완성 기능을 지원한다. → 인덱스 성능을 보장하기 위해 태그값 집합은 제한되어야 한다.

메트릭과 추적은 상호 연관성을 높일 수 있도록 최대한 태그를 중첩시켜야 한다.

|메트릭 태그 키|추적 태그 키|값|
|--|--|--|
|application|application|payments|
|method|method|GET|
|status|status|200|
|uri|uri|`/api/payment/{paymentId}`|
|uri|detailedUri|`/api/payment/abc123`|
|uri|user|user123456|

추적은 요청의 엔드투엔드 성능에 대한 통찰을 얻고자 고안됐다. 특정 매개변수에 맞추어 추적 검색 결과의 범위를 좁히면 전체적인 엔드투엔드 성능 분포는 한눈에 보기 어려워진다.

## 분산 추적 유형
추적은 인프라 계층에서 시작해 애플리케이션의 개별 컴포넌트에 이르기까지 다양한 아키텍처 수준에서 두루 사용할 수 있다.

- 수동 추적
  - Opentelemetry 라이브러리는 코드를 통해 명시적으로 애플리케이션을 측정하는 도구다.
- 에이전트 추적
  - 에이전트는 통상적으로 업체가 제공하며 코드를 고치지 않아도 바로 작동한다.
  - 그러나 애플리케이션 CD Pipeline에 탑재해야 하므로 복잡도를 증가시킨다.
- 프레임워크 추적
  - 프레임워크가 자동으로 제공하는 측정 접점에 사용자 설정을 더하면 화이트박스에 가까운 측정 형태가 된다.
- 서비스 메시 추적
  - 서비스 메시는 애플리케이션 코드 외부에 존재하는 인프라 계층이며 마이크로서비스 사이의 상호작용을 관리한다.
  - 상당수는 사이드카 프록시를 통해 애플리케이션 프로세스를 다루는 방식으로 구현된다.
  - 서비스 메시는 상태 코드 정보만 얻는다. (프레임워크 추적에 비해 덜 상세함.)
- 혼성 추적

## 샘플링
일반적으로 추적 데이터 비용을 제어하려면 샘플링이 필요하다.

메트릭이 비정상적인 상황을 경고하면 추적을 통해 심층적인 디버깅을 수행할 수 있다. 짝을 이루면 이렇게 문제될 것이 없다.

### 전수 유지
```java
@Bean
public Sampler defaultSampler() {
  return Sampler.ALWAYS_SAMPLE;
}
```

### 비율 제한 샘플링

```yaml
spring:
  sleuth:
    sampler:
      rate: 2000
```

- 초당 최초 2000개 샘플을 유지하는 스프링 클라우드 슬루스 설정
- 스프링 클라우드 슬루스는 매초 처음 10개 샘플을 유지하고 이후의 추적 데이터는 확률적으로 다운샘플링한다.

메트릭 텔레메트리도 대규모 측정 환경에서 활용할 수 있으며 되도록이면 새로운 분산 통계 시스템을 만들지 말자.

비율 기반 샘플링에 주어진 해결 과제는 공극이다. 마이크로서비스 호출이 연쇄적으로 발생할 때 각 호출의 추적 데이터 유지 여부는 독립적으로 결정된다. 따라서 한 요청의 엔드투엔드 흐름을 전체적으로 조망하면 중간에 추적 데이터가 비어있는 공간이 생긴다. 다르게 표현하자면, 비율 기반 샘플링은 **하나의 추적 ID에 대해 샘플링 비율을 일관적으로 유지하지 않는다.** 개별 하위 시스템이 샘플링 비율 임계점에 도달하는 순간, 이 시스템이 포함된 추적 과정에 공극이 발생한다.

비율 기반 샘플링의 용량 계획을 수립할 때는 이러한 비율이 **인스턴스 단위**로 결정된다는 점에 주의하자.
- 추적 시스템에 도달하는 샘플 비율 = 클러스터의 인스턴수 수 * 가장 낮은 샘플링 비율

### 확률 샘플링
100개의 추적 데이터 중 몇 개를 유지할지를 결정.

```yaml
spring:
  sleuth:
    sampler:
      probability: 0.1
```