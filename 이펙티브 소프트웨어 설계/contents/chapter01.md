# 1장. 도입
코드, API, 시스템 아키텍처를 설계할 때 유지보수, 성능, 확장성을 비롯해 다양한 요소에 영향을 미치는 결정을 내릴 필요가 았다. 한쪽으로 가기로 한 결정은 십중팔구 다른 쪽으로 진화하는 가능성을 제약한다.

상황, 출시 시점, 서비스 수준 협약(SLA), 기타 다른 요소에 따라 팀은 이런 어려운 결정을 내릴 필요가 있다.

## 모든 결정과 패턴의 결과
### 단위 테스트 결정 사항
```kotlin
class SystemComponent {
  fun publicApiMethod(): Int = privateApiMethod()

  private fun privateApiMethod(): Int = complexCalculations()

  private fun complexCalculations(): Int {
    // 몇 가지 복잡한 로직
    return 0
  }
}
```

- `complexCalculations()`를 단위 테스트에 넣을지? `private`을 사용해 비공개로 유지할지?
- 단위 테스트는 공개 API만을 다루는 블랙박스 테스트다.
- 종종 비공개 메서드에도 단위 테스트를 수행할 가치가 있는 복잡한 로직이 존재한다.
  - 가시성을 조정한다.

```kotlin
@VisibleForTesting
fun complexCalculations(): Int {
  // 몇 가지 복잡한 로직
  return 0
}
```

- API의 공개 메서드를 호출하지 못하게 호출자를 막는 방어책은 없다.
- 호출자가 애노테이션을 인식하지 못한다면 이런 암묵적인 제약을 무시할지도 모른다.
- 유연성 vs 유지보수 비용?

### 단위 테스트와 통합 테스트의 비율
- 단위 테스트나 통합 테스트 모두 장단점이 있으며, 코드를 작성할 때 직면하는 전형적인 트레이드오프가 발생한다.
- 단위 테스트는 더 빠르게 수행되며 더 빠른 피드백이 가능하므로 디버깅 과정이 종종 더 빨라진다.
- 시스템에 통합 테스트가 없으면 컴포넌트 사이의 연결과 통합 방식에 대해 추론할 수가 없다.
- 현실 세계에서 코드는 단위 테스트와 통합 테스트를 섞어 놓은 형태가 돼야 한다.
- 테스트를 만들기 위해 요구되는 시간을 고려해야 하지만, 요즘은... AI 도구들 때문에...
- 단위 테스트는 격리되어 돌아가므로 우리 시스템에서 다른 컴포넌트와 관련된 다양한 정보는 물론이고 여러 컴포넌트 사이의 상호 작용 방식에 대한 정보도 제공하지 못한다.
- 통합 테스트는 더 많은 컴포넌트와 그들 사이의 상호 작용을 검증하려 시도하지만, 종종 주어진 비즈니스 기능을 제공하는 여러 서비스로 확장되지 못한다.
- 종단간 테스트는 시스템을 총체적으로 검증함에도 불구하고 마이크로서비스 N개, DB, 큐와 같은 모든 인프라스트럭처를 가동할 필요가 있어 테스트된 컴포넌트의 수가 상당히 많을 수 있다.

## 코드 디자인 패턴과 그것이 항상 동작하지 않는 이유
- 디자인 패턴은 더 나은 재사용 가능성과 확장성을 위해 패턴을 코드에 적용하는 방식을 강력하게 권장한다.
- 반면, 디자인 패턴을 조심해서 사용해야 하는 이유는 이런 패턴 구현이 컨텍스트에 크게 의존하기 때문이다.
- 싱글턴 패턴의 예시..
  - 모든 연산을 위해 동기화 기법 사용
  - DCL 사용
  - `ThreadLocal` 기반 스레드 한정 사용
  - 벤치마크 결과 멀티스레드 컨텍스트에서 어떤 선택을?

## 아키텍처 설계 패턴이 항상 동작하지는 않는 이유
- 확장성과 탄력성, 개발 속도 vs 구동 부분이 많이 포함된 복잡한 설계

## 정리
- 소프트웨어 개발 과정에서 유한한 시간이 주어질 때 단위 테스트 또는 통합 테스트를 다루는 설계 추이를 고려할 필요가 있다.
- 싱글턴과 같이 실전에서 증명된 저수준의 코드 설계 패턴은 애플리케이션의 컨텍스트에 따라 (eg. 스레드 안정성 관점에서) 좋은 설계 선택이 아닐 수 있다.
- 고수준 마이크로서비스 아키텍처가 모든 문제에 맞아떨어지지는 않으므로 아키텍처 설계 선택을 평가하기 위한 프레임워크가 필요하다.