# 4장. 트랜잭션 관리: 사가
MSA에서 단일 서비스 내부의 트랜잭션은 ACID가 보장하지만, 여러 서비스의 데이터를 업데이트하는 트랜잭션은 구현하기가 까다롭다. 사가(saga)라는 메시지 주도 방식의 로컬 트랜잭션을 사용해야 한다. 그런데 사가는 ACID에서 I가 빠진 ACD만 지원하고 격리가 되지 않기 때문에 동시 비정상의 영향을 방지하거나 줄일 수 있는 설계 기법을 적용해야 한다.

## 마이크로서비스 아키텍처에서의 트랜잭션 관리
Spring Framework로 단일 DB에 접근하는 모놀리식 애플리케이션을 개발했다면 `@Transactional` 만으로도 ACID가 자동으로 걸려 데이터의 일관성을 보장할 수 있다. 이에 따라 트랜잭션 관리는 어렵지 않다.  
하지만 다중 DB, 다중 메시지 브로커를 사용하는 모놀리식 애플리케이션이나, 자체 DB를 가진 여러 서비스로 구성된 마이크로서비스 아키텍처는 트랜잭션 관리가 어렵기에 좀 더 정교한 메커니즘이 필요하다.

### 분산 트랜잭션의 문제점
예전에는 분산 트랜잭션을 이용해 여러 서비스, DB, 메시지 브로커에 걸쳐 데이터 일관성을 유지했다. X/Open DTP 모델은 분산 트랜잭션 관리의 사실상 표준이다. XA는 2PC를 이용해 전체 트랜잭션 참여자가 반드시 커밋 아니면 롤백을 하도록 보장한다.  
하지만, NoSQL과 현대 매시지 브로커는 분산 트랜잭션을 지원하지 않으므로 최근 기술은 상당수 포기해야 한다. 게다가 동기 IPC 형태라서 가용성이 떨어지는 문제점도 있다. 분산 트랜잭션은 참여한 서비스가 모두 가동 중이어야 커밋할 수 있다. 요즘 아키텍트들은 일관성보다 가용성을 더 우선시하는 편이다.

MSA에서 데이터 일관성을 유지하려면, 느슨하게 결합된 비동기 서비스 개념을 토대로 뭔가 다른 매커니즘이 필요하다. 이것이 바로 사가다.

### 데이터 일관성 유지: 사가 패턴
**사가는 MSA에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 메커니즘이다.** 여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의한다. 사가는 일련의 로컬 트랜잭션이다.

시스템 작업은 사가의 첫 번째 단계를 시작한다. 어느 로컬 트랜잭션이 완료되면 이어서 그다음 로컬 트랜잭션이 실행된다. 여기서 사용하는 비동기 메시징은 하나 이상의 사가 참여자가 일시 불능 상태인 경우에도 사가의 전체 단계를 확실히 실행시킬 수 있는 중요한 장점이 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/660b6edc-3a05-446b-bf8a-1d40f605d61e)

사가와 ACID 트랜잭션은 두 가지 중요한 차이점이 있다.
- ACID 트랜잭션에 있는 격리성이 사가에는 없다.
- 사가는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백해야 한다.

ACID 트랜잭션은 비즈니스 로직 실행 도중 규칙에 위배되면 쉽게 롤백이 가능하다. DB에서 ROLLBACK하면 그 시점까지 변경된 내용은 모두 undo된다. 하지만 사가는 단계마다 로컬 DB에 변경분을 커밋하므로 자동 롤백은 불가능하다.

이를 위해 보상 트랜잭션을 미리 작성해야 한다. 사가는 트랜잭션이 진행하는 반대 방향으로 보상 트랜잭션을 실행한다. 모든 단계에 보상 트랜잭션이 필요한 것은 아니다. 읽기 전용 단계나, 항상 성공하는 단계 다음에 이어지는 단계는 보상 트랜잭션이 필요하지 않다.

사가는 다음 세 가지 트랜잭션으로 구성된다.
- 보상 가능 트랜잭션: 보상 트랜잭션으로 롤백 가능한 트랜잭션
- 피봇 트랜잭션: 사가의 진행/중단 지점. 피봇 트랜잭션이 커밋되면 사가는 완료될 때까지 실행된다. 피봇 트랜잭션은 보상 가능 트랜잭션. 재시도 가능한 트랜잭션 그 어느 쪽도 아니지만, 최종 보상 가능 트랜잭션 도는 최초 재시도 가능 트랜잭션이 될 수는 있다.
- 재시도 가능 트랜잭션: 피봇 트랜잭션 직후의 트랜잭션. 반드시 성공한다.

## 사가 편성
사가는 단계를 편성하는 로직으로 구성된다. 시스템 커맨드가 사가를 시작할 때 이 편성 로직은 첫 번째 사가 참여자를 정하여 로컬 트랜잭션 실행을 지시하고, 트랜잭션이 완료되면 그다음 사가 참여자를 호출하는 과정이 모든 단계가 실행될 때까지 반복된다. 도중 하나라도 로컬 트랜잭션이 실패하면 사가는 보상 트랜잭션을 역순으로 실행한다.

사가 편성 로직은 두 가지 종류가 있다.

- 코레오그래피(choreography): 의사 결정과 순서화를 사가 참여자에게 맡긴다. 사가 참여자는 주로 이벤트 교환 방식으로 통신한다.
- 오케스트레이션(orchestration): 사가 편성 로직을 사가 오케스트레이터에 중앙화한다. 사가 오케스트레이터는 사가 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시한다.

### 코레오그래피 사가
**코레오그래피 방식은 사가 참여자가 할 일을 알려 주는 중앙 편승자가 없다. 그 대신 사가 참여자가 서로 이벤트를 구독해서 그에 따라 반응하는 것이다.**

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/af3aa29c-0bdf-4bf6-a597-577fc96f59f4)

코레오그래피 방식으로 사가를 구현하려면 두 가지 통신 이슈를 고려해야 한다.
- 사가 참여자가 자신의 DB를 업데이트하고, DB 트랜잭션의 일부로 이벤트를 발행하도록 해야 한다.
- 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이털르 연관 지을 수 있어야 한다. 이를 위해 데이터를 매핑할 수 있도록 다른 사가 참여자가 상관관계 ID가 포함된 이벤트를 발행하도록 하자.

다음과 같은 장점이 있다.
- 단순함: 비즈니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트를 발행한다.
- 느슨한 결합: 참여자는 이벤트를 구독할 뿐 서로를 직접 알지 못한다.

하지만 다음과 같은 단점도 있다.
- 이해하기 어렵다: 사가를 어느 한곳에 정의한 것이 아니라서 여러 서비스에 구현 로직이 흩어져 있다. 어떤 사가가 어떻게 작동되는지 이해하기 어려운 편이다.
- 서비스 간 순환 의존성: 참여자가 서로 이벤트를 구독하는 특성상, 순환 의존성이 발생하기 쉽다. 이는 반드시 문제라고 할 수는 없지만, 잠재적인 설계 취약점이 된다.
- 단단히 결합될 위험성: 사가 참여자는 각자 자신에게 영향을 미치는 이벤트를 모두 구독해야 한다.

### 오케스트레이션 사가
**오케스트레이션 사가에서는 사가 참여자가 할 일을 알려주는 오케스트레이터 클래스를 정의한다.** 사가 오케스트레이터는 커맨드/비동기 응답 상호 작용을 하며 참여자와 통신한다. 사가 단계를 실행하기 위해 해당 참여자가 무슨 일을 해야 하는지 커맨드 메시지에 적어 보낸다. 사가 참여자가 작업을 마치고 응답 메시지를 오케스트레이터에 주면, 오케스트레이터는 응답 메시지를 처리한 후 다음 사가 단계를 어느 참여자가 수행할지 결정한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/a9c12b94-ebc9-4eff-be74-e14a01ad5384)

오케스트레이션 사가는 다음과 같은 장점이 있다.
- 의존 관계 단순화: 오케스트레이터는 참여자를 호출하지만 참여자는 오케스트레이터를 호출하지 않으므로 순환 의존성이 발생하지 않는다.
- 낮은 결합도: 각 서비스는 오케스트레이터가 호출하는 API를 구현할 뿐, 사가 참여자가 발행하는 이벤트는 몰라도 된다.
- 관심사를 더 분리하고 비즈니스 로직을 단순화: 사가 편성 로직이 사가 오케스트레이터 한곳에만 있으므로 도메인 객체는 더 단순해지고 자신이 참여한 사가에 대해서는 알지 못한다.

한편 다음과 같은 단점이 있다. 
비즈니스 로직을 오케스트레이터에 너무 많이 중앙화하면 똑똑한 오케스트레이터 하나가 깡통 서비스에 일일이 할 일을 지시하는 모양새가 될 수 있다. 이 문제는 오케스트레이터가 순서화만 담당하고 여타 비즈니스 로직은 갖고 있지 않도록 설계하면 해결된다.

**아주 단순한 사가가 아니라면 가급적 오케스트레이션 방식을 권장한다.**

## 비격리 문제 처리
사가를 이용할 때 편성 로직보다 더 골치 아픈 이슈가 바로 비격리 문제이다. 격리가 안 되면 트랜잭션을 어떻게 처리해야 할까?

ACID의 격리성(I)은 동시에 실행 중인 여러 트랜잭션의 결과가 어떤 순서대로 실행된 결과와 동일함을 보장하는 속성이다. 그런데 사가는 격리성이 빠져 있다. 실제로 사가의 한 트랜잭션이 커밋한 변경분을 다른 사가가 즉시 바라볼 수 있다. 이는 두 가지 문제를 야기한다.
- 한 사가가 실행 중에 접근하는 데이터를 도중에 다른 사가가 바꿔치기 할 수 있다.
- 한 사가가 업데이트를 하기 이전 데이터를 다른 사가가 읽을 수 있어 데이터 일관성이 깨질 수 있다.

사가는 사실 ACD 트랜잭션으로 보아야 한다.
- 원자성: 사가는 트랜잭션을 모두 완료하거나 모든 변경분을 언두해야 한다.
- 일관성: 서비스 내부의 참조 무결성은 로컬 DB가, 여러 서비스에 걸친 참조 무결성은 서비스가 처리한다.
- 지속성: 로컬 DB로 처리한다.

격리가 안되면 DB 용어로 비정상(anomaly)이 나타날 가능성이 있다. 트랜잭션이 차례대로 실행되지 않는 것처럼 데이터를 읽고 쓰게 되는 현상이다. 그래서 사가를 동시 실행한 결과와 순차 실행한 결과가 달라질 수 있다.

비격리로 인한 비정상은 다음과 같이 정리할 수 있다.

- 소실된 업데이트(lost updates): 한 사가의 변경분을 다른 사가가 미처 못 읽고 덮어 쓴다.
- 더티 읽기(dirty reads): 사가 업데이트를 하지 않은 변경분을 다른 트랜잭션이나 사가가 읽는다.
- 퍼지/반복 불가능한 읽기(fuzzy/nonerepetable reads): 한 사가의 상이한 두 단계가 같은 데이터를 읽어도 결과가 달라지는 현상. 다른 사가가 그 사이 업데이트를 했기 때문에 생기는 문제이다.

### 비격리 대책
책에 예제로 소개된 `*_PENDING` 상태도 이상 현상을 예방하는 전략 중 하나다. 이는 시맨틱 락 대책이라 칭한 기법의 일례이다.

- 시맨틱 락(semantic lock): 애플리케이션 수준의 락
- 교환적 업데이트(commutative updates): 업데이트 작업은 어떤 순서로 실행해도 되게끔 설계
- 비관적 관점(perssimistic view): 사가 단계 순서를 재조정하여 비즈니스 리스크를 최소화한다.
- 값 다시 읽기(reread value): 데이터를 덮어 쓸 때 그 전에 변경된 내용은 없는지 값을 다시 읽고 확인하여 더티 쓰기를 방지
- 버전 파일(version file): 순서를 재조정할 수 있게 업데이트를 기록
- 값에 의한(by value): 요청별 비즈니스 위험성을 기준으로 동시성 메커니즘을 동적 선택한다.