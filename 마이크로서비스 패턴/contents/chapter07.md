# 7장. 마이크로서비스 쿼리 구현
마이크로서비스 아키텍처에선 의외로 쿼리를 작성하기 어렵다. 여러 서비스, 여러 DB에 분산된 데이터를 조회해야 하는데, 기존 분산 쿼리 메커니즘은 기술적으로 가능하다 해도 캡슐화에 위배되기 때문에 사용할 수 없다.

마이크로서비스 아키텍처에선 다음 두 가지 패턴으로 쿼리를 구현한다.

- API 조합 패턴: 서비스 클라이언트가 데이터를 가진 여러 서비스를 직접 호출하여 그 결과를 조합하는 패턴이다. 가장 단순한 방법으로 가급적 이 방법을 쓰는 것이 좋다.
- CQRS 패턴: 쿼리만 지원하는 하나 이상의 뷰 전용 DB를 유지하는 패턴이다. API 조합 패턴보다 강력한 만큼 구현하긴 더 복잡하다.

## API 조합 패턴 응용 쿼리
`findOrder()`는 기본키로 주문 정보를 조회하는 메서드다. `orderId`를 매개변수로 받아 주문 내역이 포함된 `OrderDetails` 객체를 반환한다. 주문 상태 뷰가 구현된, 모바일 기기 또는 웹 애플리케이션 등의 프론트엔드 모듈이 이 메서드를 호출한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/3d9e27ed-254c-4564-b793-3eeb75459765)

모놀리식 애플리케이션은 전체 데이터가 하나의 DB에 있기 때문에 알기 쉽게 `SELECT` 문으로 여러 테이블을 조인해서 주문 내역을 조회하면 된다. 반면 마이크로서비스 아키텍처로 전환하면 데이터가 여러 서비스에 뿔뿔이 흩어지게 된다.

- 주문 서비스: 주문 기본 정보
- 주방 서비스: 음식점 관점의 주문 상태, 픽업 준비까지 예상 소요 시간
- 배달 서비스: 주문 배달 상태, 배달 예상 정보, 현재 배달원 위치
- 회계 서비스: 주문 지불 상태

### API 조합 패턴 개요
API 조합 패턴은 데이터를 가진 서비스를 호출한 후 그 반환 결과를 조합해서 가져온다. 이 과정에는 다음 두 종류의 참여자가 개입한다.

- API 조합기: 프로바이더 서비스를 쿼리하여 데이터를 조회한다.
- 프로바이더 서비스: 최종 결과로 반환할 데이터의 일부를 갖고 있는 서비스

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/13d17910-f7ad-46e0-9d52-c88480f5d8d6)

API 조합기는 A, B, C 세 프로바이더 서비스에서 데이터를 조회한 후 그 결과를 조합한다. 이 조합기는 웹 애플리케이션처럼 웹 페이지에 데이털르 렌더링하는 클라이언트일 수도 있고, 쿼리 작업을 API 끝점으로 표출한 API 게이트웨이나 프론트엔드를 위한 백엔드 패턴의 변형일 수도 있다.

이 패턴으로 특정 쿼리 작업을 구현할 수 있을지 여부는 데이터가 어떻게 분할되었는지, 데이터를 가진 서비스가 어떤 API 기능을 표출하는지, 사용 중인 DB는 어떤 기능을 제공하는지 등 다양한 요인에 따라 가변적이다.

- 프로바이더 서비스가 필요한 데이터를 조회할 수 있는 API를 제공하더라도 애그리거트가 거대한 데이터 뭉치를 비효율적으로 인-메모리 조인을 해야 할 수도 있다.
- 이 패턴으로 구현할 수 없는 쿼리 작업도 있지만, 대부분의 경우 이 패턴을 적용해서 구현할 수 있다.

### API를 조합 패턴으로 findOrder() 쿼리 구현
`findOrder()`는 단순히 기본키로 EQUI 조인해서 쿼리하는 작업이다. `orderId`로 필요한 데이터를 가져올 수 있는 API 끝점은 각 프로바이더 서비스가 당연히 제공하리라 볼 수 있기 때문에 API 조합 패턴으로 구현하기 제격이다.