# 7장. 마이크로서비스 쿼리 구현
마이크로서비스 아키텍처에선 의외로 쿼리를 작성하기 어렵다. 여러 서비스, 여러 DB에 분산된 데이터를 조회해야 하는데, 기존 분산 쿼리 메커니즘은 기술적으로 가능하다 해도 캡슐화에 위배되기 때문에 사용할 수 없다.

마이크로서비스 아키텍처에선 다음 두 가지 패턴으로 쿼리를 구현한다.

- API 조합 패턴: 서비스 클라이언트가 데이터를 가진 여러 서비스를 직접 호출하여 그 결과를 조합하는 패턴이다. 가장 단순한 방법으로 가급적 이 방법을 쓰는 것이 좋다.
- CQRS 패턴: 쿼리만 지원하는 하나 이상의 뷰 전용 DB를 유지하는 패턴이다. API 조합 패턴보다 강력한 만큼 구현하긴 더 복잡하다.

## API 조합 패턴 응용 쿼리
`findOrder()`는 기본키로 주문 정보를 조회하는 메서드다. `orderId`를 매개변수로 받아 주문 내역이 포함된 `OrderDetails` 객체를 반환한다. 주문 상태 뷰가 구현된, 모바일 기기 또는 웹 애플리케이션 등의 프론트엔드 모듈이 이 메서드를 호출한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/3d9e27ed-254c-4564-b793-3eeb75459765)

모놀리식 애플리케이션은 전체 데이터가 하나의 DB에 있기 때문에 알기 쉽게 `SELECT` 문으로 여러 테이블을 조인해서 주문 내역을 조회하면 된다. 반면 마이크로서비스 아키텍처로 전환하면 데이터가 여러 서비스에 뿔뿔이 흩어지게 된다.

- 주문 서비스: 주문 기본 정보
- 주방 서비스: 음식점 관점의 주문 상태, 픽업 준비까지 예상 소요 시간
- 배달 서비스: 주문 배달 상태, 배달 예상 정보, 현재 배달원 위치
- 회계 서비스: 주문 지불 상태

### API 조합 패턴 개요
API 조합 패턴은 데이터를 가진 서비스를 호출한 후 그 반환 결과를 조합해서 가져온다. 이 과정에는 다음 두 종류의 참여자가 개입한다.

- API 조합기: 프로바이더 서비스를 쿼리하여 데이터를 조회한다.
- 프로바이더 서비스: 최종 결과로 반환할 데이터의 일부를 갖고 있는 서비스

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/13d17910-f7ad-46e0-9d52-c88480f5d8d6)

API 조합기는 A, B, C 세 프로바이더 서비스에서 데이터를 조회한 후 그 결과를 조합한다. 이 조합기는 웹 애플리케이션처럼 웹 페이지에 데이털르 렌더링하는 클라이언트일 수도 있고, 쿼리 작업을 API 끝점으로 표출한 API 게이트웨이나 프론트엔드를 위한 백엔드 패턴의 변형일 수도 있다.

이 패턴으로 특정 쿼리 작업을 구현할 수 있을지 여부는 데이터가 어떻게 분할되었는지, 데이터를 가진 서비스가 어떤 API 기능을 표출하는지, 사용 중인 DB는 어떤 기능을 제공하는지 등 다양한 요인에 따라 가변적이다.

- 프로바이더 서비스가 필요한 데이터를 조회할 수 있는 API를 제공하더라도 애그리거트가 거대한 데이터 뭉치를 비효율적으로 인-메모리 조인을 해야 할 수도 있다.
- 이 패턴으로 구현할 수 없는 쿼리 작업도 있지만, 대부분의 경우 이 패턴을 적용해서 구현할 수 있다.

### API를 조합 패턴으로 findOrder() 쿼리 구현
`findOrder()`는 단순히 기본키로 EQUI 조인해서 쿼리하는 작업이다. `orderId`로 필요한 데이터를 가져올 수 있는 API 끝점은 각 프로바이더 서비스가 당연히 제공하리라 볼 수 있기 때문에 API 조합 패턴으로 구현하기 제격이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/0de74c6c-c43e-41da-a689-cfaeaaed92a0)

여기서 API 조합기는 쿼리를 REST 끝점으로 표출한 서비스다. HTTP 대신 gRPC 같은 다른 IPC 프로토콜을 사용하는 서비스 역시 개념은 같다. REST 끝점 `GET /order/{orderId}`가 구현된 주문 검색 조합기는 `orderId`로 네 서비스를 호출한 후 수신한 응답을 조인한다. 각 프로바이더 서비스는 애그리거트 하나에 해당하는 응답을 반환하는 REST 끝점을 제공한다. 주문 서비스는 기본키로 자신의 `Order`를 조회하고, 다른 서비스는 `orderId`를 외래키로 자신의 애그리거트를 조회하는 것이다.

### API 조합 설계 이슈
API 조합 패턴에는 두 가지 설계 이슈가 있다.

- 어느 컴포넌트를 쿼리 작업의 API 조합기로 선정할 것인가?
- 어떻게 해야 효율적으로 취합 로직을 작성할 것인가?

#### 누가 API 조합기 역할을 맡을 것인가?
우선 쿼리 작업의 API 조합기 역할을 누가 맡을지 결정해야 한다. 세 가지 옵션이 있다.

첫째, 서비스 클라이언트를 API 조합기로 임명하는 것이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/a34f9bf0-0183-490c-b01c-c55cdf8cc2a8)

- 주문 상태 뷰를 구현한 웹 애플리케이션 같은 클라이언트가 동일한 LAN에서 실행 중이라면 가장 효율적으로 주문 내역을 조회할 수 있다.
- 클라이언트가 방화벽 외부에 있고 서비스가 위치한 네트워크가 느리다면 그리 실용적이지 않다.

둘째, 애플리케이션 외부 API가 구현된 API 게이트웨이를 API 조합기로 만드는 것이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/86b40932-ce77-43dc-877b-9dbe69a0b783)

- 쿼리 작업이 애플리케이션의 외부 API 중 일부라면 이 방법이 타당하다.
- 다른 서비스로 요청을 보내는 대신 차라리 API 게이트웨이에 API 조합 로직을 구현하는 것이다.
- 모바일 기기 등 방화벽 외부에서 접근하는 클라이언트가 API 호출 한 번으로 여러 서비스의 데이터를 조회할 수 있기 때문에 효율적이다.

셋째, API 조합기를 스탠드얼론 서비스로 구현하는 것이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/bb9a6314-5daf-4489-ab00-fc61e88aec1a)

- 내부적으로 여러 서비스가 사용하는 쿼리 작업이면 이 방법이 좋다.
- 취합 로직이 너무 복잡해서 API 게이트웨이 일부로 만들기는 곤란하고 외부에서 접근 가능한 쿼리 작업을 구현할 경우에도 좋은 방법이다.

#### API 조합기는 리액티브 프로그래밍 모델을 사용해야 한다
분산 시스템을 개발할 때 **지연 시간을 최소화하는 문제**는 항상 골칫거리다. **쿼리 작업의 반응 시간을 최대한 줄이려면 가능한 한 API 조합기가 프로바이더 서비스를 병렬 호출해야 한다.** 가령 주문 검색 애그리거트는 호출 대상인 네 서비스가 서로 의존 관계가 없기 때문에 동시 호출하는 것이 맞다. 하지만 어떤 프로바이더 서비스를 호출하기 위해 다른 프로바이더 서비스의 결과를 먼저 가져와야 하는 경우도 있다. 이럴 땐 일부 프로바이더 서비스를 순차 호출해야 한다.

그러나 순차/병렬 서비스 호출이 뒤섞인 실행 로직은 복잡해질 수 있다. 관리가 용이하고 성능/확장성도 우수한 API 조합기를 작성하려면 Java의 `CompletableFuture`, RxJava의 `observable`, 또는 이와 동등한 추상체에 기반한 리액티브 설계 기법을 동원해야 한다.

### API 조합 패턴의 장단점
API 조합 패턴은 MSA에서 아주 쉽고 단순하게 쿼리 작업을 구현할 수 있게 해주지만, 다음과 같은 단점도 있다.

- 오버헤드 증가
- 가용성 저하 우려
- 데이터 일관성 결여

#### 오버헤드는 증가한다
- 여러 서비스를 호출하고 여러 DB를 쿼리하는 오버헤드는 불가피하다.
- 그만큼 컴퓨팅/네트워크 리소스가 더 많이 소모되고 애플리케이션 운영 비용도 늘어난다.

#### 가용성이 저하될 우려가 있다
- 어떤 작업의 가용성은 더 많은 서비스가 개입할수록 감소한다.
- 하나의 쿼리 작업에 세 서비스(API 조합기 + 둘 이상의 프로바이더 서비스)가 반드시 개입되는 구조라서 하나의 서비스로 처리하는 것에 비해 가용성은 현저히 낮다.

가용성을 높이는 전략은 다음과 같다.

- 프로바이더 서비스가 불능일 경우 API 조합기가 이전에 캐시한 데이터를 반환하는 것이다.
  - 성능 향상을 목적으로 API 조합기에 캐시된, 프로바이더 서비스의 반환 데이터를 잘 활용하면 가용성을 끌어올릴 수 있다.
  - 프로바이더 서비스가 내려가더라도 API 조합기는 오래 되어 맞지 않는 데이터도 있겠지만 캐시 데이터를 반환할 수 있다.
- API 조합기가 미완성된 데이터를 반환하는 것이다.
  - 가령 주방 서비스가 일시 불능 상태가 되면 주문 검색 조합기가 이 서비스의 데이터만 제외한 나머지 데이터를 반환한다.
  - 주방 서비스 데이터가 없어도 UI에서 유용한 정보를 표시하는 데는 별 지장이 없기 때문이다.

#### 데이터 일관성이 결여된다
모놀리식 애플리케이션은 대부분 한 트랜잭션으로 쿼리를 수행한다. ACID 트랜잭션은 애플리케이션이 여러 DB에 쿼리를 실행해도 데이터를 일관되게 바라볼 수 있게 보장한다. 그러나 API 조합 패턴은 여러 DB를 대상으로 여러 쿼리를 실행하기 때문에 일관되지 않은 데이터가 반환될 수 있다.

- 주문 서비스가 조회한 주문 상태는 `CANCELLED`이지만, 주방 서비스가 조회한 이 주문의 티켓은 아직 취소되지 않았을 수 있다.

API 조합기는 이런 모순을 해결해야 하는데, 그러면 코드가 점점 더 복잡해진다. 게다가 이런 모슨된 데이터를 API 조합기가 항상 감지할 수 있는 것은 아니라서 잘못된 데이터가 그대로 클라이언트에 반환될 수도 있다.

효율적으로 구현하기 어려운 쿼리(거대한 데이터 뭉치를 인-메모리 조인하는 쿼리)는 CQRS 패턴으로 구현하는 것이 바람직하다.

## CQRS 패턴
엔터프라이즈 애플리케이션은 대부분 RDBMS에 트랜잭션을 걸어 레코드를 관리하고, 텍스트 검색 쿼리는 ElasticSearch나 솔라 등의 텍스트 검색 DB를 이용해서 구현한다. 애플리케이션에 따라 RDBMS와 텍스트 검색 DB를 모두 출력하여 동기화하기도 하고, 주기적으로 RDBMS에서 텍스트 검색 DB로 데이터를 복사하는 경우도 있다.

이런 아키텍처로 구축하는 이유는 여러 DB의 장점을 최대한 활용하자는 의도다. 즉, RDBMS 특유의 트랜잭션 기능과 텍스트 검색 DB의 탁월한 쿼리 능력을 융합하여 활용하는 것이다.

CQRS는 이런 종류의 아키텍처를 일반화한 것이다. 하나 이상의 쿼리가 구현된 하나 이상의 뷰 DB를 유지하는 기법이다.

### CQRS의 필요성
`findOrderHistory()`는 다음 매개변수를 받아 소비자의 주문 이력을 조회하는 쿼리 작업이다.

- `consumerId`: 소비자 식별자
- `OrderHistoryFilter`: 필터 조건. 어느 시점 이후 주문까지 반환할 것인가(필수), 주문 상태(옵션), 음식점명 및 메뉴 항목을 검색할 키워드(옵션)

겉보기에 `findOrder()`와 비슷하지만 단건 주문 정보가 아닌, 다건 주문 목록을 반환하는 차이점이 있다. API 조합기로 각 프로바이더 서비스에 똑같은 쿼리를 실행한 결과를 조합하면 간단할 것 같지만, 그렇게 간단하지 않다.

모든 서비스가 필터/정렬 용도의 속성을 보관하는 것이 아니기 때문이다. 이를테면 `findOrderHistory()`의 `OrderHistoryFilter`에는 메뉴 항목과 매치할 `keywords`라는 속성이 있다. 하지만 메뉴 항목을 저장하는 서비스는 주문 서비스, 주방 서비스 2개뿐이고, 나머지 배달 서비스, 회계 서비스는 메뉴 항목을 저장하지 않기 때문에 데이터를 필터할 수 없다. 마찬가지로 주방 서비스, 배달 서비스 둘 다 `orderCreationDate` 속성으로 정렬하는 것은 불가능하다.

API 조합기는 이 문제를 두 가지 방법으로 해결할 수 있다.

- API 조합기로 데이터를 인-메모리 조인을 한다. 그러나 거대한 데이터 뭉치를 이런식으로 API 조합기에서 조인하면 급격히 효율이 떨어질 것이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/c3108fae-44dd-4fe2-90bf-5c4dc376ee3a)

- API 조합기로 주문 서비스, 주방 서비스에서 데이터를 조회하고, 주문 ID를 이용해 다른 서비스에 있는 데이터를 요청한다. 하지만 이는 해당 서비스가 대량 조회 API를 제공할 경우에만 현실성 있는 방법이다. 그렇다고 주문 데이터를 하나하나 요청하는 것은 과도한 네트워크 트래픽이 유발되어 비효율적이다.

`findOrderHistory()` 같은 쿼리 작업은 API 조합기로 하여금 이미 RDBMS 쿼리 실행 엔진에 탑재된 기능을 재탕하는 것밖에 안된다. 작업 자체를 확장성 낮은 DB에서 확장성 높은 애플리케이션으로 이동시키는 의미는 있으나 비효율적이다.

#### 어려운 단일 서비스 쿼리: findAvailableRestaurants()
하나의 서비스에 국한된 쿼리도 구현하기 어려운 경우가 있다.

- 데이터를 가진 서비스에 쿼리를 구현하는 것이 부적절한 경우
- 서비스 DB 또는 데이터 모델이 효율적인 쿼리를 지원하지 않는 경우

책에서 설명하는 예시는 지리 공간을 검색하는 기능 개발이다. 지리 공간 확장팩을 제공해주는 DB를 사용하면 쉽게 구현 가능하지만, 지원하지 않는다면 까다롭다. 음식점 데이터의 레플리카를 지리 공간 쿼리에 맞게 설계된 형태로 유지할 수 밖에 없다. 문제는 원본 데이터가 변경될 때마다 레플리카를 항상 최신으로 유지하는 일이다. 다행히 레플리카를 동기화하는 문제는 CQRS로 해결할 수 있다.

#### 관심사를 분리할 필요성
단일 서비스 쿼리가 구현하기 까다로운 또 다른 이유는 **데이터를 가진 서비스에 쿼리를 구현하면 안 될 때가 있기 때문**이다. `findAvailableRestaurants()`는 음식점 서비스에 있는 데이터를 조회하는 쿼리 작업이다. 언뜻 보면 음식점 데이터를 가진 음식점 서비스에 쿼리를 구현해야 할 것처럼 느껴지지만, 이는 데이터 소유권만 보고 판단할 문제는 아니다.

**관심사를 어떻게 분리하면 좋을 지, 어느 한 서비스에 너무 많은 책임을 부과하지 않으려면 어떻게 해야 할까 하는 문제도 함께 고민해야 한다.**

- 음식점 서비스 개발 팀의 주 업무는 음식점 주인이 자기가 운영하는 음식점을 잘 관리할 수 있게 해주는 서비스를 개발하는 일이지, 성능이 매우 중요한 대용량 데이터를 조회하는 쿼리를 구현하는 일은 아니다.
- 이 팀의 개발자가 `findAvailableRestaurants()` 개발까지 담당할 경우, 나중에 자신이 변경할 코드를 배포할 때 사이드이펙트가 생기진 않을지 불안에 시달리게 될 것이다.

`findAvailableRestaurants()` 쿼리는 다른 팀(주문 서비스 개발팀)이 구현하고 음식점 서비스는 검색할 음식점 데이터만 제공하는 구조가 낫다. `findOrderHistory()` 쿼리 작업 처럼 지리 공간 인덱스를 유지해야 할 경우라면, 쿼리 구현을 위해 일부 데이터의 레플리카는 최종 일관된 형태를 유지해야 한다.

### CQRS 개요
MSA에선 쿼리를 구현할 때 다음 세 가지 난관에 봉착하게 된다.

- API를 조합하여 여러 서비스에 흩어진 데이터를 조회하려면 값비싸고 비효율적인 인-메모리 조인을 해야 한다.
- 데이터를 가진 서비스는 필요한 쿼리를 효율적으로 지원하지 않는 DB에 또는 그런 형태로 데이터를 저장한다.
- 관심사를 분리할 필요가 있다는 것은 데이터를 가진 서비스가 쿼리 작업을 구현할 장소로 적합하지 않다는 뜻이다.

이 문제들을 해결할 수 있는 방법이 CQRS 패턴이다.

#### CQRS는 커맨드와 쿼리를 서로 분리한다
이는 이름처럼 관심사의 분리/구분에 관한 패턴이다.

**영속적 데이터 모델과 그것을 사용하는 모듈을 커맨드와 쿼리, 두 편으로 가른다.**

- 조회(R) 기능은 쿼리 쪽 모듈 및 데이터 모델에 구현
- 생성/수정/삭제(CUD) 기능은 커맨드 쪽 모듈 및 데이터 모델에 구현
- 양쪽 데이터 모델 사이의 동기화는 커맨드 쪽에서 발행한 이벤트를 쿼리 쪽에서 구독하는 식으로 이루어진다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/1894624f-7256-476c-b110-dde4b84d3358)

CQRS 패턴과 상관없이 거의 모든 서비스는 다양한 CRUD 작업이 구현된 API를 갖고 있다. 비 CQRS 서비스에선 이런 작업을 보통 DB에 매핑된 도메인 모델로 구현한다. 성능이 중요한 쿼리는 도메인 모델을 건너뛰고 직접 DB에 접속하기도 한다. 하나의 영속적 데이터 모델은 커맨드와 쿼리를 모두 지원한다.

- 커맨드 쪽 도메인 모델은 CRUD 작업을 처리하고 자체 DB에 매핑된다.
- 조인 없는 단순 쿼리와 기본키 기반의 쿼리도 처리할 수 있다.
- 커맨드 쪽은 데이터가 바뀔 때마다 이벤트 소싱 등의 프렝ㅁ워크를 이용해 도메인 이벤트를 발행한다.
- 별도로 나뉘어진 쿼리 모델은 다소 복잡한 쿼리를 처리한다.
- 쿼리 쪽은 반드시 지원해야 하는 쿼리에 대해선 모든 종류의 DB를 지원한다.
- 쿼리 쪽에는 도메인 이벤트를 구독하고 DB(들)를 업데이트하는 이벤트 핸들러가 있다.
- 쿼리 종류마다 쿼리 모델을 하나씩 가진 다중 쿼리 모델도 있다.

#### CQRS와 쿼리 전용 서비스
CQRS는 서비스 내부에 적용할 수 있을 뿐만 아니라, 이 패턴을 이용해 쿼리 서비스를 정의하는 것도 가능하다. **쿼리 서비스엔 커맨드 작업이 전혀 없는 오직 쿼리 작업만으로 구성된 API가 있고, 하나 이상의 다른 서비스가 발행한 이벤트를 구독하여 항상 최신 상태로 유지되는 DB를 쿼리하는 로직이 구현되어 있다.**

쿼리 쪽 서비스는 여러 서비스가 발행한 이벤트를 구독해서 구축된 뷰를 구현하기 좋은 방법이다. 이런 뷰는 특정 서비스에 종속되지 않기 때문에 스탠드얼론 서비스로 구현하는 것이 타당하다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/a4f99c25-6799-4c37-a184-f3d2d9f2b1c0)

주문 이력 서비스는 여러 서비스가 발행한 이벤트를 구독하고 주문 이력 뷰 DB를 업데이트하는 이벤트 핸들러를 갖고 있다.

- 쿼리 서비스는 한 서비스가 가진 데이터를 복제한 뷰를 구현하는 수단으로도 유용하다.
- 여러 면에서 CQRS는 RDBMS를 기록 시스템으로 활용하면서 텍스트 검색 엔진을 이용하여 텍스트 검색 쿼리를 처리하는 대중적인 접근 방식을 이벤트를 기반으로 일반화한 것이라 볼 수 있다.
- 다만 CQRS는 텍스트 검색 엔진뿐만 아니라 훨씬 다양한 종류의 DB를 활용할 수 있다는 차이점이 있다.
- CQRS 쿼리 쪽 뷰는 이벤트를 구독해서 거의 실시간으로 업데이트된다.

### CQRS의 장점
- 마이크로서비스 아키텍처에서 쿼리를 효율적으로 구현할 수 있다.
- 다양한 쿼리를 효율적으로 구현할 수 있다.
- 이벤트 소싱 애플리케이션에서 쿼리가 가능하다.
- 관심사가 더 분리된다.

### CQRS의 단점
- 아키텍처가 더 복잡하다.
- 복제 시차를 처리해야 한다.

클라이언트 애플리케이션이 애그리거트를 업데이트한 즉시 뷰를 쿼리하면 이전 버전의 애그리거트를 바라보게 될 수도 있다. 이렇게 일관되지 않은 데이터가 최대한 사용자에게 노출되지 않도록 애플리케이션을 개발해야 한다. 한 가지 방법은 커맨드/쿼리 양쪽 API가 클라이언트에 버전 정보를 전달해서 김빠진 데이터를 분간할 수 있게 만드는 것이다.

네이티브 모바일 앱이나 SPA 같은 UI 애플리케이션은 쿼리를 하지 않고 커맨드가 성공하면 자신의 로컬 모델을 업데이트하는 방법으로 복제 시차를 해소할 수 있다. 커맨드가 반환한 데이터로 자체 모델을 업데이트하는 것이다. 별다른 문제가 없다면 사용자 액션으로 쿼리가 트리거될 때 뷰는 최신 상태가 될 것이다. 하지만 모델을 업데이트하려면 UI 코드가 서버 쪽 코드를 복제해야 한다는 단점이 있다.

가능한 한 API 조합 패턴을 사용하고, 꼭 필요할 경우에 한하여 CQRS를 사용하자.

## CQRS 뷰 설계
CQRS 뷰 모듈에는 하나 이상의 쿼리 작업으로 구성된 API가 있다. 하나 이상의 서비스가 발행한 이벤트를 구독해서 최신 상태로 유지된 DB를 조회하는 쿼리 API다. 뷰 모듈은 뷰 DB와 세 하위 모듈로 구성된다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/434c45cc-16b4-4809-9436-649d3056a52a)

이벤트 핸들러, 쿼리 API 모듈은 데이터 접근 모듈을 통해 DB를 조회/수정한다. 이벤트 핸들러 모듈은 이벤트를 구독해서 DB를 업데이트하고, 쿼리 API 모듈은 데이터를 조회한다.

뷰 모듈을 개발할 땐 몇 가지 중요한 설계 결정을 해야 한다.

- DB를 산정하고 스키마를 설계해야 한다.
- 데이터 접근 모듈을 설계할 때 멱등한/동시 업데이트 등 다양한 문제를 고려해야 한다.
- 기존 애플리케이션에 새 뷰를 구현하거나 기존 스키마를 바꿀 경우, 뷰를 효율적으로 (재)빌드할 수 있는 수단을 강구해야 한다.
- 뷰 클라이언트에서 복제 시차를 어떻게 처리할 지 결정해야 한다.

### 뷰 DB 선택
DB와 데이터 모델의 주목적은 뷰 모듈의 쿼리 작업을 효율적으로 구현하는 것이다. DB를 선택할 때 이런 쿼리 작업의 특성이 주된 검토 항목이지만, DB 역시 이벤트 핸들러가 수행하는 업데이트 작업을 효율적으로 지원 가능해야 한다.

#### SQL대 NoSQL DB
NoSQL DB는 대부분 트랜잭션 기능이 제한적이고 범용적인 쿼리 능력은 없지만, 어떤 유스케이스는 유연한 데이터 모델, 우수한 성능/확장성 등 SQL 기반 DB보다 더 낫다.

NoSQL DB는 CQRS 뷰와 잘 맞는 편이다. NoSQL DB의 풍성한 데이터 모델과 우수한 성능이 CQRS 뷰에 유리하다. 또 CQRS 뷰는 단순 트랜잭션만 사용하고 고정된 쿼리만 실행하므로 NoSQL DB의 제약 사항에도 영향을 받지 않는다.

RDBMS는 예전보다 성능이 뛰어나고, 대부분의 사람들이 이에 익숙하기에 RDBMS를 사용하여 CQRS 뷰를 구현하는 것이 타당할 때가 있다.

|~가 필요하면|~를 사용한다|예시|
|--|--|--|
|JSON 객체를 PK로 검색|문서형 스토어 (ex. MongoDB, DynamoDB), 키-값 스토어 (ex. Redis)|고객별 MongoDB 문서로 주문 이력 관리|
|쿼리 기반의 JSON 객체 검색|문서형 스토어|MongoDB, DynamoDB로 고객 뷰 구현|
|텍스트 쿼리|텍스트 검색 엔진 (ex. ElasticSearch)|주문별 ElasticSearch 문서로 주문 텍스트 검색 구현|
|그래프 쿼리|그래프 DB(ex. Neo4j)|고객, 주문, 기타 데이터의 그래프로 부정 탐지 구현|
|전통적인 SQL 리포팅/BI|관계형 DB|표준 비즈니스 리포트 및 분석|

#### 업데이트 작업 지원
뷰 데이터 모델에선 쿼리뿐만 아니라 이벤트 핸들러가 실행할 업데이트 작업 역시 효율적으로 구현되어야 한다. 이벤트 핸들러는 대개 뷰 DB에 있는 레코드를 기본키로 찾아 수정/삭제할 것이다.

- `finedOrderHistory()` 쿼리의 뷰는 주문 서비스에서 이벤트를 수신받아 그대로 해당 레코드를 업데이트한다.

하지만 외래키를 이용해서 레코드를 수정/삭제해야 하는 경우도 있다. `Delivery*` 이벤트 핸들러가 이에 해당한다.

- `Delivery`와 `Order`가 1:1 관계 → `Delivery.id` == `Order.id` → 이벤트 핸들러는 주문 DB 레코드를 쉽게 업데이트할 수 있다.
- `Delivery`가 자신의 기본키를 갖고 있거나 `Order`와 `Delivery`가 1:N 관계인 경우 → PK가 포함되지 않은 이벤트들의 경우 `deliveryId`를 외래키로 이용하여 주문 레코드를 업데이트해야 한다.

일부 DB 자료형은 외래키 기반의 업데이트 작업을 효율적으로 지원한다. RDBMS나 MongoDB를 제외한 NoSQL DB에선 비기본키 기반으로 업데이트하기가 쉽지 않다. 애플리케이션이 업데이트할 레코드를 결정하려면 외래키에서 기본키로 매핑 가능한 데이터를 DB에 갖고 있어야 한다.

### 데이터 접근 모듈 설계
이벤트 핸들러와 쿼리 API 모듈은 DB에 직접 접근하지 않는다. 그 대신 데이터 접근 객체 및 헬퍼 클래스로 구성된 데이터 접근 모듈을 사용한다.

- DAO는 이벤트 핸들러가 호출한 업데이트 작업과 쿼리 모듈이 호출한 쿼리 작업을 실질적으로 수행한다.
- 고수준 코드에 쓰이는 자료형과 DB API 간 매핑, 동시 업데이트 처리 및 업데이트 멱등성 보장 등 하는 일이 많다.

#### 동시성 처리
동일한 DB 레코드에 대해 DAO가 여러 동시 업데이트를 처리하는 경우가 있다. **뷰가 한 종류의 애그리거트가 발행한 이벤트를 구독한다면 동시성 이슈는 없다.** 특정 애그리거트 인스턴스가 발행한 이벤트는 순차적으로 처리되기 때문에 어느 한 애그리거트 인스턴스에 해당되는 레코드가 동시에 업데이트될 일은 없다. 하지만 **뷰가 여러 종류의 애그리거트가 발행한 이벤트를 구독할 경우, 여러 이벤트 핸들러가 동일한 레코드에 달려들어 업데이트할 수 있다.**

동일한 주문을 대상으로 `Order*` 이벤트 핸들러와 `Delivery*` 이벤트 핸들러가 동일한 시간에 호출되어 해당 주문의 DB 레코드를 업데이트하는 DAO가 동시에 호출될 수 있다. DAO는 동시 업데이트로 서로가 서로의 데이터를 덮어 쓰지 않도록 작성되어야 한다. 만약 DAO가 레코드를 읽고 업데이트된 레코드를 쓴다면 **낙관적 잠금이든, 비관적 잠금이든 둘 중 하나를 적용해야 한다.**

#### 멱등한 이벤트 핸들러
이벤트 핸들러는 같은 이벤트를 한 번 이상 넘겨받고 호출될 수 있다. 쿼리 쪽 이벤트 핸들러가 멱등한 경우, 즉 중복 이벤트를 처리해도 결과가 정확히 동일하다면 문제될 일은 아니다. 최악의 경우, 뷰 데이터 저장소는 일시적으로 동기화가 안 될 것이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/5422e57f-5d4d-4006-9585-348c9a51edc8)

주문 이력 뷰를 유지하는 이벤트 핸들러는 배달 픽업됨, 주문 배달됨, 배달 픽업됨, 주문 배달됨으로 이벤트를 받아 호출된다. 메시지 브로커가 최초로 배달 픽업됨, 주문 배달됨 이벤트를 전달한 후, 네트워크 오류 등 어떤 문제가 생겨 이전 시점의 이벤트 전달을 재개하면 결국 배달 픽업됨, 주문 배달됨 이벤트를 다시 전달하게 될 것이다.

두 번째 배달 픽업됨 이벤트를 이벤트 핸들러가 처리한 이후, 주문 이력 뷰는 주문 배달됨 이벤트가 처리되기 전까진 일시적으로 과거 주문 상태를 바라보게 된다. 이벤트 핸들러가 중복 이벤트를 알아서 솎아 내면 이런 일이 발생하지 않을 것이다.

**중복 이벤트 때문에 부정확한 결과가 나온다면 멱등한 이벤트 핸들러가 아니다.** 비멱등적 이벤트 핸들러는 자신이 뷰 데이터 저장소에서 처리한 이벤트 ID를 기록해 두었다가 중복 이벤트가 들어오면 솎아 내야 한다.

**이벤트 핸들러는 반드시 이벤트 ID를 기록하고 데이터 저장소를 원자적으로 업데이트해야 한다.** 그 방법은 DB 종류마다 다르다. 뷰 데이터 저장소가 SQL DB면, 이벤트 핸들러가 처리 완료한 이벤트를 뷰 업데이트 트랜잭션의 일부로 `PROCESSED_EVENTS` 테이블에 삽입할 수 있다. 그러나 트랜잭션 능력이 제한적인 NoSQL DB면, 이벤트 핸들러는 자신이 업데이트하는 데이터 저장소 '레코드'에 이벤트를 저장해야 한다.

이벤트 핸들러가 모든 이벤트 ID를 일일이 기록할 필요는 없다. 이벤추에이트처럼 이벤트 ID가 그냥 하나씩 증가하는 구조라면 주어진 애그리거트 인스턴스에서 전달받은 `max(eventId)`를 각 레코드에 저장하면 된다. 레코드가 단일 애그리거트 인스턴스에 해당된다면 이벤트 핸들러는 `max(eventId)`만 기록하면 된다. 여러 애그리거트의 이벤트가 조합된 결과를 나타내는 레코드는 `[애그리거트 타입, 애그리거트 ID] → max(eventId)` 맵을 담고 있어야 한다.

```
{
  // ...
  "Order3949384394-039434903" : "0000015e0c6fc18f-0242ac1100e50002",
  "Delivery3949384394-039434903" : "0000015e0c6fc264-0242ac1100e50002",
}
```

각 이벤트의 추적 속성명은 `<애그리거트 타입> <애그리거트 ID>`로, 값은 `eventId`로 세팅한다.

#### 클라이언트 애플리케이션이 최종 일관된 뷰를 사용할 수 있다
CQRS를 적용하면 커맨드 쪽을 업데이트한 직후 쿼리를 실행하는 클라이언트가 자신이 업데이트한 내용을 바라보지 못하게 될 가능성이 있다. 메시징 인프라의 지연 시간은 불가피하기 때문에 이 뷰는 최종 일관된다.

커맨드와 쿼리 모듈 API를 이용하면 클라이언트가 비일관성을 감지하게 만들 수 있다. 커맨드 쪽 작업이 클라이언트에 발행된 이벤트의 ID가 포함된 토큰을 반환하고, 클라이언트는 이 토큰을 쿼리 작업에 전달하면 해당 이벤트에 의해 뷰가 업데이트 되지 않았을 경우 에러가 반환될 것이다. 이런 중복 이벤트 감지 메커니즘을 뷰 모듈에 구현할 수 있다.

### CQRS 뷰 추가 업데이트
CQRS 뷰는 애플리케이션이 살아 있는 동안 계속 추가/수정될 것이다. 새 쿼리를 지원하기 위해 새 뷰를 추가해야 할 때가 있고, 스키마가 변경되거나 뷰 업데이트 코드의 버그를 조치하기 위해 뷰를 재생성해야 할 경우도 있을 것이다.

뷰를 추가/수정하는 작업은 개념만 보자면 간단하다. 새 뷰를 생성하려면 쿼리 쪽 모듈을 개발하고, 데이터 저장소를 세팅하고, 서비스를 배포한다. 쿼리 쪽 모듈의 이벤트 핸들러가 모든 이벤트를 처리하고 뷰는 언젠가 최신 상태가 될 것이다. 기존 뷰를 수정하는 작업도 이벤트 핸들러를 변경한 후 뷰를 재생성한다. 그러나 이 방법은 실제로 잘 통하지 않는다는 것이 문제다.

#### 아카이빙된 이벤트를 이용하여 CQRS 뷰 구축
우선 메시지 브로커는 메시지를 무기한 보관할 수 없다. 기존 메시지 브로커(RabbitMQ)는 컨슈머가 케시지를 처리한 직후 메시지를 삭제하며, 미리 설정된 시간 동안 메시지를 보관 가능한 최신 브로커(Apache Kafka) 역시 이벤트를 영구 보관하진 않는다. 그러므로 필요한 이벤트를 메시지 브로커에서 전부 읽기만 해선 뷰를 구축할 수 없다. 따라서 이를테면 AWS S3 같은 곳에 아카이빙된, 더 오래된 이벤트도 같이 가져와야 한다. Apache Spark처럼 확장 가능한 빅데이터 기술을 응용하면 가능하다.

#### CQRS 뷰를 단계적으로 구축
전체 이벤트를 처리하는 시간/리소스가 점점 증가하는 것도 뷰 생성의 또 다른 문제점이다. 결국 언젠가 뷰는 너무 느려지고 비용도 많이 들 것이다.

해결 방법은 2단계 증분 알고리즘을 적용하는 것이다.

- 1단계는 주기적으로 각 애그리거트 인스턴스의 스냅샷을 그 이전의 스냅샷과 이 스냅샷이 생성된 이후 쭉 발생한 이벤트를 바탕으로 계산한다.
- 2단계는 이렇게 계산된 스냅샷과 그 이후 발생한 이벤트를 이용해 뷰를 생성한다.

## 정리
- 각 서비스 데이터는 프라이빗하기 때문에 여러 서비스의 데이터를 가져오는 쿼리는 구현하기 쉽지 않다.
- 여러 서비스의 데이터를 조회하는 쿼리는 크게 API 조합 패턴과 커맨드 쿼리 책임 분리 패턴으로 구현한다.
- 여러 서비스에서 데이터를 취합하는 API 조합 패턴은 쿼리를 구현하기 가장 간편한 방법이므로 가능하면 많이 사용하는 것이 좋다.
- API 조합 패턴은 쿼리가 조금만 복잡해져도 대량 데이터를 인-메모리 조인해야 하므로 효율이 낮다.
- CQRS 패턴은 뷰 전용 DB를 이용하여 쿼리한다. 기능이 강력한 만큼 구현 복잡도는 비교적 높은 편이다.
- CQRS 뷰 모듈은 중복 이벤트 솎아 내기, 동시 업데이트 처리 기능을 갖춰야 한다.
- CQRS를 사용하면 한 서비스가 다른 서비스가 소유한 데이터를 반환하는 쿼리 구현도 가능하므로 관심사 분리 관점에서 유리하다.
- 클라이언트는 CQRS 뷰의 최종 일관성을 처리해야 한다.