# 7장. 마이크로서비스 쿼리 구현
마이크로서비스 아키텍처에선 의외로 쿼리를 작성하기 어렵다. 여러 서비스, 여러 DB에 분산된 데이터를 조회해야 하는데, 기존 분산 쿼리 메커니즘은 기술적으로 가능하다 해도 캡슐화에 위배되기 때문에 사용할 수 없다.

마이크로서비스 아키텍처에선 다음 두 가지 패턴으로 쿼리를 구현한다.

- API 조합 패턴: 서비스 클라이언트가 데이터를 가진 여러 서비스를 직접 호출하여 그 결과를 조합하는 패턴이다. 가장 단순한 방법으로 가급적 이 방법을 쓰는 것이 좋다.
- CQRS 패턴: 쿼리만 지원하는 하나 이상의 뷰 전용 DB를 유지하는 패턴이다. API 조합 패턴보다 강력한 만큼 구현하긴 더 복잡하다.

## API 조합 패턴 응용 쿼리
`findOrder()`는 기본키로 주문 정보를 조회하는 메서드다. `orderId`를 매개변수로 받아 주문 내역이 포함된 `OrderDetails` 객체를 반환한다. 주문 상태 뷰가 구현된, 모바일 기기 또는 웹 애플리케이션 등의 프론트엔드 모듈이 이 메서드를 호출한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/3d9e27ed-254c-4564-b793-3eeb75459765)

모놀리식 애플리케이션은 전체 데이터가 하나의 DB에 있기 때문에 알기 쉽게 `SELECT` 문으로 여러 테이블을 조인해서 주문 내역을 조회하면 된다. 반면 마이크로서비스 아키텍처로 전환하면 데이터가 여러 서비스에 뿔뿔이 흩어지게 된다.

- 주문 서비스: 주문 기본 정보
- 주방 서비스: 음식점 관점의 주문 상태, 픽업 준비까지 예상 소요 시간
- 배달 서비스: 주문 배달 상태, 배달 예상 정보, 현재 배달원 위치
- 회계 서비스: 주문 지불 상태

### API 조합 패턴 개요
API 조합 패턴은 데이터를 가진 서비스를 호출한 후 그 반환 결과를 조합해서 가져온다. 이 과정에는 다음 두 종류의 참여자가 개입한다.

- API 조합기: 프로바이더 서비스를 쿼리하여 데이터를 조회한다.
- 프로바이더 서비스: 최종 결과로 반환할 데이터의 일부를 갖고 있는 서비스

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/13d17910-f7ad-46e0-9d52-c88480f5d8d6)

API 조합기는 A, B, C 세 프로바이더 서비스에서 데이터를 조회한 후 그 결과를 조합한다. 이 조합기는 웹 애플리케이션처럼 웹 페이지에 데이털르 렌더링하는 클라이언트일 수도 있고, 쿼리 작업을 API 끝점으로 표출한 API 게이트웨이나 프론트엔드를 위한 백엔드 패턴의 변형일 수도 있다.

이 패턴으로 특정 쿼리 작업을 구현할 수 있을지 여부는 데이터가 어떻게 분할되었는지, 데이터를 가진 서비스가 어떤 API 기능을 표출하는지, 사용 중인 DB는 어떤 기능을 제공하는지 등 다양한 요인에 따라 가변적이다.

- 프로바이더 서비스가 필요한 데이터를 조회할 수 있는 API를 제공하더라도 애그리거트가 거대한 데이터 뭉치를 비효율적으로 인-메모리 조인을 해야 할 수도 있다.
- 이 패턴으로 구현할 수 없는 쿼리 작업도 있지만, 대부분의 경우 이 패턴을 적용해서 구현할 수 있다.

### API를 조합 패턴으로 findOrder() 쿼리 구현
`findOrder()`는 단순히 기본키로 EQUI 조인해서 쿼리하는 작업이다. `orderId`로 필요한 데이터를 가져올 수 있는 API 끝점은 각 프로바이더 서비스가 당연히 제공하리라 볼 수 있기 때문에 API 조합 패턴으로 구현하기 제격이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/0de74c6c-c43e-41da-a689-cfaeaaed92a0)

여기서 API 조합기는 쿼리를 REST 끝점으로 표출한 서비스다. HTTP 대신 gRPC 같은 다른 IPC 프로토콜을 사용하는 서비스 역시 개념은 같다. REST 끝점 `GET /order/{orderId}`가 구현된 주문 검색 조합기는 `orderId`로 네 서비스를 호출한 후 수신한 응답을 조인한다. 각 프로바이더 서비스는 애그리거트 하나에 해당하는 응답을 반환하는 REST 끝점을 제공한다. 주문 서비스는 기본키로 자신의 `Order`를 조회하고, 다른 서비스는 `orderId`를 외래키로 자신의 애그리거트를 조회하는 것이다.

### API 조합 설계 이슈
API 조합 패턴에는 두 가지 설계 이슈가 있다.

- 어느 컴포넌트를 쿼리 작업의 API 조합기로 선정할 것인가?
- 어떻게 해야 효율적으로 취합 로직을 작성할 것인가?

#### 누가 API 조합기 역할을 맡을 것인가?
우선 쿼리 작업의 API 조합기 역할을 누가 맡을지 결정해야 한다. 세 가지 옵션이 있다.

첫째, 서비스 클라이언트를 API 조합기로 임명하는 것이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/a34f9bf0-0183-490c-b01c-c55cdf8cc2a8)

- 주문 상태 뷰를 구현한 웹 애플리케이션 같은 클라이언트가 동일한 LAN에서 실행 중이라면 가장 효율적으로 주문 내역을 조회할 수 있다.
- 클라이언트가 방화벽 외부에 있고 서비스가 위치한 네트워크가 느리다면 그리 실용적이지 않다.

둘째, 애플리케이션 외부 API가 구현된 API 게이트웨이를 API 조합기로 만드는 것이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/86b40932-ce77-43dc-877b-9dbe69a0b783)

- 쿼리 작업이 애플리케이션의 외부 API 중 일부라면 이 방법이 타당하다.
- 다른 서비스로 요청을 보내는 대신 차라리 API 게이트웨이에 API 조합 로직을 구현하는 것이다.
- 모바일 기기 등 방화벽 외부에서 접근하는 클라이언트가 API 호출 한 번으로 여러 서비스의 데이터를 조회할 수 있기 때문에 효율적이다.

셋째, API 조합기를 스탠드얼론 서비스로 구현하는 것이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/bb9a6314-5daf-4489-ab00-fc61e88aec1a)

- 내부적으로 여러 서비스가 사용하는 쿼리 작업이면 이 방법이 좋다.
- 취합 로직이 너무 복잡해서 API 게이트웨이 일부로 만들기는 곤란하고 외부에서 접근 가능한 쿼리 작업을 구현할 경우에도 좋은 방법이다.

#### API 조합기는 리액티브 프로그래밍 모델을 사용해야 한다
분산 시스템을 개발할 때 **지연 시간을 최소화하는 문제**는 항상 골칫거리다. **쿼리 작업의 반응 시간을 최대한 줄이려면 가능한 한 API 조합기가 프로바이더 서비스를 병렬 호출해야 한다.** 가령 주문 검색 애그리거트는 호출 대상인 네 서비스가 서로 의존 관계가 없기 때문에 동시 호출하는 것이 맞다. 하지만 어떤 프로바이더 서비스를 호출하기 위해 다른 프로바이더 서비스의 결과를 먼저 가져와야 하는 경우도 있다. 이럴 땐 일부 프로바이더 서비스를 순차 호출해야 한다.

그러나 순차/병렬 서비스 호출이 뒤섞인 실행 로직은 복잡해질 수 있다. 관리가 용이하고 성능/확장성도 우수한 API 조합기를 작성하려면 Java의 `CompletableFuture`, RxJava의 `observable`, 또는 이와 동등한 추상체에 기반한 리액티브 설계 기법을 동원해야 한다.

### API 조합 패턴의 장단점
API 조합 패턴은 MSA에서 아주 쉽고 단순하게 쿼리 작업을 구현할 수 있게 해주지만, 다음과 같은 단점도 있다.

- 오버헤드 증가
- 가용성 저하 우려
- 데이터 일관성 결여

#### 오버헤드는 증가한다
- 여러 서비스를 호출하고 여러 DB를 쿼리하는 오버헤드는 불가피하다.
- 그만큼 컴퓨팅/네트워크 리소스가 더 많이 소모되고 애플리케이션 운영 비용도 늘어난다.

#### 가용성이 저하될 우려가 있다
- 어떤 작업의 가용성은 더 많은 서비스가 개입할수록 감소한다.
- 하나의 쿼리 작업에 세 서비스(API 조합기 + 둘 이상의 프로바이더 서비스)가 반드시 개입되는 구조라서 하나의 서비스로 처리하는 것에 비해 가용성은 현저히 낮다.

가용성을 높이는 전략은 다음과 같다.

- 프로바이더 서비스가 불능일 경우 API 조합기가 이전에 캐시한 데이터를 반환하는 것이다.
  - 성능 향상을 목적으로 API 조합기에 캐시된, 프로바이더 서비스의 반환 데이터를 잘 활용하면 가용성을 끌어올릴 수 있다.
  - 프로바이더 서비스가 내려가더라도 API 조합기는 오래 되어 맞지 않는 데이터도 있겠지만 캐시 데이터를 반환할 수 있다.
- API 조합기가 미완성된 데이터를 반환하는 것이다.
  - 가령 주방 서비스가 일시 불능 상태가 되면 주문 검색 조합기가 이 서비스의 데이터만 제외한 나머지 데이터를 반환한다.
  - 주방 서비스 데이터가 없어도 UI에서 유용한 정보를 표시하는 데는 별 지장이 없기 때문이다.

#### 데이터 일관성이 결여된다
모놀리식 애플리케이션은 대부분 한 트랜잭션으로 쿼리를 수행한다. ACID 트랜잭션은 애플리케이션이 여러 DB에 쿼리를 실행해도 데이터를 일관되게 바라볼 수 있게 보장한다. 그러나 API 조합 패턴은 여러 DB를 대상으로 여러 쿼리를 실행하기 때문에 일관되지 않은 데이터가 반환될 수 있다.

- 주문 서비스가 조회한 주문 상태는 `CANCELLED`이지만, 주방 서비스가 조회한 이 주문의 티켓은 아직 취소되지 않았을 수 있다.

API 조합기는 이런 모순을 해결해야 하는데, 그러면 코드가 점점 더 복잡해진다. 게다가 이런 모슨된 데이터를 API 조합기가 항상 감지할 수 있는 것은 아니라서 잘못된 데이터가 그대로 클라이언트에 반환될 수도 있다.

효율적으로 구현하기 어려운 쿼리(거대한 데이터 뭉치를 인-메모리 조인하는 쿼리)는 CQRS 패턴으로 구현하는 것이 바람직하다.

## CQRS 패턴
엔터프라이즈 애플리케이션은 대부분 RDBMS에 트랜잭션을 걸어 레코드를 관리하고, 텍스트 검색 쿼리는 ElasticSearch나 솔라 등의 텍스트 검색 DB를 이용해서 구현한다. 애플리케이션에 따라 RDBMS와 텍스트 검색 DB를 모두 출력하여 동기화하기도 하고, 주기적으로 RDBMS에서 텍스트 검색 DB로 데이터를 복사하는 경우도 있다.

이런 아키텍처로 구축하는 이유는 여러 DB의 장점을 최대한 활용하자는 의도다. 즉, RDBMS 특유의 트랜잭션 기능과 텍스트 검색 DB의 탁월한 쿼리 능력을 융합하여 활용하는 것이다.

CQRS는 이런 종류의 아키텍처를 일반화한 것이다. 하나 이상의 쿼리가 구현된 하나 이상의 뷰 DB를 유지하는 기법이다.

### CQRS의 필요성
`findOrderHistory()`는 다음 매개변수를 받아 소비자의 주문 이력을 조회하는 쿼리 작업이다.

- `consumerId`: 소비자 식별자
- `OrderHistoryFilter`: 필터 조건. 어느 시점 이후 주문까지 반환할 것인가(필수), 주문 상태(옵션), 음식점명 및 메뉴 항목을 검색할 키워드(옵션)

겉보기에 `findOrder()`와 비슷하지만 단건 주문 정보가 아닌, 다건 주문 목록을 반환하는 차이점이 있다. API 조합기로 각 프로바이더 서비스에 똑같은 쿼리를 실행한 결과를 조합하면 간단할 것 같지만, 그렇게 간단하지 않다.

모든 서비스가 필터/정렬 용도의 속성을 보관하는 것이 아니기 때문이다. 이를테면 `findOrderHistory()`의 `OrderHistoryFilter`에는 메뉴 항목과 매치할 `keywords`라는 속성이 있다. 하지만 메뉴 항목을 저장하는 서비스는 주문 서비스, 주방 서비스 2개뿐이고, 나머지 배달 서비스, 회계 서비스는 메뉴 항목을 저장하지 않기 때문에 데이터를 필터할 수 없다. 마찬가지로 주방 서비스, 배달 서비스 둘 다 `orderCreationDate` 속성으로 정렬하는 것은 불가능하다.

API 조합기는 이 문제를 두 가지 방법으로 해결할 수 있다.

- API 조합기로 데이터를 인-메모리 조인을 한다. 그러나 거대한 데이터 뭉치를 이런식으로 API 조합기에서 조인하면 급격히 효율이 떨어질 것이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/c3108fae-44dd-4fe2-90bf-5c4dc376ee3a)

- API 조합기로 주문 서비스, 주방 서비스에서 데이터를 조회하고, 주문 ID를 이용해 다른 서비스에 있는 데이터를 요청한다. 하지만 이는 해당 서비스가 대량 조회 API를 제공할 경우에만 현실성 있는 방법이다. 그렇다고 주문 데이터를 하나하나 요청하는 것은 과도한 네트워크 트래픽이 유발되어 비효율적이다.

`findOrderHistory()` 같은 쿼리 작업은 API 조합기로 하여금 이미 RDBMS 쿼리 실행 엔진에 탑재된 기능을 재탕하는 것밖에 안된다. 작업 자체를 확장성 낮은 DB에서 확장성 높은 애플리케이션으로 이동시키는 의미는 있으나 비효율적이다.

#### 어려운 단일 서비스 쿼리: findAvailableRestaurants()
하나의 서비스에 국한된 쿼리도 구현하기 어려운 경우가 있다.

- 데이터를 가진 서비스에 쿼리를 구현하는 것이 부적절한 경우
- 서비스 DB 또는 데이터 모델이 효율적인 쿼리를 지원하지 않는 경우

책에서 설명하는 예시는 지리 공간을 검색하는 기능 개발이다. 지리 공간 확장팩을 제공해주는 DB를 사용하면 쉽게 구현 가능하지만, 지원하지 않는다면 까다롭다. 음식점 데이터의 레플리카를 지리 공간 쿼리에 맞게 설계된 형태로 유지할 수 밖에 없다. 문제는 원본 데이터가 변경될 때마다 레플리카를 항상 최신으로 유지하는 일이다. 다행히 레플리카를 동기화하는 문제는 CQRS로 해결할 수 있다.

#### 관심사를 분리할 필요성
단일 서비스 쿼리가 구현하기 까다로운 또 다른 이유는 **데이터를 가진 서비스에 쿼리를 구현하면 안 될 때가 있기 때문**이다. `findAvailableRestaurants()`는 음식점 서비스에 있는 데이터를 조회하는 쿼리 작업이다. 언뜻 보면 음식점 데이터를 가진 음식점 서비스에 쿼리를 구현해야 할 것처럼 느껴지지만, 이는 데이터 소유권만 보고 판단할 문제는 아니다.

**관심사를 어떻게 분리하면 좋을 지, 어느 한 서비스에 너무 많은 책임을 부과하지 않으려면 어떻게 해야 할까 하는 문제도 함께 고민해야 한다.**

- 음식점 서비스 개발 팀의 주 업무는 음식점 주인이 자기가 운영하는 음식점을 잘 관리할 수 있게 해주는 서비스를 개발하는 일이지, 성능이 매우 중요한 대용량 데이터를 조회하는 쿼리를 구현하는 일은 아니다.
- 이 팀의 개발자가 `findAvailableRestaurants()` 개발까지 담당할 경우, 나중에 자신이 변경할 코드를 배포할 때 사이드이펙트가 생기진 않을지 불안에 시달리게 될 것이다.

`findAvailableRestaurants()` 쿼리는 다른 팀(주문 서비스 개발팀)이 구현하고 음식점 서비스는 검색할 음식점 데이터만 제공하는 구조가 낫다. `findOrderHistory()` 쿼리 작업 처럼 지리 공간 인덱스를 유지해야 할 경우라면, 쿼리 구현을 위해 일부 데이터의 레플리카는 최종 일관된 형태를 유지해야 한다.

### CQRS 개요
MSA에선 쿼리를 구현할 때 다음 세 가지 난관에 봉착하게 된다.

- API를 조합하여 여러 서비스에 흩어진 데이터를 조회하려면 값비싸고 비효율적인 인-메모리 조인을 해야 한다.
- 데이터를 가진 서비스는 필요한 쿼리를 효율적으로 지원하지 않는 DB에 또는 그런 형태로 데이터를 저장한다.
- 관심사를 분리할 필요가 있다는 것은 데이터를 가진 서비스가 쿼리 작업을 구현할 장소로 적합하지 않다는 뜻이다.

이 문제들을 해결할 수 있는 방법이 CQRS 패턴이다.

#### CQRS는 커맨드와 쿼리를 서로 분리한다
이는 이름처럼 관심사의 분리/구분에 관한 패턴이다.

**영속적 데이터 모델과 그것을 사용하는 모듈을 커맨드와 쿼리, 두 편으로 가른다.**

- 조회(R) 기능은 쿼리 쪽 모듈 및 데이터 모델에 구현
- 생성/수정/삭제(CUD) 기능은 커맨드 쪽 모듈 및 데이터 모델에 구현
- 양쪽 데이터 모델 사이의 동기화는 커맨드 쪽에서 발행한 이벤트를 쿼리 쪽에서 구독하는 식으로 이루어진다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/1894624f-7256-476c-b110-dde4b84d3358)

CQRS 패턴과 상관없이 거의 모든 서비스는 다양한 CRUD 작업이 구현된 API를 갖고 있다. 비 CQRS 서비스에선 이런 작업을 보통 DB에 매핑된 도메인 모델로 구현한다. 성능이 중요한 쿼리는 도메인 모델을 건너뛰고 직접 DB에 접속하기도 한다. 하나의 영속적 데이터 모델은 커맨드와 쿼리를 모두 지원한다.

- 커맨드 쪽 도메인 모델은 CRUD 작업을 처리하고 자체 DB에 매핑된다.
- 조인 없는 단순 쿼리와 기본키 기반의 쿼리도 처리할 수 있다.
- 커맨드 쪽은 데이터가 바뀔 때마다 이벤트 소싱 등의 프렝ㅁ워크를 이용해 도메인 이벤트를 발행한다.
- 별도로 나뉘어진 쿼리 모델은 다소 복잡한 쿼리를 처리한다.
- 쿼리 쪽은 반드시 지원해야 하는 쿼리에 대해선 모든 종류의 DB를 지원한다.
- 쿼리 쪽에는 도메인 이벤트를 구독하고 DB(들)를 업데이트하는 이벤트 핸들러가 있다.
- 쿼리 종류마다 쿼리 모델을 하나씩 가진 다중 쿼리 모델도 있다.

#### CQRS와 쿼리 전용 서비스
CQRS는 서비스 내부에 적용할 수 있을 뿐만 아니라, 이 패턴을 이용해 쿼리 서비스를 정의하는 것도 가능하다. **쿼리 서비스엔 커맨드 작업이 전혀 없는 오직 쿼리 작업만으로 구성된 API가 있고, 하나 이상의 다른 서비스가 발행한 이벤트를 구독하여 항상 최신 상태로 유지되는 DB를 쿼리하는 로직이 구현되어 있다.**

쿼리 쪽 서비스는 여러 서비스가 발행한 이벤트를 구독해서 구축된 뷰를 구현하기 좋은 방법이다. 이런 뷰는 특정 서비스에 종속되지 않기 때문에 스탠드얼론 서비스로 구현하는 것이 타당하다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/a4f99c25-6799-4c37-a184-f3d2d9f2b1c0)

주문 이력 서비스는 여러 서비스가 발행한 이벤트를 구독하고 주문 이력 뷰 DB를 업데이트하는 이벤트 핸들러를 갖고 있다.

- 쿼리 서비스는 한 서비스가 가진 데이터를 복제한 뷰를 구현하는 수단으로도 유용하다.
- 여러 면에서 CQRS는 RDBMS를 기록 시스템으로 활용하면서 텍스트 검색 엔진을 이용하여 텍스트 검색 쿼리를 처리하는 대중적인 접근 방식을 이벤트를 기반으로 일반화한 것이라 볼 수 있다.
- 다만 CQRS는 텍스트 검색 엔진뿐만 아니라 훨씬 다양한 종류의 DB를 활용할 수 있다는 차이점이 있다.
- CQRS 쿼리 쪽 뷰는 이벤트를 구독해서 거의 실시간으로 업데이트된다.

### CQRS의 장점
- 마이크로서비스 아키텍처에서 쿼리를 효율적으로 구현할 수 있다.
- 다양한 쿼리를 효율적으로 구현할 수 있다.
- 이벤트 소싱 애플리케이션에서 쿼리가 가능하다.
- 관심사가 더 분리된다.

### CQRS의 단점
- 아키텍처가 더 복잡하다.
- 복제 시차를 처리해야 한다.

클라이언트 애플리케이션이 애그리거트를 업데이트한 즉시 뷰를 쿼리하면 이전 버전의 애그리거트를 바라보게 될 수도 있다. 이렇게 일관되지 않은 데이터가 최대한 사용자에게 노출되지 않도록 애플리케이션을 개발해야 한다. 한 가지 방법은 커맨드/쿼리 양쪽 API가 클라이언트에 버전 정보를 전달해서 김빠진 데이터를 분간할 수 있게 만드는 것이다.

네이티브 모바일 앱이나 SPA 같은 UI 애플리케이션은 쿼리를 하지 않고 커맨드가 성공하면 자신의 로컬 모델을 업데이트하는 방법으로 복제 시차를 해소할 수 있다. 커맨드가 반환한 데이터로 자체 모델을 업데이트하는 것이다. 별다른 문제가 없다면 사용자 액션으로 쿼리가 트리거될 때 뷰는 최신 상태가 될 것이다. 하지만 모델을 업데이트하려면 UI 코드가 서버 쪽 코드를 복제해야 한다는 단점이 있다.

가능한 한 API 조합 패턴을 사용하고, 꼭 필요할 경우에 한하여 CQRS를 사용하자.

## CQRS 뷰 설계
CQRS 뷰 모듈에는 하나 이상의 쿼리 작업으로 구성된 API가 있다. 하나 이상의 서비스가 발행한 이벤트를 구독해서 최신 상태로 유지된 DB를 조회하는 쿼리 API다. 뷰 모듈은 뷰 DB와 세 하위 모듈로 구성된다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/434c45cc-16b4-4809-9436-649d3056a52a)

이벤트 핸들러, 쿼리 API 모듈은 데이터 접근 모듈을 통해 DB를 조회/수정한다. 이벤트 핸들러 모듈은 이벤트를 구독해서 DB를 업데이트하고, 쿼리 API 모듈은 데이터를 조회한다.

뷰 모듈을 개발할 땐 몇 가지 중요한 설계 결정을 해야 한다.

- DB를 산정하고 스키마를 설계해야 한다.
- 데이터 접근 모듈을 설계할 때 멱등한/동시 업데이트 등 다양한 문제를 고려해야 한다.
- 기존 애플리케이션에 새 뷰를 구현하거나 기존 스키마를 바꿀 경우, 뷰를 효율적으로 (재)빌드할 수 있는 수단을 강구해야 한다.
- 뷰 클라이언트에서 복제 시차를 어떻게 처리할 지 결정해야 한다.

### 뷰 DB 선택
