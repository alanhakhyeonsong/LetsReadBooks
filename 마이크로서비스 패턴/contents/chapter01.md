# 1장. 모놀리식 지옥에서 벗어나라
![image](https://user-images.githubusercontent.com/60968342/236966673-6ed0713b-e896-46ef-9843-33ec258dcfc2.png)

앞으로도 계속 예시로 볼 가상의 회사인 FTGO는 위와 같은 구조로 시스템을 사용하고 있다. FTGO가 제공하는 REST API와 UI 어댑터로 어플리케이션은 내부적으로 각종 비즈니스 로직을 처리하고, MySQL 어댑터를 통해 DB에 저장하거나, 사용중인 클라우드서비스를 호출해주는 어댑터를 쓰는 모습을 보여준다.

FTGO의 모듈을 이루는 모듈조직들은 하나의 소스코드저장소에 저장을 하고, 모든 모듈이 통합된 하나의 WAR파일을 실제 어플리케이션으로 구동하여 서비스를 운영한다.

## 모놀리식 아키텍처의 장점
- 개발이 간단하다: IDE 등 개발 툴은 단일 애플리케이션 구축에 초점이 맞춰짐
- 애플리케이션을 쉽게 변경할 수 있다: 코드, DB 스키마를 변경해서 빌드/배포하기 용이하다
- 테스트하기 쉽다: 개발자가 애플리케이션을 띄우고, REST API를 호출하고, Selenuim으로 UI를 시험하는 종단 간 테스트를 작성한다
- 배포하기 쉽다: 개발자는 서버에 접속하여 톰캣 설치 경로에 WAR 파일을 복사하면 그만이다
- 확장하기 쉽다: load balancer 뒷면에 애플리케이션 인스턴스를 여러 개 실행한다

## 모놀리식 지옥의 실상
![image](https://user-images.githubusercontent.com/60968342/236968496-2505c297-656c-4a36-8424-c3090bbf836e.png)

개발자가 오나전히 이해할 수 없을 정도로 내용이 방대해서 버그를 고치고 새 기능을 정확하게 구현하기가 갈수록 힘들고 시간도 오래걸린다. 복잡도는 하위로 내려갈수록 더욱 심화된다.

애플리케이션이 너무 커져서 개발자의 IDE의 실행 속도도 느려지고, 자연히 빌드 시간도 오래걸린다. 게다가 비대한 몸집에 걸맞게 한 번 시동하는 것도 적잖은 시간이 필요하다. Refactoring, Build/Run, Test의 과정에서 너무 많은 시간이 낭비되어 생산성이 떨어진다.

branch 전략을 사용하더라도 merge 단계 또한 험난해서 한 팀이 스프린트를 마치면 곧바로 길고 긴 테스트 및 코드 안정화 기간이 필요하다. 테스트가 실패하면 원인을 찾고 조치하는 데 시간이 많이 걸려 한 사이클을 완료하는 테스트에만 2~3일이 걸린다.

애플리케이션은 모듈마다 리소스 요건이 서로 맞지 않아 확장하기 어렵다. 예시로 데이터 용량이 큰 음식점 데이터는 인-메모리 DB 형태로 저장하는데, 이런 DB는 메모리 칩이 많이 장착된 서버에 배포하는 것이 좋지만, 이미지 처리 모듈은 CPU를 집중 소모하므로 CPU 코어 수가 많은 서버에 배포하는 것이 최적이다. 이처럼 리소스 요건이 상이한 모듈이 존재하므로 서버 구성 시 리소스 배분을 신경 써야 한다.

신뢰성이 부족한 것도 문제이다. 애플리케이션 자체가 워낙 커서 철저하게 테스트하기 어렵고, 그 결과 프로덕션에 버그가 발생할 가능성이 높다. 전체 모듈이 같은 프로세스로 실행되는 까닭에 결함 격리(fault isolation)가 되지 않고, 어떤 모듈에 버그 하나만 있어도 메모리 누수가 발생해서 전체 애플리케이션 인스턴스가 내려가는 일도 드물지 않다.

마지막으로, 모놀리식 지옥에선 아키텍처 때문에 어쩔 수 없이 점점 한물간 기술 스택을 쓸 수밖에 없고, 그 특성상 새로운 프레임워크, 새로운 프로그래밍 언어를 받아들이기 어렵다. 신기술을 사용하기 위해 전체 애플리케이션을 재작성하는 것은 비용도 비용이며, 리스크가 높기 때문에 어쩔 수 없는 상황이다.

## 마이크로서비스 아키텍처가 답이다
![image](https://user-images.githubusercontent.com/60968342/236968764-88a67726-ed6f-4b60-a3da-ecb302020f0d.png)

저자가 마이크로서비스 아키텍처에 영감을 받았다는 아래의 확장큐브라는 모델을 보자. 확장큐브의 모델에 따르면 어플리케이션을 X,Y,Z축 세 방향으로 확장시킬 수 있다.

### X축 확장: 다중 인스턴스에 고루 요청 분산
X축 확장은 일반적인 모놀리식 애플리케이션의 확장 수단이다. 로드 밸런서 뒷면에 애플리케이션 인스턴스를 N개 띄워 놓고 부하 분산기는 들어온 요청을 이들 인스턴스에 고루 분배한다. 애플리케이션 능력과 가용성을 개선할 수 있는 훌륭한 방법이다.

### Z축 확장: 요청 속성별 라우팅
X축 확장에서 인스턴스 단위로 부하를 분산시켰지만, 분산 이전에 라우터를 통해서 지정된 인스턴스별로도 요청을 나눔으로써, 트랜잭션이나 데이터볼륨을 처리하기 위한 확장방안으로 볼 수 있다.

### Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해
X축과 Z축은 어플리케이션의 가용성을 높였지만 복잡성은 해결시킬 수 없다. Y축확장은 모놀리식 어플리케이션을 여러 서비스로 나누는것을 의미한다.

![image](https://user-images.githubusercontent.com/60968342/236970003-8738b5f6-0217-4f67-ab94-465e0ef5ddc8.png)

위 그림에서 확인할 수 있는 것은 Order Service, Customer Service, Review Service 라는 서비스단위로 분리한 Y축의 역할, 그리고 서비스의 요청은 로드밸런서를 통해 X축을 확장시키거나, 필요시 Z축으로 인스턴스의 리소스를 차등적으로 분배하여 시스템을 확장시킬 수 있다는 것이다.

넓은 관점에서 바라보면 마이크로서비스 아키텍처는 하나의 어플리케이션을 여러 서비스로 기능을 분해하는 아키텍처 스타일이다. 여기서 어플리케이션을 나누는 것은 규모가 아닌 서비스 도메인을 기준으로 책임을 가진다는 것이다.

## 마이크로서비스의 특징
### 마이크로서비스는 모듈성을 갖고 있다


### 서비스마다 DB가 따로 있다

### 마이크로서비스 아키텍처와 SOA

## 마이크로서비스 아키텍처의 장단점
![image](https://user-images.githubusercontent.com/60968342/236967020-2a313450-7c05-44dc-a554-4dd7b26e33e5.png)