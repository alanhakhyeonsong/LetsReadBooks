# 1장. 모놀리식 지옥에서 벗어나라
![image](https://user-images.githubusercontent.com/60968342/236966673-6ed0713b-e896-46ef-9843-33ec258dcfc2.png)

앞으로도 계속 예시로 볼 가상의 회사인 FTGO는 위와 같은 구조로 시스템을 사용하고 있다. FTGO가 제공하는 REST API와 UI 어댑터로 어플리케이션은 내부적으로 각종 비즈니스 로직을 처리하고, MySQL 어댑터를 통해 DB에 저장하거나, 사용중인 클라우드서비스를 호출해주는 어댑터를 쓰는 모습을 보여준다.

FTGO의 모듈을 이루는 모듈조직들은 하나의 소스코드저장소에 저장을 하고, 모든 모듈이 통합된 하나의 WAR파일을 실제 어플리케이션으로 구동하여 서비스를 운영한다.

## 모놀리식 아키텍처의 장점
- 개발이 간단하다: IDE 등 개발 툴은 단일 애플리케이션 구축에 초점이 맞춰짐
- 애플리케이션을 쉽게 변경할 수 있다: 코드, DB 스키마를 변경해서 빌드/배포하기 용이하다
- 테스트하기 쉽다: 개발자가 애플리케이션을 띄우고, REST API를 호출하고, Selenuim으로 UI를 시험하는 종단 간 테스트를 작성한다
- 배포하기 쉽다: 개발자는 서버에 접속하여 톰캣 설치 경로에 WAR 파일을 복사하면 그만이다
- 확장하기 쉽다: load balancer 뒷면에 애플리케이션 인스턴스를 여러 개 실행한다

## 모놀리식 지옥의 실상
![image](https://user-images.githubusercontent.com/60968342/236968496-2505c297-656c-4a36-8424-c3090bbf836e.png)

개발자가 오나전히 이해할 수 없을 정도로 내용이 방대해서 버그를 고치고 새 기능을 정확하게 구현하기가 갈수록 힘들고 시간도 오래걸린다. 복잡도는 하위로 내려갈수록 더욱 심화된다.

애플리케이션이 너무 커져서 개발자의 IDE의 실행 속도도 느려지고, 자연히 빌드 시간도 오래걸린다. 게다가 비대한 몸집에 걸맞게 한 번 시동하는 것도 적잖은 시간이 필요하다. Refactoring, Build/Run, Test의 과정에서 너무 많은 시간이 낭비되어 생산성이 떨어진다.

branch 전략을 사용하더라도 merge 단계 또한 험난해서 한 팀이 스프린트를 마치면 곧바로 길고 긴 테스트 및 코드 안정화 기간이 필요하다. 테스트가 실패하면 원인을 찾고 조치하는 데 시간이 많이 걸려 한 사이클을 완료하는 테스트에만 2~3일이 걸린다.

애플리케이션은 모듈마다 리소스 요건이 서로 맞지 않아 확장하기 어렵다. 예시로 데이터 용량이 큰 음식점 데이터는 인-메모리 DB 형태로 저장하는데, 이런 DB는 메모리 칩이 많이 장착된 서버에 배포하는 것이 좋지만, 이미지 처리 모듈은 CPU를 집중 소모하므로 CPU 코어 수가 많은 서버에 배포하는 것이 최적이다. 이처럼 리소스 요건이 상이한 모듈이 존재하므로 서버 구성 시 리소스 배분을 신경 써야 한다.

신뢰성이 부족한 것도 문제이다. 애플리케이션 자체가 워낙 커서 철저하게 테스트하기 어렵고, 그 결과 프로덕션에 버그가 발생할 가능성이 높다. 전체 모듈이 같은 프로세스로 실행되는 까닭에 결함 격리(fault isolation)가 되지 않고, 어떤 모듈에 버그 하나만 있어도 메모리 누수가 발생해서 전체 애플리케이션 인스턴스가 내려가는 일도 드물지 않다.

마지막으로, 모놀리식 지옥에선 아키텍처 때문에 어쩔 수 없이 점점 한물간 기술 스택을 쓸 수밖에 없고, 그 특성상 새로운 프레임워크, 새로운 프로그래밍 언어를 받아들이기 어렵다. 신기술을 사용하기 위해 전체 애플리케이션을 재작성하는 것은 비용도 비용이며, 리스크가 높기 때문에 어쩔 수 없는 상황이다.

## 마이크로서비스 아키텍처가 답이다
![image](https://user-images.githubusercontent.com/60968342/236968764-88a67726-ed6f-4b60-a3da-ecb302020f0d.png)

저자가 마이크로서비스 아키텍처에 영감을 받았다는 아래의 확장큐브라는 모델을 보자. 확장큐브의 모델에 따르면 어플리케이션을 X,Y,Z축 세 방향으로 확장시킬 수 있다.

### X축 확장: 다중 인스턴스에 고루 요청 분산
X축 확장은 일반적인 모놀리식 애플리케이션의 확장 수단이다. 로드 밸런서 뒷면에 애플리케이션 인스턴스를 N개 띄워 놓고 부하 분산기는 들어온 요청을 이들 인스턴스에 고루 분배한다. 애플리케이션 능력과 가용성을 개선할 수 있는 훌륭한 방법이다.

### Z축 확장: 요청 속성별 라우팅
X축 확장에서 인스턴스 단위로 부하를 분산시켰지만, 분산 이전에 라우터를 통해서 지정된 인스턴스별로도 요청을 나눔으로써, 트랜잭션이나 데이터볼륨을 처리하기 위한 확장방안으로 볼 수 있다.

### Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해
X축과 Z축은 어플리케이션의 가용성을 높였지만 복잡성은 해결시킬 수 없다. Y축확장은 모놀리식 어플리케이션을 여러 서비스로 나누는것을 의미한다.

![image](https://user-images.githubusercontent.com/60968342/236970003-8738b5f6-0217-4f67-ab94-465e0ef5ddc8.png)

위 그림에서 확인할 수 있는 것은 Order Service, Customer Service, Review Service 라는 서비스단위로 분리한 Y축의 역할, 그리고 서비스의 요청은 로드밸런서를 통해 X축을 확장시키거나, 필요시 Z축으로 인스턴스의 리소스를 차등적으로 분배하여 시스템을 확장시킬 수 있다는 것이다.

넓은 관점에서 바라보면 마이크로서비스 아키텍처는 하나의 어플리케이션을 여러 서비스로 기능을 분해하는 아키텍처 스타일이다. 여기서 어플리케이션을 나누는 것은 규모가 아닌 서비스 도메인을 기준으로 책임을 가진다는 것이다.

## 마이크로서비스의 특징
### 마이크로서비스는 모듈성을 갖고 있다
모듈성은 크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성이다. 요즘 애플리케이션은 규모가 방대하고 내용이 너무 복잡해서 어느 한 개인이 전부 다 이해하고 개발할 수 없다. 따라서 여러 사람이 이해하고 개발할 수 있게 애플리케이션을 여러 모듈로 분해한다. 모놀리식 애플리케이션은 프로그래밍 언어 구성체(ex. java package)와 빌드 아티팩트(ex. java jar 파일)를 조합한 단위로 모듈을 정의하지만 실제로 이런 접근 방식은 문제가 많다.

**마이크로서비스 아키텍처는 서비스를 모듈성의 단위로 사용한다.** 각 서비스는 다른 서비스가 함부로 규칙을 어기고 침투하지 못하게 API라는 경계선을 갖고 있어서 다른 서비스 API를 우회하여 그 내부 클래스에 마음대로 들어올 수 없다.

**또 서비스를 빌딩 블록처럼 사용하여 독립적으로 배포/확장할 수 있는 부가적인 장점도 있다.**

### 서비스마다 DB가 따로 있다
**마이크로서비스는 서로 느슨하게 결합되어 있고 오직 API를 통해서만 통신한다.** 이렇게 느슨하게 결합된 서비스는 각각 자체 DB를 갖고 있다. 주문 서비스는 ORDERS 테이블이 있는 DB를, 고객 서비스는 CUSTOMERS 테이블이 있는 DB를 각자 소유한다. 이렇게 하면 개발 단계에서 다른 서비스 개발자와 일일이 협의하지 않고도 개발자 본인이 담당한 서비스 스키마를 변경할 수 있다.

**런타임에 서비스는 서로 완전히 분리되어 있기 때문에, 이를테면 다른 서비스가 DB 락을 획득해 내 서비스를 블로킹하는 일 따위는 일어나지 않는다.**

### 마이크로서비스 아키텍처와 SOA
마이크로서비스 아키텍처는 SOA(Service Oriented Architecture)와 별반 다를 것이 없다. 전혀 새로운 것이 아니다.

|구분|SOA|마이크로서비스|
|--|--|--|
|서비스간 통신|SOAP, WS 표준처럼 무거운 프로토콜을 응용한 엔터프라이즈 서비스 버스 중심의 스마트 파이프(smart pipe)|REST나 gRPC처럼 가벼운 프로토콜을 응용한 메시지 브로커 또는 서비스 간 통신 중심의 덤 파이프(dumb pipe)|
|데이터|전역 데이터 모델 및 공유 DB|서비스 개별 데이터 모델 및 DB|
|주요 사례|대규모 모놀리식 애플리케이션|소규모 서비스|

일반적으로 SOA, MSA는 사용하는 기술 스택이 다르다. SOA는 SOAP, WS 표준 등 무거운 기술을 주로 쓰고, 서비스를 통합하는 비즈니스와 메시지 처리 로직이 포함된 ESB라는 스마트 파이프를 활용한다.  
MSA는 대개 가벼운 오픈 소스 기술을 사용하며, 메시지 브로커나 REST 또는 gRPC처럼 가벼운 프로토콜 위주의 덤 파이프를 통해 서비스간 통신을 한다.

## 마이크로서비스 아키텍처의 장단점
MSA는 다음과 같은 장점이 있다.
- 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있다.
- 서비스 규모가 작아 관리하기 쉽다.
- 서비스를 독립적으로 배포/확장할 수 있다.
- 마이크로서비스 아키텍처 덕분에 팀이 자율적으로 움직인다.
- 결함 격리가 잘된다.
- 새로운 기술을 실험하고 도입하기 쉽다.

![image](https://user-images.githubusercontent.com/60968342/236967020-2a313450-7c05-44dc-a554-4dd7b26e33e5.png)

하지만 단점도 존재한다.
- 딱 맞는 서비스를 찾기가 쉽지 않다.
- 분산 시스템은 너무 복잡해서 개발, 테스트, 배포가 어렵다.
- 여러 서비스에 걸친 기능을 배포할 때에는 잘 조정해야 한다.
- 마이크로서비스 아키텍처 도입 시점을 결정하기가 어렵다.

## 마이크로서비스 아키텍처 패턴 언어
아키텍처와 설계는 전부 결정하기 나름이다. 모놀리식 아키텍처가 잘 맞을지, 마이크로서비스 아키텍처가 잘 맞을지 결정하려면 수많은 트레이드오프를 검토해야 하고, 그 결과 마이크로서비스를 채택했다면 그에 수반하는 갖가지 이슈도 해결해야 한다.

결정에 가장 좋은 방법은 패턴언어를 사용하는 것이다.

- 패턴: 특정한 상황에서 발생한 문제에 대한 재사용 가능한 해법
- 패턴 언어: 특정 영역 내부에서 문제를 해결하는 연관된 패턴의 집합

패턴은 자신이 적용되는 맥락을 반드시 기술해야 한다는 점에서 가치가 크다. 패턴이 제시한 솔루션이 어떤 맥락에서는 통하지만 또 다른 맥락에선 전혀 통하지 않을 수도 있다. 자주 간과되는 솔루션의 측면도 함께 기술하도록 강제한다는 점에서 효용성 또한 크다.

상용 패턴의 구조는 다음 세 부분으로 구성된다.
- 강제 조항: 문제 해결을 위해 반드시 처리해야 할 이슈  
  모든 조항을 전부 충족할 수는 없고, 어느 조항이 더 중요한지는 맥락에 따라 다르므로 우선순위를 정해야 한다. 강제 조항을 명시적으로 나열하면 어느 이슈를 해결해야 할지 명확해진다.
- 결과 맥락: 패턴 적용 결과
  - 장점: (해결된 강제 조항 등) 패턴의 좋은 점
  - 단점: (미해결 강제 조항 등) 패턴의 나쁜점
  - 이슈: 패턴 적용 시 발생한 새로운 문제점  
  
  결과 맥락은 솔루션을 편견에 치우지지 않은, 좀 더 완전한 시야로 바라보게 한다. 그 결과 더 나은 설계 결정을 내릴 수 있게 된다.
- 연관 패턴: 다섯 가지 관계 유형
  - 선행자: 이 패턴을 필요하게 만든 선행 패턴
  - 후행자: 이 패턴으로 야기된 이슈를 해결하는 패턴
  - 대안: 이 패턴의 대체 솔루션을 제공하는 패턴
  - 일반화: 문제를 해결하는 일반적인 솔루션에 해당하는 패턴
  - 세분화: 특정 패턴을 더 세부적으로 나타낸 형태

패턴 간 관계 역시 몇 가지 유형이 있다.
- 선행자-후행자 관계를 표현
- 같은 문제를 다른 방법으로 해결하는 패턴
- 한 패턴이 다른 패턴을 구체화한 패턴임을 표시
- 특정 영역의 문제에 적용되는 패턴

![image](https://miro.medium.com/v2/resize:fit:3456/format:webp/0*HwLJQJS0nim7G951.jpg)

패턴은 다시 3계층으로 분류된다.
- 인프라 패턴: 주로 개발 영역 밖의 인프라 문제를 해결
- 애플리케이션 인프라: 개발에도 영향을 미치는 인프라 문제를 해결
- 애플리케이션 패턴: 개발자가 맞닥뜨리는 문제를 해결

좀 더 자세한 패턴에 대한 내용은 뒤 챕터들에서 확인할 수 있다.