# 5장. 비즈니스 로직 설계
비즈니스 로직이 여러 서비스에 흩어져 있는 마이크로서비스 아키텍처는 복잡한 비즈니스 로직을 개발하기가 까다롭다. 큰 문제는 두 가지다.
- 도메인 모델은 대부분 상호 연관된 클래스가 거미줄처럼 뒤얽혀 있다. MSA에선 서비스의 경계를 넘나드는 객체 레퍼런스를 제거해야 한다.
- MSA 특유의 트랜잭션 관리 제약 조건하에서도 작동되는 비즈니스 로직을 설계해야 한다. 여러 서비스에 걸쳐 데이터 일관성을 유지하려면 사가 패턴을 적용해야만 한다.

위 두 문제는 서비스 비즈니스 로직을 여러 애그리거트로 구성하는 DDD 애그리거트 패턴으로 해결할 수 있다. **애그리거트란 한 단위로 취급 가능한 객체들을 모아 놓은 것이다.**
- 애그리거트를 사용하면 객체 레퍼런스가 서비스 경계를 넘나들 일이 없다. 객체 참조 대신 기본키(PK)를 이용해 애그리거트가 서로 참조하기 때문이다.
- 한 트랜잭션으로 하나의 애그리거트만 생성/수정할 수 있다. 따라서 애그리거트는 마이크로서비스 트랜잭션 모델의 제약 조건에 잘 맞는다.

결과적으로 ACID 트랜잭션은 반드시 하나의 서비스 내부에만 걸리게 된다.

## 비즈니스 로직 구성 패턴
책에서 예시로 든 주문 서비스는 hexagonal 아키텍처로 구성되어 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/e0665a54-089d-429a-9522-8450974b702e)

주문 서비스는 비즈니스 로직과 어댑터들로 구성된다.
- REST API 어댑터
- `OrderCommandHandlers`
- DB 어댑터
- 도메인 이벤트 발행 어댑터

일반적으로 비즈니스 로직은 서비스에서 가장 복잡한 부분이다. 어떻게 하면 애플리케이션에 가장 적절한 방법으로 비즈니스 로직을 구성/개발할 수 있을지 의식적으로 고민해야 한다.

비즈니스 로직은 절차적 트랜잭션 스크립트 패턴과 객체 지향적 도메인 모델 패턴으로 구성한다.

### 비즈니스 로직 설계: 트랜잭션 스크립트 패턴
![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/0921ca05-a752-43ba-bd4f-f1c3f26dcef4)

마틴 파울러의 저서 '엔터프라이즈 애플리케이션 아키텍처 패턴'의 트랜잭션 스크립트 패턴은 **객체 지향 설계를 하지 않고 트랜잭션 스크립트라는 메서드를 작성하여 표현 계층에서 들어온 요청을 처리하는 것이다.** 이 방법은 동작이 구현된 클래스와 상태를 보관하는 클래스가 따로 존재하는 중요한 특징이 있다.

트랜잭션 스크립트란 비즈니스 로직을 요청 타입별로 하나씩 매핑된 절차적 트랜잭션 스크립트 뭉치로 구성한다.

절차적 접근 방식은 단순한 비즈니스 로직에는 아주 잘 통하지만, 비즈니스 로직이 복잡해지면 거의 관리 불가한 상태로 악화된다.

### 비즈니스 로직 설계: 비즈니스 로직 설계: 도메인 모델 패턴
![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/8deae25f-287c-4c31-902b-6420f89d4cc5)

객체 지향적으로 설계한 비즈니스 로직은 비교적 작은 클래스가 그물망처럼 얽힌 객체 모델로 구성된다. 이런 클래스는 제각기 문제 영역 개념에 직접 대응된다. 대부분 상태/동작 모두 갖고 있다.

트랜잭션 스크립트 패턴을 적용하면 `OrderService`는 각 요청 및 시스템 작업마다 하나의 메서드를 갖게 두지만, 도메인 패턴 모델을 적용하면 서비스 메서드가 단순해진다. 서비스 메서드가 거의 항상 비즈니스 로직이 잔뜩 포함된 영속화 도메인 객체에 위임하기 때문이다.

객체 지향 설계를 하면 좋은 점이 많다.
- 설계를 이해/관리하기 쉽다.
- 테스트하기 쉽다.
- 잘 알려진 설계 패턴을 응용할 수 있기 때문에 확장하기 쉽다.

하지만 도메인 모델 패턴도 MSA에선 해결해야 할 문제가 많기 때문에 이를 개선한 DDD가 필요하다.

### 도메인 주도 설계
에릭 에반스의 저서 '도메인 주도 설계'에 따르면 DDD는 복잡한 비즈니스 로직을 개발하기 위해 OOD를 개선한 접근 방식이라 한다. DDD 방식으로 설계하면 각 서비스는 자체 도메인 모델을 가지며, 애플리케이션 전체 도메인 모델의 문제점을 방지할 수 있다. 하위 도메인과 이와 연관된 경게 컨텍스트 개념은 DDD 패턴의 양대 전략이다.

DDD에서 도메인 모델을 구축하는 데 흔히 쓰이는 빌딩 블록은 다음과 같다. 각 클래스가 도메인 모델에서 수행하는 역할과 클래스의 특징을 정의한다.
- 엔티티(entity): 영속적 신원을 가진 객체. 두 엔티티가 속성 값이 동일해도 엄연히 다른 객체다. Java에선 JPA `@Entity`로 DDD의 엔티티를 나타낸다.
- 밸류 객체(value object): 여러 값을 모아 놓은 객체. 속성 값이 동일한 두 밸류 객체는 서로 바꾸어 사용할 수 있다.
- 팩토리(factory): 일반 생성자로 직접 만들기에 복잡한 객체 생성 로직이 구현된 객체 또는 메서드. 인스턴스로 생성할 구상 클래스를 감출 수 있으며, 클래스의 정적 메서드로 구현할 수 있다.
- 리포지터리(repository): 엔티티를 저장하는 DB 접근 로직을 캡슐화한 객체
- 서비스(service): 엔티티, 밸류 객체에 속하지 않은 비즈니스 로직 구현 객체

## 도메인 모델 설계: DDD 애그리거트 패턴
