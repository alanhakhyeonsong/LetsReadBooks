# 5장. 비즈니스 로직 설계
비즈니스 로직이 여러 서비스에 흩어져 있는 마이크로서비스 아키텍처는 복잡한 비즈니스 로직을 개발하기가 까다롭다. 큰 문제는 두 가지다.
- 도메인 모델은 대부분 상호 연관된 클래스가 거미줄처럼 뒤얽혀 있다. MSA에선 서비스의 경계를 넘나드는 객체 레퍼런스를 제거해야 한다.
- MSA 특유의 트랜잭션 관리 제약 조건하에서도 작동되는 비즈니스 로직을 설계해야 한다. 여러 서비스에 걸쳐 데이터 일관성을 유지하려면 사가 패턴을 적용해야만 한다.

위 두 문제는 서비스 비즈니스 로직을 여러 애그리거트로 구성하는 DDD 애그리거트 패턴으로 해결할 수 있다. **애그리거트란 한 단위로 취급 가능한 객체들을 모아 놓은 것이다.**
- 애그리거트를 사용하면 객체 레퍼런스가 서비스 경계를 넘나들 일이 없다. 객체 참조 대신 기본키(PK)를 이용해 애그리거트가 서로 참조하기 때문이다.
- 한 트랜잭션으로 하나의 애그리거트만 생성/수정할 수 있다. 따라서 애그리거트는 마이크로서비스 트랜잭션 모델의 제약 조건에 잘 맞는다.

결과적으로 ACID 트랜잭션은 반드시 하나의 서비스 내부에만 걸리게 된다.

## 비즈니스 로직 구성 패턴
책에서 예시로 든 주문 서비스는 hexagonal 아키텍처로 구성되어 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/e0665a54-089d-429a-9522-8450974b702e)

주문 서비스는 비즈니스 로직과 어댑터들로 구성된다.
- REST API 어댑터
- `OrderCommandHandlers`
- DB 어댑터
- 도메인 이벤트 발행 어댑터

일반적으로 비즈니스 로직은 서비스에서 가장 복잡한 부분이다. 어떻게 하면 애플리케이션에 가장 적절한 방법으로 비즈니스 로직을 구성/개발할 수 있을지 의식적으로 고민해야 한다.

비즈니스 로직은 절차적 트랜잭션 스크립트 패턴과 객체 지향적 도메인 모델 패턴으로 구성한다.

### 비즈니스 로직 설계: 트랜잭션 스크립트 패턴
![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/0921ca05-a752-43ba-bd4f-f1c3f26dcef4)

마틴 파울러의 저서 '엔터프라이즈 애플리케이션 아키텍처 패턴'의 트랜잭션 스크립트 패턴은 **객체 지향 설계를 하지 않고 트랜잭션 스크립트라는 메서드를 작성하여 표현 계층에서 들어온 요청을 처리하는 것이다.** 이 방법은 동작이 구현된 클래스와 상태를 보관하는 클래스가 따로 존재하는 중요한 특징이 있다.

트랜잭션 스크립트란 비즈니스 로직을 요청 타입별로 하나씩 매핑된 절차적 트랜잭션 스크립트 뭉치로 구성한다.

절차적 접근 방식은 단순한 비즈니스 로직에는 아주 잘 통하지만, 비즈니스 로직이 복잡해지면 거의 관리 불가한 상태로 악화된다.

### 비즈니스 로직 설계: 비즈니스 로직 설계: 도메인 모델 패턴
![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/8deae25f-287c-4c31-902b-6420f89d4cc5)

객체 지향적으로 설계한 비즈니스 로직은 비교적 작은 클래스가 그물망처럼 얽힌 객체 모델로 구성된다. 이런 클래스는 제각기 문제 영역 개념에 직접 대응된다. 대부분 상태/동작 모두 갖고 있다.

트랜잭션 스크립트 패턴을 적용하면 `OrderService`는 각 요청 및 시스템 작업마다 하나의 메서드를 갖게 두지만, 도메인 패턴 모델을 적용하면 서비스 메서드가 단순해진다. 서비스 메서드가 거의 항상 비즈니스 로직이 잔뜩 포함된 영속화 도메인 객체에 위임하기 때문이다.

객체 지향 설계를 하면 좋은 점이 많다.
- 설계를 이해/관리하기 쉽다.
- 테스트하기 쉽다.
- 잘 알려진 설계 패턴을 응용할 수 있기 때문에 확장하기 쉽다.

하지만 도메인 모델 패턴도 MSA에선 해결해야 할 문제가 많기 때문에 이를 개선한 DDD가 필요하다.

### 도메인 주도 설계
에릭 에반스의 저서 '도메인 주도 설계'에 따르면 DDD는 복잡한 비즈니스 로직을 개발하기 위해 OOD를 개선한 접근 방식이라 한다. DDD 방식으로 설계하면 각 서비스는 자체 도메인 모델을 가지며, 애플리케이션 전체 도메인 모델의 문제점을 방지할 수 있다. 하위 도메인과 이와 연관된 경게 컨텍스트 개념은 DDD 패턴의 양대 전략이다.

DDD에서 도메인 모델을 구축하는 데 흔히 쓰이는 빌딩 블록은 다음과 같다. 각 클래스가 도메인 모델에서 수행하는 역할과 클래스의 특징을 정의한다.
- 엔티티(entity): 영속적 신원을 가진 객체. 두 엔티티가 속성 값이 동일해도 엄연히 다른 객체다. Java에선 JPA `@Entity`로 DDD의 엔티티를 나타낸다.
- 밸류 객체(value object): 여러 값을 모아 놓은 객체. 속성 값이 동일한 두 밸류 객체는 서로 바꾸어 사용할 수 있다.
- 팩토리(factory): 일반 생성자로 직접 만들기에 복잡한 객체 생성 로직이 구현된 객체 또는 메서드. 인스턴스로 생성할 구상 클래스를 감출 수 있으며, 클래스의 정적 메서드로 구현할 수 있다.
- 리포지터리(repository): 엔티티를 저장하는 DB 접근 로직을 캡슐화한 객체
- 서비스(service): 엔티티, 밸류 객체에 속하지 않은 비즈니스 로직 구현 객체

## 도메인 모델 설계: DDD 애그리거트 패턴
전통적인 객체 지향 설계에 기반한 도메인 모델은 비즈니스 객체들의 경계가 불분명하다. 경계가 불분명하면 마이크로서비스 아키텍처에서 문제가 생길 가능성이 높다.

개념적으로도 모호하지만 경계가 불분명하면 비즈니스 객체를 업데이트할 때 문제가 생길 수 있다. 비즈니스 객체는 대부분 불변 값이 있고 필히 준수해야 할 비즈니스 규칙이 있다. 예를 들어 `Order` 객체는 최소 주문량이라는 불변 값이 있어서 주문을 업데이트할 때 이 값 이상의 양을 주문해야 한다. 그런데 이렇게 불변 값을 강제하려면 비즈니스 로직을 주의 깊게 설계해야 한다.

여러 소비자가 주문하는 상황에서 최소 주문량의 충족 여부를 어떻게 보장할 수 있을까? 낙관적 락을 기반으로 애플리케이션이 동작한다면, 비즈니스 객체 일부를 직접 업데이트하는 경우 결과적으로 비즈니스 규칙을 위반할 가능성이 높다. DDD 애그리거트는 이런 문제에서 해결책이 될 수 있다.

### 애그리거트는 경계가 분명하다.
**애그리거트는 한 단위로 취급 가능한 경계 내부의 도메인 객체들이다.** 하나의 루트 엔티티와 하나 이상의 기타 엔티티 + 밸류 객체로 구성된다. 비즈니스 객체는 대부분 애그리거트로 모델링한다.

애그리거트는 도메인 모델을 개별적으로 이해하기 쉬운 덩어리로 분해한다. 로드, 수정, 삭제 같은 작업 범위를 분명하게 설정하고, 작업은 애그리거트 일부가 아닌 전체 애그리거트에 작용한다. 애그리거트는 보통 DB에서 통째로 가져오기 때문에 복잡한 지연 로딩 문제를 신경 쓸 필요가 없다. 그리고 애그리거트를 삭제하면 해당 객체가 DB에서 모두 사라진다. 동시성 역시 애그리거트 루트 잠금하여 처리한다.

DDD 도메인 모델 설계의 핵심은 애그리거트와 그 경계, 그리고 그 루트를 식별하는 것이다.

### 애그리거트 규칙
- 애그리거트 루트만 참조하라  
  외부 클래스는 반드시 애그리거트의 루트 엔티티만 참조할 수 있게 제한해야 한다. 무분별한 값 변경을 방지하기 위해서다.
- 애그리거트 간 참조는 반드시 기본키를 사용하라
  애그리거트는 객체 레퍼런스 대신 기본키로 서로를 참조해야 한다. FK와 함께 사용하는 결과 느슨하게 결합되고 애그리거트 간 경계가 분명해지기 때문에 실수로 다른 애그리거트를 업데이트하는 일은 일어나지 않으며 다른 서비스의 일부인 경우에도 여러 서비스에 걸친 객체 레퍼런스에 대한 문제는 없다.
- 하나의 트랜잭션으로 하나의 애그리거트를 생성/수정하라
  하나의 트랜잭션으로 오직 하나의 애그리거트만 생성/수정해야 한다. 데이터의 정합성을 유지하기 위해 하나의 트랜잭션으로 프로세스가 이루어져야 하기에 SAGA를 통해 해결하도록 한다. 이 규칙은 NoSQL DB의 제한된 트랜잭션 모델과도 잘 어울린다.

### 애그리거트 입도
애그리거트의 단위는 작을수록 좋다. 각 애그리거트의 업데이트는 직렬화되므로 잘게 나뉘어져 있으면 그만큼 애플리케이션이 동시 처리 가능한 요청 개수가 늘고 확장성이 좋아진다. 여러 사용자가 동시에 같은 애그리거트를 업데이트하다가 충돌할 가능성도 줄기도 한다. 하지만 애그리거트 자체가 곧 트랜잭션의 범위라서 어떤 업데이트를 원자적으로 처리하려면 애그리거트를 크게 잡아야 할 수도 있다.

## 도메인 이벤트 발행
DDD 맥락에서 도메인 이벤트는 애그리거트에 발생한 사건이다. 도메인 이벤트는 도메인 모델에서는 클래스로 표현되며, 대부분 어떤 상태 변경을 나타낸다. 예를 들어 `Order` 애그리거트라면 주문 생성됨, 주문 취소됨, 주문 배달됨 등 상태가 바뀌는 이벤트를 발생한다. 애그리거트는 상태가 전이될 때마다 이에 관련된 컨슈머를 위해 이벤트를 발행한다.

> 📌 도메인 이벤트: 애그리거트는 뭔가 생성되거나 중요한 변경이 발생했을 때 도메인 이벤트를 발행한다.

### 변경 이벤트를 발행하는 이유
사용자나 다른 애플리케이션 또는 같은 애플리케이션 내부의 다른 컴포넌트들이 애그리거트의 상태 변경을 궁금해하기 때문에 도메인 이벤트는 유용하다. 다음과 같은 예시가 있다.

- 코레오그래피 사가를 이용하여 여러 서비스에 걸쳐 데이터 일관성을 유지한다.
- 레플리카를 둔 서비스에 소스 데이터가 변경되었음을 알린다. (CQRS)
- 미리 등록된 웹훅이나 메시지 브로커를 통해 비즈니스 프로세스의 다음 단계를 진행하도록 다른 애플리케이션에 알린다.
- 사용자 브라우저에 웹 소켓 메시지를 보내거나, ElasticSearch 같은 텍스트 DB를 업데이트 하기 위해 같은 애플리케이션의 다른 컴포넌트에 알린다.
- 사용자에게 텍스트 메시지나 이메일로 알린다. (주문 상품이 배달됨, 예약한 항공편 스케줄이 지연됨, ...)
- 애플리케이션이 제대로 작동되고 있는지 도메인 이벤트를 모니터링하면서 확인한다.
- 사용자 행동을 모델링하기 위해 이벤트를 분석한다.

### 도메인 이벤트란 무엇인가?
**도메인 이벤트는 과거 분사형 동사로 명명한 클래스다.** 이벤트에 의미를 부여하는 프로퍼티는 원시 값(primitive value) 또는 밸류 객체이다. 대부분 이벤트 ID, 타임스탬프 같은 메타데이터도 존재한다. 또한 변경을 일으킨 사용자 신원 정보를 넣기도 하는데, 감사 용도로 좋다.

메타데이터는 상위 클래스에 정의된 이벤트 객체의 일부이거나, 이벤트 객체를 감싼 envelope object에 있다. 이벤트를 발생시킨 애그리거트 ID는 특정 이벤트 프로퍼티가 아닌 인벨로프의 일부일 수 있다.

```java
// 자신을 구현한 클래스가 도메인 이벤트임을 알리는 마커 인터페이스
interface DomainEvent {}

// Order 애그리거트가 발행한 OrderCreatedEvent의 마커 인터페이스
interface OrderDomainEvent extends DomainEvent {}

class OrderCreatedEvent implements OrderDomainEvent {}

interface DomainEventEnvelope<T extends DomainEvent> {
    String getAggregateId();
    Message getMessage();
    String getAggregateType();
    String getEventId();

    T getEvent();
}
```

### 이벤트 강화
컨슈머를 작성할 때 이벤트 컨슈머가 서비스를 쿼리해서 애그리거트를 조회하는 것은 오버헤드를 유발한다. 그래서 컨슈머에 필요한 정보를 이벤트가 갖고 다니는 이벤트 강화 기법을 적용한다. 그 결과 이벤트를 발행한 서비스를 다시 쿼리해서 데이터를 가져올 필요가 없어 이벤트 컨슈머가 아주 간단해진다.

```java
class OrderCreatedEvent implements OrderEvent {
    private List<OrderLineItem> lineItems;
    private DeliveryInformation deliveryInformation; // 컨슈머가 필요로 하는 데이터
    private PaymentInformation paymentInformation;
    private long restaurantId;
    private String restaurantName;
    // ...
}
```

이벤트 강화 기법은 컨슈머를 단순화하는 이점이 있지만, 컨슈머 요건이 바뀌면 이벤트 클래스도 함께 바꿔야 하므로 이벤트 클래스의 안정성은 떨어진다. 변경할 일이 생기면 애플리케이션 곳곳에 영향이 있을 수 있으니 유지보수성도 나빠진다. 모든 컨슈머를 전부 만족시킬 수는 없다. 하지만 대부분의 경우는 이벤트 안에 포함시켜야 할 프로퍼티가 명백하다.

### 도메인 이벤트 식별
요즘은 이벤트 스토밍이라는 방법을 많이 사용하는 추세라고 한다. 복잡한 도메인을 이해하기 위해 이벤트 중심으로 워크숍을 하는 것이다. 3단계의 과정을 간략하게 정리하고 넘어가자.

1. 이벤트 스토밍: 도메인 이벤트를 머릿속에서 쥐어 짜낸다. 오렌지색 접착식 메모지로 구분된 도메인 이벤트를 모델링 화면에 대략 그려 놓은 타임라인에 배치한다.
2. 이벤트 트리거 식별: 각각의 이벤트를 일으키는 트리거를 식별한다.
  - 사용자 액션: 파란색 접착식 메모지로 커맨드를 표시
  - 외부 시스템: 자주색 접착식 메모지로 표시
  - 기타 도메인 이벤트
  - 시간 경과
3. 애그리거트 식별: 각 커맨드 소비 후 적절한 이벤트를 발생시키는 애그리거트를 식별해서 노란색 접착식 메모지로 표시한다.

### 도메인 이벤트 생성 및 발행
도메인 이벤트를 이용한 통신은 비동기 메시징 형태를 취하지만, 비즈니스 로직이 도메인 이벤트를 메시지 브로커에 발행하려면 먼저 도메인 이벤트를 생성해야 한다.

개념적으로 도메인 이벤트는 애그리거트가 발행한다. 애그리거트는 자신의 상태가 변경되는 시점과 그 결과 어떤 이벤트를 발행할 지 알고 있다. 애그리거트가 메시징 API를 직접 호출하는 것도 가능하지만, 디펜던시 주입을 할 수 없기 때문에 메시징 API를 메서드 인수로 전달해야 하는 문제가 있다. 이는 인프라 관심사와 비즈니스 로직이 서로 뒤엉켜버릴 문제가 있다. 따라서 애그리거트와 호출하는 서비스의 책임을 분리하는 것이 좋다.

서비스는 디펜던시를 주입하여 메시징 API를 가리키는 레퍼런스를 획득할 수 있으므로 이벤트를 발행하기가 더 쉽다. 애그리거트는 상태 전이 시 이벤트를 생성하고, 생성한 이벤트를 이벤트 목록에 넣어 반환하며, 메시지를 발행하기 위해서는 트랜잭셔널 메시지를 사용하여 반환한다.

```java
// Ticket 애그리거트와 accept() 메서드
public class Ticket {
    
    public List<TicketDomainEvent> accept(LocalDateTime readyBy) {
        // ...
        this.acceptTime = LocalDateTime.now(); // Ticket 업데이트
        this.readyBy = readyBy;
        return singletonList(new TicketAcceptedEvent(readyBy)); // 이벤트 반환
    }
}
```

서비스는 애그리거트 루트 메서드를 호출한 뒤 이벤트를 발행한다.

```java
public class KitchenService {
    
    @Autowired
    private TicketRepository ticketRepository;

    @Autowired
    private TicketDomainEventPublisher domainEventPublisher;

    public void accept(long ticketId, LocalDateTime readyBy) {
        Ticket ticket = ticketRepository.findById(ticketId)
                          .orElseThrow(() -> new TicketNotFoundException(ticketId));
        List<TicketDomainEvent> events = ticket.accept(readyBy);

        domainEventPublisher.publish(Ticket.class, orderId, events); // 도메인 이벤트 발행
    }
}
```

애그리거트 루트의 특정 필드에 이벤트를 차곡차곡 쌓아두고 서비스가 이벤트를 가져다 발행하는 방법도 있다.

```java
// Ticket은 도메인 이벤트를 기록하는 상위 클래스 AbstractAggregateRoot를 상속한다.
public class Ticket extends AbstractAggregateRoot {

    public void accept(LocalDateTime readyBy) {
        // ...
        this.acceptTime = LocalDateTime.now();
        this.readyBy = readyBy;
        registerEvent(new TicketAcceptedEvent(readyBy));
    }
}
```

이벤트를 기록하는 `registerEvent()`가 상위 클래스에 정의된 메서드다. 서비스는 `AbstractAggregateRoot.domainEvents()`를 호출해서 이벤트를 가져온다.

도메인 이벤트를 확실하게 발행하는 방법은 트랜잭셔널 메시징을 사용하는 방법이다.  
서비스는 DB에서 애그리거트를 직접 업데이트하는 트랜잭션의 일부로 이벤트를 발행하기 위해 트랜잭셔널 메시징을 사용해야 한다.

### 도메인 이벤트 소비
도메인 이벤트는 결국 메시지로 바뀌어 메시지 브로커에 발행된다.

> 저자가 제시한 프레임워크 대신 Kafka를 사용해서 직접 코드를 작성해보는 것이 이해가 빠를 것 같다. 덧붙여 DDD 개념을 제대로 알고 책을 읽으면 도움이 더 잘될 것 같다.