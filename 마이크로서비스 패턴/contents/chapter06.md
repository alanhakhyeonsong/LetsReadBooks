# 6장. 비즈니스 로직 개발: 이벤트 소싱
이전의 이벤트 발행 로직은 상당히 직관적이다. 애그리거트의 상태를 시작/변경하는 각 애그리거트의 메서드가 이벤트 목록을 반환하면 도메인 서비스는 이 이벤트를 발행한다. 그런데 다른 한편으론 이벤트 발행 로직이 비즈니스 로직에 추가되기 때문에 개발자가 실수로 이벤트 발행 로직을 빠뜨려도 비즈니스 로직은 그냥 흘러갈 것이다.

이벤트 소싱 기법을 활용하면 애그리거트가 생성/수정될 때마다 무조건 이벤트를 발행해서 프로그래밍 오류를 제거할 수 있다.

## 이벤트 소싱 응용 비즈니스 로직 개발
**이벤트 소싱은 비즈니스 로직을 구성하고 애그리거트를 저장하는 또 다른 방법이다. 애그리거트를 일련의 이벤트 형태로 저장한다.** 이벤트는 각 애그리거트의 상태 변화를 나타낸다. 애플리케이션은 이벤트를 재연하여 애그리거트의 현재 상태를 재생성한다.

- 장점: 애그리거트 이력이 보존되므로 감사/통제 용도로도 가치가 있고, 도메인 이벤트를 확실하게 발행할 수 있어 MSA에서 특히 유용하다.
- 단점: 비즈니스 로직을 작성하는 방법이 특이해서 어느정도 학습 시간이 필요하고, 이벤트 저장소를 쿼리하기 쉽지 않아 CQRS 패턴을 적용해야 한다.

### 기존 영속화의 문제점
- 객체-관계 임피던스 부정합: OOP와 RDB간 기본 철학이 다르다.
- 애그리거트 이력이 없다: 기존 영속화 메커니즘은 현재 애그리거트의 상태만 저장한다. 즉, 애그리거트가 업데이트되면 이전 상태는 사라지고 없다. 이력을 남기려면 개발자가 직접 코드를 구현해야 하고, 비즈니스 로직과 동기화해야 하는 코드를 중복 생성하게 된다.
- 감사 로깅은 구현하기 힘들고 오류도 자주 발생한다: 여러 로깅을 종류별로 구현하기 번거럽고, 비즈니스 로직은 계속 변경되기 때문에 버그가 발생할 가능성이 높다.
- 이벤트 발행 로직이 비즈니스 로직에 추가된다: 기존 영속화는 도메인 이벤트 발행을 지원하지 않는다. ORM 프레임워크는 데이터 객체가 변경될 때 애플리케이션이 제공한 콜백을 호출할 수 있지만, 데이터를 업데이트하는 트랜잭션의 일부로 메시지를 자동 발행하는 기능 따위는 없다. 따라서 이벤트 생성 로직을 추가해야 하는데, 자칫 비즈니스 로직과 동기화되지 않을 위험이 있다.

### 이벤트 소싱 개요
**이벤트 소싱은 이벤트를 위주로 비즈니스 로직을 구현하고, 애그리거트를 DB에 일련의 이벤트로 저장하는 기법**이다. 각 이벤트는 애그리거트의 상태 변화를 나타낸다. 애그리거트의 비즈니스 로직은 이벤트를 생산/소비하는 요건 중심으로 구성된다.

예를 들어 `Order` 애그리거트를 이벤트 소싱으로 저장한다면 `Order`를 `ORDER` 테이블에 로우 단위로 저장하는 것이 아니라, `Order` 애그리거트를 `EVENTS` 테이블의 여러 로우로 저장한다. 각 로우가 바로 주문 생성됨, 주문 승인됨, 주문 배달됨 등의 도메인 이벤트다.

```
+----------+----------------+-------------+-----------+------------+
| EVENT_ID |   EVENT_TYPE   | ENTITY_TYPE | ENTITY_ID | EVENT_DATA |
+----------+----------------+-------------+-----------+------------+
|     1002 | ORDER_CREATED  | ORDER       |      1001 | {...}      |
|     1003 | ORDER_APPROVED | ORDER       |      1001 | {...}      |
|     1004 | ORDER_SHIPPED  | ORDER       |      1001 | {...}      |
+----------+----------------+-------------+-----------+------------+
```

애그리거트를 로드하는 작업은 다음 3단계로 구성된다.

1. 애그리거트의 이벤트를 로드한다.
2. 기본 생성자를 호출하여 애그리거트 인스턴스를 생성한다.
3. 이벤트를 하나씩 순회하며 `apply()`를 호출한다.

### 동시 업데이트: 낙관적 잠금
여러 오쳥이 동일한 애그리거트를 동시에 업데이트하는 일은 드물지 않다. 기존 영속화 메커니즘은 대게 한 트랜잭션이 다른 트랜잭션의 변경을 덮어 쓰지 못하게 낙관적 잠금을 하여 처리한다.

이벤트 저장소 역시 낙관적 잠금 기법으로 동시 업데이트를 처리할 수 있다. 이벤트에 딸려온 버전 정보를 각 애그리거트 인스턴스마다 두고, 애플리케이션이 이벤트를 삽입할 때 이벤트 저장소가 버전 변경 여부를 체크하는 것이다.

### 이벤트 발행: 폴링
이벤트를 `EVENTS` 테이블에 저장한다 가정할 때, 이벤트 발생 순서와 커밋 시점의 차이로 인해 순서가 뒤섞일 수 있다. 이런 문제점은 이벤트 발행 여부를 추적할 수 있는 컬럼을 추가하는 것이다.

1. `SELECT * FROM EVENTS WHERE PUBLISHED = 0 ORDER BY EVENT_ID ASC` 쿼리로 미발행 이벤트 검색
2. 메시지 브로커에 이벤트를 발행
3. `UPDATE EVENTS SET PUBLISHED = 1 WHERE EVENT_ID = ?` 쿼리로 이벤트가 발행된 것으로 표시

### 스냅샷으로 성능 개선
수명이 긴 애그리거트는 이벤트 수가 꽤 많아 일일이 로드/폴드하기 만만치 않다. 이 경우, 주기적으로 애그리거트 상태의 스냅샷을 저장하고 물리적인 조회 대상을 줄인 다음 이벤트를 조회하여 성능을 개선할 수 있다.

### 이벤트 소싱의 장점
- 도메인 이벤트를 확실하게 발행한다.
- 애그리거트 이력이 보존된다.
- O/R 임피던스 불일치 문제를 대부분 방지할 수 있다.
- 개발자에게 타임 머신을 제공한다.

### 이벤트 소싱의 단점
- 새로운 프로그래밍 모델을 배우는 데 시간이 걸린다.
- 메시징 기반 애플리케이션은 복잡하다.
- 이벤트를 개량하기 까다로운 편이다.
- 데이터를 삭제하기가 어렵다.
- 이벤트 저장소를 쿼리하기가 만만찮다.

## 이벤트 저장소 구현
이벤트 저장소는 DB와 메시지 브로커를 합한 것이다. 애그리거트의 이벤트를 기본키로 삽입/조회하는 API가 있어 마치 DB처럼 움직이면서, 이벤트를 구독하는 API도 있어서 메시지 브로커처럼 동작하기도 한다.

RDBMS에 이벤트를 그냥 저장하는 방법도 있지만, 성능/확장성이 우수한 다기능의 전용 이벤트 저장소를 두는 방법도 있다.
- Event Store
- Lagom
- Axon
- Eventuate