# 6장. 비즈니스 로직 개발: 이벤트 소싱
이전의 이벤트 발행 로직은 상당히 직관적이다. 애그리거트의 상태를 시작/변경하는 각 애그리거트의 메서드가 이벤트 목록을 반환하면 도메인 서비스는 이 이벤트를 발행한다. 그런데 다른 한편으론 이벤트 발행 로직이 비즈니스 로직에 추가되기 때문에 개발자가 실수로 이벤트 발행 로직을 빠뜨려도 비즈니스 로직은 그냥 흘러갈 것이다.

이벤트 소싱 기법을 활용하면 애그리거트가 생성/수정될 때마다 무조건 이벤트를 발행해서 프로그래밍 오류를 제거할 수 있다.

## 이벤트 소싱 응용 비즈니스 로직 개발
**이벤트 소싱은 비즈니스 로직을 구성하고 애그리거트를 저장하는 또 다른 방법이다. 애그리거트를 일련의 이벤트 형태로 저장한다.** 이벤트는 각 애그리거트의 상태 변화를 나타낸다. 애플리케이션은 이벤트를 재연하여 애그리거트의 현재 상태를 재생성한다.

- 장점: 애그리거트 이력이 보존되므로 감사/통제 용도로도 가치가 있고, 도메인 이벤트를 확실하게 발행할 수 있어 MSA에서 특히 유용하다.
- 단점: 비즈니스 로직을 작성하는 방법이 특이해서 어느정도 학습 시간이 필요하고, 이벤트 저장소를 쿼리하기 쉽지 않아 CQRS 패턴을 적용해야 한다.

### 기존 영속화의 문제점
- 객체-관계 임피던스 부정합: OOP와 RDB간 기본 철학이 다르다.
- 애그리거트 이력이 없다: 기존 영속화 메커니즘은 현재 애그리거트의 상태만 저장한다. 즉, 애그리거트가 업데이트되면 이전 상태는 사라지고 없다. 이력을 남기려면 개발자가 직접 코드를 구현해야 하고, 비즈니스 로직과 동기화해야 하는 코드를 중복 생성하게 된다.
- 감사 로깅은 구현하기 힘들고 오류도 자주 발생한다: 여러 로깅을 종류별로 구현하기 번거럽고, 비즈니스 로직은 계속 변경되기 때문에 버그가 발생할 가능성이 높다.
- 이벤트 발행 로직이 비즈니스 로직에 추가된다: 기존 영속화는 도메인 이벤트 발행을 지원하지 않는다. ORM 프레임워크는 데이터 객체가 변경될 때 애플리케이션이 제공한 콜백을 호출할 수 있지만, 데이터를 업데이트하는 트랜잭션의 일부로 메시지를 자동 발행하는 기능 따위는 없다. 따라서 이벤트 생성 로직을 추가해야 하는데, 자칫 비즈니스 로직과 동기화되지 않을 위험이 있다.

### 이벤트 소싱 개요
**이벤트 소싱은 이벤트를 위주로 비즈니스 로직을 구현하고, 애그리거트를 DB에 일련의 이벤트로 저장하는 기법**이다. 각 이벤트는 애그리거트의 상태 변화를 나타낸다. 애그리거트의 비즈니스 로직은 이벤트를 생산/소비하는 요건 중심으로 구성된다.

예를 들어 `Order` 애그리거트를 이벤트 소싱으로 저장한다면 `Order`를 `ORDER` 테이블에 로우 단위로 저장하는 것이 아니라, `Order` 애그리거트를 `EVENTS` 테이블의 여러 로우로 저장한다. 각 로우가 바로 주문 생성됨, 주문 승인됨, 주문 배달됨 등의 도메인 이벤트다.

```
+----------+----------------+-------------+-----------+------------+
| EVENT_ID |   EVENT_TYPE   | ENTITY_TYPE | ENTITY_ID | EVENT_DATA |
+----------+----------------+-------------+-----------+------------+
|     1002 | ORDER_CREATED  | ORDER       |      1001 | {...}      |
|     1003 | ORDER_APPROVED | ORDER       |      1001 | {...}      |
|     1004 | ORDER_SHIPPED  | ORDER       |      1001 | {...}      |
+----------+----------------+-------------+-----------+------------+
```

애그리거트를 로드하는 작업은 다음 3단계로 구성된다.

1. 애그리거트의 이벤트를 로드한다.
2. 기본 생성자를 호출하여 애그리거트 인스턴스를 생성한다.
3. 이벤트를 하나씩 순회하며 `apply()`를 호출한다.

