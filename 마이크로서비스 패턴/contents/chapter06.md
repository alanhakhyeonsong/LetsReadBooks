# 6장. 비즈니스 로직 개발: 이벤트 소싱
이전의 이벤트 발행 로직은 상당히 직관적이다. 애그리거트의 상태를 시작/변경하는 각 애그리거트의 메서드가 이벤트 목록을 반환하면 도메인 서비스는 이 이벤트를 발행한다. 그런데 다른 한편으론 이벤트 발행 로직이 비즈니스 로직에 추가되기 때문에 개발자가 실수로 이벤트 발행 로직을 빠뜨려도 비즈니스 로직은 그냥 흘러갈 것이다.

이벤트 소싱 기법을 활용하면 애그리거트가 생성/수정될 때마다 무조건 이벤트를 발행해서 프로그래밍 오류를 제거할 수 있다.

## 이벤트 소싱 응용 비즈니스 로직 개발
**이벤트 소싱은 비즈니스 로직을 구성하고 애그리거트를 저장하는 또 다른 방법이다. 애그리거트를 일련의 이벤트 형태로 저장한다.** 이벤트는 각 애그리거트의 상태 변화를 나타낸다. 애플리케이션은 이벤트를 재연하여 애그리거트의 현재 상태를 재생성한다.

- 장점: 애그리거트 이력이 보존되므로 감사/통제 용도로도 가치가 있고, 도메인 이벤트를 확실하게 발행할 수 있어 MSA에서 특히 유용하다.
- 단점: 비즈니스 로직을 작성하는 방법이 특이해서 어느정도 학습 시간이 필요하고, 이벤트 저장소를 쿼리하기 쉽지 않아 CQRS 패턴을 적용해야 한다.

### 기존 영속화의 문제점
![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/956b5c2b-1165-4163-9916-319d849d0843)

- 객체-관계 임피던스 부정합: OOP와 RDB간 기본 철학이 다르다.
- 애그리거트 이력이 없다: 기존 영속화 메커니즘은 현재 애그리거트의 상태만 저장한다. 즉, 애그리거트가 업데이트되면 이전 상태는 사라지고 없다. 이력을 남기려면 개발자가 직접 코드를 구현해야 하고, 비즈니스 로직과 동기화해야 하는 코드를 중복 생성하게 된다.
- 감사 로깅은 구현하기 힘들고 오류도 자주 발생한다: 여러 로깅을 종류별로 구현하기 번거럽고, 비즈니스 로직은 계속 변경되기 때문에 버그가 발생할 가능성이 높다.
- 이벤트 발행 로직이 비즈니스 로직에 추가된다: 기존 영속화는 도메인 이벤트 발행을 지원하지 않는다. ORM 프레임워크는 데이터 객체가 변경될 때 애플리케이션이 제공한 콜백을 호출할 수 있지만, 데이터를 업데이트하는 트랜잭션의 일부로 메시지를 자동 발행하는 기능 따위는 없다. 따라서 이벤트 생성 로직을 추가해야 하는데, 자칫 비즈니스 로직과 동기화되지 않을 위험이 있다.

### 이벤트 소싱 개요
**이벤트 소싱은 이벤트를 위주로 비즈니스 로직을 구현하고, 애그리거트를 DB에 일련의 이벤트로 저장하는 기법**이다. 각 이벤트는 애그리거트의 상태 변화를 나타낸다. 애그리거트의 비즈니스 로직은 이벤트를 생산/소비하는 요건 중심으로 구성된다.

예를 들어 `Order` 애그리거트를 이벤트 소싱으로 저장한다면 `Order`를 `ORDER` 테이블에 로우 단위로 저장하는 것이 아니라, `Order` 애그리거트를 `EVENTS` 테이블의 여러 로우로 저장한다. 각 로우가 바로 주문 생성됨, 주문 승인됨, 주문 배달됨 등의 도메인 이벤트다.

```
+----------+----------------+-------------+-----------+------------+
| EVENT_ID |   EVENT_TYPE   | ENTITY_TYPE | ENTITY_ID | EVENT_DATA |
+----------+----------------+-------------+-----------+------------+
|     1002 | ORDER_CREATED  | ORDER       |      1001 | {...}      |
|     1003 | ORDER_APPROVED | ORDER       |      1001 | {...}      |
|     1004 | ORDER_SHIPPED  | ORDER       |      1001 | {...}      |
+----------+----------------+-------------+-----------+------------+
```

애그리거트를 로드하는 작업은 다음 3단계로 구성된다.

1. 애그리거트의 이벤트를 로드한다.
2. 기본 생성자를 호출하여 애그리거트 인스턴스를 생성한다.
3. 이벤트를 하나씩 순회하며 `apply()`를 호출한다.

#### 이벤트는 곧 상태 변화
- 도메인 이벤트는 애그리거트의 변경을 구독자에게 알리는 장치로, 이벤트는 애그리거트 ID 같은 최소한의 필수 데이터만 넣거나 컨슈머에 유용한 데이터까지 포함시켜 강화할 수 있다.
- **이벤트 소싱에선 이벤트가 필수다.** 생성을 비롯한 모든 애그리거트의 상태 변화를 도메인 이벤트로 나타내며, 애그리거트는 상태가 바뀔 때마다 반드시 이벤트를 발생시킨다.
- 이벤트는 애그리거트가 상태 전이를 하기 위해 필요한 데이터를 갖고 있어야 한다. 애그리거트의 상태는 애그리거트를 구성한 객체의 필드 값들로 구성된다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/96b488cd-dca1-4c76-8e53-7ce91eb02300)

#### 애그리거트 메서드의 관심사는 오직 이벤트
- 비즈니스 로직은 애그리거트의 업데이트 요청을 애그리거트 루트에 있는 커맨드 메서드를 호출하여 처리한다.
  - 기존에는 커맨드 메서드가 매개변수를 검증한 후 하나 이상의 애그리거트 필드를 업데이트했다.
  - 이벤트 소싱을 사용하면 커맨드 메서드가 반드시 이벤트를 발생시킨다.
  - 애그리거트의 커맨드 메서드를 호출한 결과는 상태 변경을 나타내는 일련의 이벤트다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/d151518e-838b-4d66-97bf-8b61c2e3e9a2)

- 이벤트는 DB에 저장되며, 애그리거트에 적용되어 상태를 업데이트한다.
- 이벤트 소싱은 커맨드 메서드 하나를 둘 이상의 메서드로 리팩터링한다.
  - 요청을 나타낸 커맨드 객체를 매개변수로 받아 상태를 어떻게 변경해야 할지 결정. 애그리거트 상태는 바꾸지 않고 상태 변경을 나타낸 이벤트 목록을 반환한다. 수행할 수 없는 커맨드라면 예외를 던진다.
  - 각자 정해진 이벤트 타입을 매개변수로 받아 애그리거트를 업데이트.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/060e43ab-77ad-4f25-9118-28aef550e640)

### 동시 업데이트: 낙관적 잠금
여러 요청이 동일한 애그리거트를 동시에 업데이트하는 일은 드물지 않다. 기존 영속화 메커니즘은 대게 한 트랜잭션이 다른 트랜잭션의 변경을 덮어 쓰지 못하게 낙관적 잠금을 하여 처리한다.

이벤트 저장소 역시 낙관적 잠금 기법으로 동시 업데이트를 처리할 수 있다. 이벤트에 딸려온 버전 정보를 각 애그리거트 인스턴스마다 두고, 애플리케이션이 이벤트를 삽입할 때 이벤트 저장소가 버전 변경 여부를 체크하는 것이다.

### 이벤트 소싱과 이벤트 발행
#### 이벤트 발행: 폴링
이벤트를 `EVENTS` 테이블에 저장한다 가정할 때, 이벤트 발생 순서와 커밋 시점의 차이로 인해 순서가 뒤섞일 수 있다. 이런 문제점을 해결하는 한 가지 방법은 이벤트 발행 여부를 추적할 수 있는 컬럼을 추가하는 것이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/77252261-507f-4789-b877-f9ebd1c6eec4)

1. `SELECT * FROM EVENTS WHERE PUBLISHED = 0 ORDER BY EVENT_ID ASC` 쿼리로 미발행 이벤트 검색
2. 메시지 브로커에 이벤트를 발행
3. `UPDATE EVENTS SET PUBLISHED = 1 WHERE EVENT_ID = ?` 쿼리로 이벤트가 발행된 것으로 표시

#### 이벤트 발행: 트랜잭션 로그 테일링
트랜잭션 로그 테일링은 좀 더 정교한 방법이다. 이벤트 발행을 확실히 보장하면서도 성능/확장성이 우수하다.

### 스냅샷으로 성능 개선
수명이 긴 애그리거트는 이벤트 수가 꽤 많아 일일이 로드/폴드하기 만만치 않다. 이 경우, 주기적으로 애그리거트 상태의 스냅샷을 저장하고 물리적인 조회 대상을 줄인 다음 이벤트를 조회하여 성능을 개선할 수 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/98395a8c-d3b7-43e1-902a-aaa29a867255)

스냅샷 버전이 N이면 N+1 이후 발생한 이벤트 2개만 가져오면 애그리거트 상태를 되살릴 수 있다. 그 이전 이벤트 N개는 이벤트 저장소에서 가져올 필요가 없다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/c34d3018-d1ce-45a9-ad6a-8340079d2248)

### 멱등한 메시지 처리
서비스는 대부분 다른 애플리케이션 또는 서비스로부터 받은 메시지를 소비한다. 애그리거트가 발행한 도메인 이벤트나 사가 오케스트레이터가 보낸 커맨드 메시지를 소비한다. 그런데 메시지 브로커가 동일한 메시지를 여러 번 전송할 가능성이 있으므로 **메시지 컨슈머는 멱등하게 개발해야 한다.**

메시지 컨슈머가 동일한 메시지를 여러 번 호출해도 안전하다면 멱등한 것이다.

- 비즈니스 로직이 애그리거트를 생성/수정하는 로컬 ACID 트랜잭션의 일부로 처리한 메시지 ID를 `PROCESSED_MESSAGE` 테이블에 기록한다.
- 이 테이블에 메시지 ID가 있으면 중복 메시지이므로 솎아내면 된다.

이벤트 소싱 기반의 비즈니스 로직은 이런 메커니즘을 강구해야 한다.

#### RDBMS 이벤트 저장소 사용
메시지 ID는 `PROCESSED_MESSAGES` 테이블에, 이벤트는 `EVENTS` 테이블에 삽입하는 트랜잭션의 일부로 삽입하면 된다.

#### NoSQL 이벤트 저장소 사용
트랜잭션 모델이 제한적이라서 메시지를 멱등하게 처리하려면 다른 수단을 강구해야 한다. 메시지 컨슈머는 이벤트를 저장하고 메시지 ID를 기록하는 작업을 어느 정도 원자적으로 처리해야 한다.

**메시지 컨슈머가 메시지 처리 도중 생성된 메시지 ID를 저장하는 것이다.** 해당 메시지 ID가 애그리거트의 이벤트에 있는지 확인하면 중복 메시지 여부를 알 수 있다.

그러나 메시지 처리 결과 아무 이벤트도 생성되지 않을 수 있다. 이벤트가 없다는 것은 메시지 처리 기록 또한 전무하다는 뜻이고, 이후에 같은 메시지를 재전달/재처리하면 이상하게 동작할 수 있다. 해결 방법은 **항상 이벤트를 발행하는 것이다.** 애그리거트가 이벤트를 발생시키지 않을 경우, 오직 메시지 ID를 기록할 목적으로 가짜 이벤트를 저장한다. 이는 이벤트 컨슈머가 무시해야 한다.

### 이벤트 소싱의 장점
- 도메인 이벤트를 확실하게 발행한다.
- 애그리거트 이력이 보존된다.
- O/R 임피던스 불일치 문제를 대부분 방지할 수 있다.
- 개발자에게 타임 머신을 제공한다.

### 이벤트 소싱의 단점
- 새로운 프로그래밍 모델을 배우는 데 시간이 걸린다.
- 메시징 기반 애플리케이션은 복잡하다.
- 이벤트를 개량하기 까다로운 편이다.
- 데이터를 삭제하기가 어렵다.
- 이벤트 저장소를 쿼리하기가 만만찮다.

## 이벤트 저장소 구현
이벤트 저장소는 DB와 메시지 브로커를 합한 것이다. 애그리거트의 이벤트를 기본키로 삽입/조회하는 API가 있어 마치 DB처럼 움직이면서, 이벤트를 구독하는 API도 있어서 메시지 브로커처럼 동작하기도 한다.

RDBMS에 이벤트를 그냥 저장하는 방법도 있지만, 성능/확장성이 우수한 다기능의 전용 이벤트 저장소를 두는 방법도 있다.
- Event Store
- Lagom
- Axon
- Eventuate

### 이벤추에이트 로컬 이벤트 저장소의 작동 원리
이벤트는 MySQL 등의 DB에 저장된다. 애플리케이션은 애그리거트 이벤트를 기본키로 조회/삽입하고, Apache Kafka 등의 메시지 브로커에서 이벤트를 가져와 소비한다. 트랜잭션 로그 테일링 장치는 끊임없이 DB에서 메시지 브로커로 이벤트를 퍼 나른다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/ca673cc1-ff0f-4b35-93e9-017cf5c69c1a)

### 자바용 이벤추에이트 클라이언트 프레임워크
이벤추에이트 클라이언트는 이벤추에이트 로컬 이벤트 저장소를 사용하는 이벤트 소싱 애플리케이션의 개발 프레임워크다. 이벤트 소싱 기반의 애그리거트, 서비스, 이벤트 핸들러 개발에 필요한 기반을 제공한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/3094e90e-7947-4c81-bb7f-517d388a1575)

프레임워크의 구성 요소를 간략히 살펴보면 아래와 같다.

```java
public class Order extends ReflectiveMutableCommandProcessingAggregate<
      Order, OrderCommand> {

  public List<Event> process(CreateOrderCommand command) { ... }

  public void apply(OrderCreatedEvent event) { ... }

  ...
}

public interface OrderCommand extends Command {
}

public class CreateOrderCommand implements OrderCommand { ... }

interface OrderEvent extends Event {

}

public class OrderCreated extends OrderEvent { ... }

public class OrderService {
  private AggregateRepository<Order, OrderCommand> orderRepository;

  public OrderService(AggregateRepository<Order, OrderCommand> orderRepository)
  {
    this.orderRepository = orderRepository;
  }

  public EntityWithIdAndVersion<Order> createOrder(OrderDetails orderDetails) {
    return orderRepository.save(new CreateOrder(orderDetails));
  }
}

@EventSubscriber(id="orderServiceEventHandlers")
public class OrderServiceEventHandlers {

  @EventHandlerMethod
  public void creditReserved(EventHandlerContext<CreditReserved> ctx) {
    CreditReserved event = ctx.getEvent();
    ...
  }
  //...
}
```

## 사가와 이벤트 소싱을 접목
여러 서비스에 걸쳐 데이터 일관성을 유지하려면 서비스가 사가를 시작하거나 사가에 참여해야 할 경우가 많다.

- ex) 주문 서비스는 사가를 이용하여 `Order`를 검증하며, 주방 서비스, 소비자 서비스, 회계 서비스는 이 사가에 참여한다.

따라서 사가와 이벤트 소싱 기반의 비즈니스 로직을 연계해야 한다.

이벤트 소싱에선 **코레오그래피 사가를 쉽게 이용할 수 있다.** 참여자는 자신의 애그리거트가 발생시킨 도메인 이벤트를 교환하고, 각 참여자의 애그리거트는 커맨드를 처리하고 새로운 이벤트를 발생시키는 식으로 이벤트를 처리한다.

하지만 이벤트 소싱 기반의 비즈니스 로직을 오케스트레이션 기반의 사가에 연계하는 일은 훨씬 어려울 수 있다. 이벤트 저장소의 트랜잭션 개념이 상당히 제한적이기 때문이다. 이벤트 저장소를 사용하는 애플리케이션은 애그리거트 하나만 생성/수정하고 결과 이벤트(들)를 발행할 수 있는데, 각 사가의 단계는 다음과 같이 반드시 원자적으로 수행되어야 하는 액션들로 구성된다.

- 사가 생성: 사가를 시작한 서비스는 원자적으로 애그리거트를 생성/수정하고 사가 오케스트레이터를 생성해야 한다. 주문 서비스의 `createOrder()`는 `Order` 애그리거트와 `CreateOrderSaga`를 생성해야 한다.
- 사가 오케스트레이션: 사가 오케스트레이터는 원자적으로 응답을 소비하고, 자신의 상태를 업데이트한 후 커맨드 메시지를 전송해야 한다.
- 사가 참여자: 주방 서비스, 주문 서비스 등 사가 참여자는 원자적으로 메시지를 소비하고, 중복 메시지를 솎아 내고, 애그리거트를 생성/수정하고, 응답 메시지를 전송해야 한다.

**이벤트 저장소의 트랜잭션 능력과 요건 사이에 맞지 않는 부분이 있기 때문에 오케스트레이션 사가와 이벤트 소싱을 연계하는 작업은 쉽지 않은 도전이 될 가능성이 있다.**

이벤트 저장소의 RDBMS/NoSQL 사용 여부는 이벤트 소싱과 오케스트레이션 사가의 연계 가능성을 가늠하는 핵심 기준이다.  
사가 오케스트레이터와 참여자는 RDBMS에서 지원되는 ACID 트랜잭션을 걸고 DB를 원자적으로 업데이트 한 후, 메시지를 교환한다. 그러나 NoSQL을 쓰는 이벤트 저장소는 동일한 트랜잭션에 참여할 수 없기 때문에 다른 방법을 궁리해야 한다.

### 코레오그래피 사가 구현: 이벤트 소싱
이벤트 소싱은 속성상 이벤트가 모든 것을 주도하므로 코레오그래피 사가를 아주 쉽게 구현할 수 있다.

- 애그리거트가 업데이트되면 사가가 이벤트를 발생
- 제각기 배정된 이벤트 핸들러는 해당 이벤트를 소비한 후 애그리거트를 업데이트
- 이벤트 소싱 프레임워크는 각 이벤트 핸들러를 알아서 멱등하게 만든다.

이벤트 소싱과 코레오그래피 사가는 찰떡궁합니다. 이벤트 소싱은 메시징 기반의 IPC, 메시지 중복 제거, 원자적 상태 업데이트와 메시지 전송 등 사가가 필요로 하는 여러 가지 메커니즘을 제공한다. 물론 코레오그래피 사가는 단순해서 좋지만 단점도 많다. 특히 이벤트 소싱에서만 해당되는 단점이 하나 있다.

**사가 코레오그래피에 이벤트를 사용하면 이벤트의 목적이 이원화되는 문제다.**

- 이벤트 소싱은 상태 변화를 나타내기 위해 이벤트를 이용하는데, 이벤트를 사가 코레오그래피에 갖다 쓰면 애그리거트는 상태 변화가 없어도 무조건 이벤트를 발생시켜야 한다.
- 애그리거트를 업데이트하면 비즈니스 규칙에 위배될 경우, 애그리거트는 반드시 이벤트를 발생시켜 오류를 보고해야 한다.
- 더 큰 문제는 **사가 참여자가 애그리거트를 생성할 수 없는 경우다.** 에러 이벤트를 발생시킬 애그리거트가 하나도 없을 것이다.

이런 문제가 있어 조금 더 복잡하지만 **오케스트레이션 사가를 구현하는 것이 최선이다.**

### 오케스트레이션 사가 생성
- 사가 오케스트레이터는 일부 서비스 메서드에 의해 생성된다.
- `OrderService.createOrder()` 같은 다른 서비스 메서드는 애그리거트를 생성/수정하고 사가 오케스트레이터를 생성하는 두 가지 일을 한다.
- 서비스는 이 두 가지 액션을 첫 번째 액션이 수행되면 두 번째 액션은 최종적으로 실행되는 방식으로 수행한다.
- 두 액션이 서비스에서 반드시 수행되도록 보장하는 방법은 이벤트 저장소의 종류마다 다르다.

#### 사가 오케스트레이터 작성: RDBMS 이벤트 저장소 사용 서비스
RDBMS 이벤트 저장소를 사용하는 서비스에선 **이벤트 저장소를 업데이트하고 사가 오케스트레이터를 생성하는 작업을 한 트랜잭션으로 묶을 수 있다.**

`OrderService`가 이벤추에이트 로컬 및 트램 사가 프레임워크를 사용한다면 `createOrder()`는 다음과 같이 구현할 수 있다.

```java
public class OrderService {
  // ...
  
  @Autowired
  private SagaManager<CreateOrderSagaState> createOrderSagaState;

  @Transactional
  public EntityWithIdAndVersion<Order> createOrder(OrderDetails orderDetails) {
    // Order 애그리거트 생성
    EntityWithIdAndVersion<Order> order = orderRepository.save(new CreateOrder(orderDetails));

    CreateOrderSagaState data = new CreateOrderSagaState(order.getId(), orderDetails);

    createOrderSagaManager.create(data, Order.class, order.getId());

    return order;
  }
  // ...
}
```

이벤추에이트 로컬은 RDMBS를 사용하므로 이벤추에이트 트램 사가 프레임워크와 동일한 ACID 트랜잭션에 참여할 수 있다. 하지만 NoSQL 이벤트 저장소를 사용하는 서비스는 사가 오케스트레이터를 생성하는 것이 이렇게 간단하진 않다.

#### 사가 오케스트레이터 작성: NoSQL 이벤트 저장소 사용 서비스
NoSQL 이벤트 저장소를 사용하는 서비스는 이벤트 저장소를 업데이트하고 사가 오케스트레이터를 생성하는 액션을 원자적으로 수행할 수 없다. 사가 오케스트레이션 프레임워크가 전혀 다른 DB를 사용할 수도 있다.

동일한 NoSQL DB를 사용한다 해도 NoSQL DB 특성상 트랜잭션 모델이 제한적이므로 애플리케이션에서 상이한 두 객체를 원자적으로 생성/수정할 수는 없다. 그 대신 서비스는 애그리거트가 발생시킨 도메인 이벤트에 반응하여 사가 오케스트레이터를 생성하는 이벤트 핸들러를 갖고 있어야 한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/b8c54c01-e67f-43dc-8b10-583fe630a7c7)

사가 오케스트레이터를 생성하는 이벤트 핸들러를 작성할 때 주의할 점은 **중복 이벤트를 처리해야 한다는 사실**이다. 적어도 한 번은 메시지를 전달하기 때문에 사가를 생성하는 이벤트 핸들러가 여러 번 호출될 수 있다. 사가 인스턴스를 정확히 하나만 생성하도록 할 수는 없을까?

가장 쉬운 방법은 이벤트의 유일한 속성에서 사가 ID를 추출하는 것이다.

1. 이벤트를 발생시킨 애그리거트 ID를 사가 ID로 쓰는 것이다. 애그리거트 생성 이벤트에 반응하여 생성되는 사가에 적합하다.
2. 이벤트 ID를 사가 ID로 쓰는 것이다. 이벤트 ID는 유일하므로 사가 ID 역시 반드시 유일하다. 중복 이벤트라면 이벤트 핸들러가 사가를 생성 시도할 때 해당 ID가 이미 존재할 테니 실패할 것이다. 동일한 사가 인스턴스가 여럿 존재할 가능성이 있을 경우 괜찮은 방법이다.

RDBMS 이벤트 저장소를 사용하는 서비스 역시 동일한 이벤트 주도 방식으로 사가를 생성할 수 있다. `OrderService` 같은 서비스가 더 이상 명시적으로 사가 인스턴스를 생성하지 않으므로 느슨한 결합이 장려되는 장점이 있다.

### 이벤트 소싱 기반의 사가 참여자 구현
오케스트레이션 사가에 참여해야 하는 서비스를 이벤트 소싱으로 구현했다고 하자. 이벤추에이트 로컬처럼 RDBMS 이벤트 저장소를 이용한 서비스라면 별로 어렵지 않게 사가 커맨드 메시지를 원자적으로 처리하고 응답을 보낼 수 있다. 이벤추에이트 트램 프레임워크가 시작한 ACID 트랜잭션의 일부로 이벤트 저장소를 업데이트하는 것이다. 하지만 이벤추에이트 트램 프레임워크와 동일한 트랜잭션으로 묶을 수 없는 이벤트 저장소를 이용하는 서비스는 전혀 다른 방법을 조사해야 한다.

다음 두 가지 이슈를 해결해야 한다.

- 커맨드 메시지를 멱등하게 처리
- 응답 메시지를 원자적으로 전송

#### 커멘드 메시지를 멱등하게 처리
우선 **이벤트 소싱 기반의 사가 참여자가 중복 메시지를 솎아 낼 수 있는 수단을 마련해야** 한다. 멱등한 메시지 처리 메커니즘을 활용하면 쉽게 해결할 수 있다. **메시지를 처리할 때 생성되는 이벤트에 메시지 ID를 기록**하면 사가 참여자는 다음에 애그리거트를 업데이트하기 전에 메시지 ID를 이벤트에서 꺼내 보고 자신이 이전에 이 메시지를 처리한 적이 있는지 확인하는 것이다.

#### 응답 메시지를 원자적으로 전송
이벤트 소싱 기반의 사가 참여자가 원자적으로 응답을 전송하는 방법이다.

이론적으로 사가 오케스트레이터는 애그리거트가 발생시킨 이벤트를 구독할 수 있지만, 그러면 두 가지 문제가 생긴다.

- 사가 커맨드가 실제로 애그리거트 상태를 변경하지 않을지도 모른다. 이 경우 애그리거트는 이벤트를 발생시키지 않으니 사가 오케스트레이터에는 아무 응답도 전송되지 않는다.
- 이벤트 소싱을 이용하는 사가 참여자와 그렇지 않은 참여자를 사가 오케스트레이터가 다르게 취급해야 한다. 사가 오케스트레이터가 도메인 이벤트를 수신하려면 자신의 응답 채널뿐만 아니라, 애그리거트의 이벤트 채널도 함께 구독해야 하기 때문이다.

사가 참여자가 사가 오케스트레이터의 응답 채널로 응답 메시지를 계속 보내는 것이 더 나은 방법이지만, 사가 참여자는 응답 메시지를 직접 보내는 것이 아니라 다음 2단계 프로세스를 거친다.

1. 사가 커맨드 핸들러가 애그리거트를 생성/수정할 때, 애그리거트가 발생시킨 진짜 이벤트와 가짜 이벤트 `SagaReplyRequested`를 모두 이벤트 저장소에 저장한다.
2. `SagaReplyRequested` 이벤트 핸들러는 이벤트에 포함된 데이터로 응답 메시지를 만들어 사가 오케스트레이터의 응답 채널에 출력한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/92d20608-cc7e-4b16-a33a-1828d97948ae)

위 그림은 사가가 전송한 이증 커맨드를 이벤추에이트 사가 프레임워크로 구현한 회계 서비스에서 처리하는 과정이다. 이벤트 순서는 다음과 같다.

1. 주문 생성 사가가 계좌 인증 커맨드를 매시징 채널을 통해 회계 서비스로 보낸다. 이벤추에이트 사가 프레임워크의 `SagaCommandDispatcher`는 `AccountingServiceCommandHandler`를 호출하여 커맨드 메시지를 처리한다.
2. `AccountingServiceCommandHandler`는 주어진 `Accounting` 애그리거트로 커맨드를 전송한다.
3. 애그리거트가 `AccountAuthorizedEvent`와 `SagaReplyRequestedEvent` 두 이벤트를 발생시킨다.
4. `SagaReplyRequested` 이벤트 핸들러는 주문 생성 사가에 응답 메시지를 전송하여 `SagaReplyRequestedEvent`를 처리한다.

`AccountingServiceCommandHandler`는 `Account` 애그리거트를 업데이트하기 위해 `AggregateRepository.update()`를 호출하는 식으로 `AuthorizeAccount` 커맨드 메시지를 처리한다.

```java
public class AccountingServiceCommandHandler {
  
  @Autowired
  private AggregateRepository<Account, AccountCommand> accountRepository;

  public void authorize(CommandMessage<AuthorizeCommand> cm) {
    AuthorizeCommand command = cm.getCommand();
    accountRepository.update(command.getOrderId(), command,
      replyingTo(cm)
        .catching(AccountDisabledException.class, () -> withFailure(new AccountDisabledReply()))
        .build());
  }

  // ...
}
```

`UpdateOptions`는 다음과 같은 일을 수행하기 위해 `update()`를 구성한다.

- 메시지가 꼭 한 번만 처리되도록 메시지 ID를 멱등성 키로 사용한다. 이벤추에이트 프레임워크는 생성된 모든 이벤트에 멱등성 키를 저장하는 식으로 애그리거트 업데이트를 시도하는 중복 메시지를 발견하여 무시한다.
- 이벤트 저장소에 저장된 이벤트 목록에 가짜 이벤트 `SagaReplyRequestedEvent`를 추가한다. `SagaReplyRequestedEventHandler`가 이 가짜 이벤트를 받으면 `CreateOrderSaga`의 응답 채널로 응답을 보낸다.
- 애그리거트가 `AccountDisabledException`을 던질 때 기본 에러 응답 대신 `AccountDisabledReply`를 전송한다.

### 사가 오케스트레이터 구현: 이벤트 소싱
사가 오케스트레이터도 이벤트 소싱을 이용하여 구현할 수 있다. 구현 전에 고민해야 할 세 가지 설계 이슈가 있는데 다음과 같다.

- 사가 오케스트레이터를 어떻게 저장할 것인가?
- 어떻게 오케스트레이터 상태를 원자적으로 변경하고 커맨드 메시지를 전송할 것인가?
- 어떻게 사가 오케스트레이터가 정확히 한 번만 메시지를 응답하게 만들 것인가?

#### 이벤트 소싱으로 사가 오케스트레이터 저장
사가 오케스트레이터의 일생은 아주 단순하다. 처음 생성된 다음부턴 사가 참여자의 응답에 반응하며 계속 업데이트된다. 그러므로 사가는 다음 이벤트를 이용하여 저장할 수 있다.

- `SagaOrchestratorCreated`: 사가 오케스트레이터가 생성되었다.
- `SagaOrchestratorUpdated`: 사가 오케스트레이터가 수정되었다.

사가 오케스트레이터는 생성될 때 `SagaOrchestratorCreate` 이벤트, 수정될 때 `SagaOrchestratorUpdated` 이벤트를 발생시킨다. 이 두 이벤트는 사가 오케스트레이터의 상태 재구성에 필요한 데이터를 갖고 있다.

ex) `CreateOrderSaga`의 이벤트엔 JSON 등으로 직렬화한 `CreateOrderSagaState`가 있다.

#### 커맨드 메시지를 확실하게 전송
사가 상태를 원자적으로 업데이트하고 커맨드를 전송하는가 하는 문제를 생각해야 한다.

이벤추에이트 트램 기반의 사가는 오케스트레이터를 업데이트하고 커맨드 메시지를 메시지 테이블에 삽입하는 메시지 테이블에 삽입하는 작업을 한 트랜잭션으로 묶어 수행했다. 이벤추에이터 로컬 같은 RDBMS 이벤트 저장소를 사용하는 애플리케이션은 이와 동일한 방법을 쓸 수 있다. 이벤추에이트 SaaS 같은 NoSQL 이벤트 저장소를 사용하는 애플리케이션 역시 트랜잭션 모델이 매우 제한적이기는 하지만 비슷한 방법으로 접근할 수 있다.

바로 전송할 커맨드를 나타낸 `SagaCommandEvent`를 저장하는 것이다. 그러면 이벤트 핸들러는 이 이벤트를 구독해서 적절한 채널로 각 커맨드 메시지를 전송한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/daf16d8f-2817-433e-b7b8-cb76db7c40b3)

사가 오케스트레이터는 다음 두 단계로 커맨드를 전송한다.

1. 사가 오케스트레이터가 전송하려는 각 커맨드마다 `SagaCommandEvent`를 발생시킨다. `SagaCommandEvent`에는 목적지 채널, 커맨드 객체 등 커맨드 전송에 필요한 데이터가 모두 담겨있다. 이런 이벤트는 이벤트 저장소에 저장된다.
2. 이벤트 핸들러는 `SagaCommandEvent` 처리 후 커맨드 메시지를 목적지 메시지 채널로 보낸다.

이렇게 두 단계로 처리하니 적어도 1회 이상은 커맨드가 전송될 것이다.

동일한 이벤트를 받아 여러 번 이벤트 핸들러가 호출될 수 있는 구조이기 때문에 `SagaCommandEvent` 핸들러가 중복된 커맨드 메시지를 전송할 수도 있다. 하지만 다행히 유일성이 보장된 `SagaCommandEvent`의 ID를 커맨드 메시지 ID로 사용하면, 중복 메시지는 결국 동일한 ID를 가지게 되므로 사가 참여자는 쉽게 중복 메시지를 걸러 낼 수 있다.

#### 응답을 꼭 한 번만 처리
사가 오케스트레이터 역시 앞서 설명한 방법으로 중복된 응답 메시지를 솎아 낼 필요가 있다. 오케스트레이터가 응답 메시지 ID를 (응답을 처리할 때 오케스트레이터가 발생시킬) 이벤트에 보관하면 어느 메시지가 중복인지 쉽게 분간할 수 있다.

이벤트 소싱은 사가를 구현하기에 아주 훌륭한 기반 기술이다. 다른 장점도 많지만 무엇보다 **데이터가 변경될 때마다 이벤트를 생성하고 확실하게 감사 로그를 남기는 기능이 내장되어 있고 임시 쿼리를 수행할 수 있는 능력이 돋보인다.** 물론 익숙해지려면 학습 시간이 꽤 걸리고, 이벤트 스키마를 발전시키기 어려운 경우도 있다는 단점이 있다.

하지만 이벤트 소싱은 마이크로서비스 아키텍처에서 중요한 비중을 차지한다.

## 정리
- 이벤트 소싱은 애그리거트를 일련의 이벤트로 저장하며, 여기서 각 이벤트는 애그리거트의 생성 또는 상태 변화를 나타낸다. 이벤트를 재생하면 특정 애그리거트 상태를 그대로 재생성할 수 있다. 이벤트 소싱 덕분에 도메인 객체의 이력 및 감사 로그를 정확히 남기고 도메인 이벤트를 확실하게 발행할 수 있다.
- 스냅샷은 재연해야 할 이벤트 개수를 줄여 성능을 향상시킨다.
- 이벤트는 DB와 메시지 브로커를 혼합한 형태인 이벤트 저장소에 저장된다. 서비스가 이벤트를 이벤트 저장소에 저장하면, 이벤트 저장소는 이벤트를 구독기에 전달한다.
- 이벤추에이트 로컬은 MySQL 및 Apache Kafka 기반으로 개발한 오픈 소스 이벤트 저장소다. 개발자는 이벤추에이트 클라이언트 프레임워크를 이용하여 애그리거트 및 이벤트 핸들러를 작성할 수 있다.
- 애플리케이션에서 이벤트 재연 시 여러 버전의 이벤트를 처리해야 할 수도 있기 때문에 이벤트 발전을 다루는 일이 관건이다. 따라서 이벤트 저장소에서 이벤트를 가져올 때 최근 버전으로 이벤트를 업그레이드하는 업캐스팅이 좋은 방법이다.
- 이벤트 소싱 애플리케이션은 데이터를 삭제하기 까다롭다. 개인 정보를 삭제하는 애플리케이션에서 유럽 연합 GDPR 등의 규정을 준수하려면 암호화/가명화 등의 기법을 동원해야 한다.
- 이벤트 소싱을 이용하면, 이벤트 소싱 기반의 애그리거트가 발행한 이벤트를 리스닝하는 이벤트 핸들러가 서비스에 달려 있기 때문에 코레오그래피 사가를 간단히 구현할 수 있다.
- 이벤트 소싱은 사가 오케스트레이터를 구현하기 좋은 수단이다. 덕분에 이벤트 저장소를 배타적으로 사용하는 애플리케이션을 작성할 수 있다.