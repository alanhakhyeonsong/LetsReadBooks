# 2장. 분해 전략
## 마이크로서비스 아키텍처란 무엇인가?
소프트웨어 아키텍처는 구성 요소 및 그들 간의 디펜던시로 엮인 고수준의 구조물이다. 애플리케이션 아키텍처는 다차원적이므로 기술하는 방법도 다양하다. 아키텍처가 중요한 이유는 소프트웨어의 품질 속성 지표가 아키텍처에 의해 결정되기 때문이다.

확장성, 신뢰성, 보안 등이 아키텍처의 목표였지만, 이제는 신속/안전하게 소프트웨어를 전달하는 능력도 매우 중요하다. 마이크로서비스 아키텍처는 관리성, 테스트성, 배포성이 높은 애플리케이션을 구축하는 아키텍처 스타일이다.

### 소프트웨어 아키텍처의 정의
> 컴퓨팅 시스템의 소프트웨어 아키텍처는 소프트웨어 엘리먼트와 그들 간의 관계, 그리고 이 둘의 속성으로 구성된 시스템을 추론하는 데 필요한 구조의 집합이다. - Documenting Software Architectures, Bass 등

핵심은 애플리케이션 아키텍처가 여러 파트로의 분해와 이런 파트 간의 관계(연관성)라는 것이다. 분해가 중요한 이유는 다음 두 가지 때문이다.
- 업무와 지식을 분리한다. 덕분에 전문 지식을 보유한 사람들(또는 여러 팀)이 함께 생산적으로 애플리케이션 작업을 할 수 있다.
- 소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힌다.

### 소프트웨어 아키텍처의 4+1 뷰 모델
- 논리 뷰(logical view): 개발자가 작성한 소프트웨어 엘리먼트, 객체 지향 언어라면 클래스 패키지가 해당되며 결국 상속, 연관, 의존 등 클래스와 패키지의 관계를 말한다.
- 구현 뷰(implementation view): 빌드 시스템의 결과물, 모듈(패키징된 코드)과 컴포넌트(하나 이상의 모듈로 구성된 실행/배포 가능 단위)로 구성된다. Java에서 모듈은 보통 JAR 파일, 컴포넌트는 WAR 파일이나 실행 가능한 JAR 파일이다. 모듈 간 디펜던시와 컴포넌트/모듈 간 조합 관계도 이 뷰에 포함된다.
- 프로세스 뷰(process view): 런타임 컴포넌트. 각 엘리먼트는 개별 프로세스고, IPC는 프로세스 간 관계를 나타낸다.
- 배포 뷰(deployment view): 프로세스가 머신에 매핑되는 방법. 이 뷰의 엘리먼트는 (물리 또는 가상) 머신 및 프로세스고, 머신 간의 관계가 바로 네트워킹이다. 프로세스와 머신 사이의 관계도 이 뷰에서 기술된다.

이 외에도 뷰를 구동시키는 시나리오가 있다. 각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍처 요소가 협동하여 요청을 처리하는지 기술한다.

### 아키텍처의 중요성
애플리케이션의 요건은 크게 두 가지 종류로 나뉜다.
- 애플리케이션이 해야 할 일을 정의한 기능 요건
- '~성'으로 끝나는 서비스 품질 요건

## 계층화 아키텍처 스타일
소프트웨어 엘리먼트를 계층별로 구성하는 전형적인 아키텍처 스타일이다. 계층마다 명확히 정의된 역할을 분담하며, 계층 간 디펜던시는 아키텍처로 제한한다. 따라서 어떤 계층은 바로 하위에 있는 계층에만 의존하거나(계층화를 엄격히 할 경우), 하위에 위치한 어느 한 계층에 의존한다.

- presentation layer: 사용자 인터페이스 또는 외부 API가 구현된 계층
- business logic layer: 비즈니스 로직이 구현된 계층
- persistence layer: DB 상호 작용 로직이 구현된 계층

계층화 아키텍처는 몇 가지 중요한 흠이 있다.
- 표현 계층이 하나뿐이다: 애플리케이션을 호출하는 시스템이 하나밖에 없을까?
- 영속화 계층이 하나뿐이다: 애플리케이션이 상호 작용하는 DB가 정말 하나뿐일까?
- 비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다: 이론적으로 이런 디펜던시 때문에 DB 없이 비즈니스 로직을 테스트하는 것은 불가능함

또한 잘 설계된 애플리케이션에서 디펜던시를 잘못 나타내는 문제도 있다.  
일반적으로 비즈니스 로직 계층은 인터페이스나 데이터 접근 메서드가 정의된 인터페이스 리포지터리를 정의하고, 영속화 계층은 리포지터리 인터페이스를 구현한 DAO 클래스를 정의한다. 결국 실제 디펜던시가 계층화 아키텍처에서 기술된 것과는 정반대이다.

## 헥사고날 아키텍처 스타일
애플리케이션에 표현 계층 대신 비즈니스 로직을 호출하여 외부에서 들어온 요청을 처리하는 인바운드 어댑터들과 영속화 계층 대신 비즈니스 로직에 의해 호출되고 외부 애플리케이션을 호출하는 아웃바운드 어댑터들을 둔다. **비즈니스 로직이 어댑터에 전혀 의존하지 않는다는 것이 이 아키텍처의 가장 중요한 특장점이다.**

![](https://velog.velcdn.com/images/songs4805/post/5e58d270-5cdb-4b0c-a91b-db9614790bad/image.png)

- 인바운드 포트: 비즈니스 로직이 표출된 API로서, 외부 애플리케이션은 이 API를 통해 비즈니스 로직을 호출한다. (ex. Service의 public 메서드가 정의된 Service Interface)
- 아웃바운드 포트: 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한 것. (ex. 데이터 접근 작업이 정의된 Repository Interface)
- 인바운드 어댑터: 외부에서 들어온 요청을 인바운드 포트를 호출해서 처리. (ex. REST 끝점, 웹 페이지가 구현된 Spring MVC 컨트롤러, 메시지를 구독하는 메시지 브로커 클라이언트)
  - 동일한 인바운드 포트를 여러 인바운드 어댑터가 호출할 수도 있다.
- 아웃바운드 어댑터: 비즈니스 로직에서 들어온 요청을 외부 애플리케이션/서비스를 호출해서 처리. (ex. DB 작업이 구현된 데이터 접근 객체(DAO) 클래스, 원격 서비스를 호출하는 프록시 클래스)
  - 아웃바운드 어댑터는 이밴트를 발행하기도 한다.

육각형 아키텍처 스타일의 가장 큰 장점은 **비즈니스 로직에 있던 표현/데이터 접근 로직이 어댑터와 분리되었기 때문에 비즈니스 로직이 표현/데이터 접근 로직 어디에도 의존하지 않는다는 점이다.**

이렇게 분리를 하니 **비즈니스 로직만 따로 테스트하기도 쉽고, 현대 에플리케이션 아키텍처를 좀 더 명확하게 반영할 수 있다.** 제각기 특정한 API나 UI가 구현된 인바운드 어댑터가 비즈니스 로직을 호출하고, 비즈니스 로직은 다양한 외부 시스템을 호출하는 아웃바운드 어댑터를 호출하는 구조다. MSA를 이루는 각 서비스 아키텍처를 기술하는 가장 좋은 방법이다.

![](https://velog.velcdn.com/images/songs4805/post/b02b1628-f61a-4cdb-b39b-29cff5b9e992/image.png)

**모놀리식 아키텍처는 구현 뷰를 단일 컴포넌트(하나의 실행 파일이나 WAR 파일)로 구성한 아키텍처 스타일이다.** 다른 뷰는 일체 등장하지 않는다.

마이크로서비스 아키텍처는 **구현 뷰를 다수의 컴포넌트(여러 실행 파일이나 WAR 파일)로 구성하는 차이점이 있다.** 여기서 컴포넌트는 곧 서비스고, 각 서비스는 자체 논리 뷰 아키텍처를 갖고 있다. 커넥터는 이런 서비스가 서로 협동할 수 있게 해주는 통신 프로토콜이다.

**마이크로서비스 아키텍처의 핵심 제약 조건은 서비스를 느슨하게 결합한다는 것이다.**

### 서비스란 무엇인가?
**서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트이다.** 클라이언트가 자신이 서비스하는 기능에 접근할 수 있도록 커멘드, 쿼리, 이벤트로 구성된 API를 제공한다. 서비스 작업은 크게 Command(명령/CUD)와 Query(조회/R)로 나뉜다. 서비스는 클라이언트가 소비하는 `OrderCreated`와 같은 이벤트를 발행하기도 한다.

서비스 API는 내부 구현 상세를 캡슐화한다. 모놀리스와 달리 개발자는 API를 우회하여 서비스에 접근하는 코드를 작성할 수 없으므로 MSA에서 애플리케이션 모듈성은 보장된다.

API는 서비스에 구현된 비즈니스 로직과 소통하는 어댑터를 이용하여 구현한다. 작업 어댑터(operations adapter)는 비즈니스 로직을 호출하고 이벤트 어댑터(events adapter)는 비즈니스 로직이 내어 준 이벤트를 발행한다.

![](https://velog.velcdn.com/images/songs4805/post/0eb1fd38-9d93-4342-af0f-87ecd48424f8/image.png)

### 느슨한 결합
서비스는 구현 코드를 감싼 API를 통해서만 상호 작용하므로 클라이언트에 영향을 끼치지 않고 서비스 내부 구현 코드를 바꿀 수 있다. 느슨하게 결합된 서비스는 유지보수성, 테스트성을 높이고 애플리케이션 개발 시간을 단축하는 효과가 있다. 무엇보다 개발자가 서비스를 이해하고, 변경하고, 테스트하기가 더 쉽다.

**서비스가 직접 DB와 통신하는 일은 불가능하다.** 또 클래스 필드 같은 서비스의 영속적 데이터는 반드시 프라이빗으로 유지해야 한다. 이렇게 해야 개발자가 자신이 맡은 서비스의 DB 스키마를 변경할 때 다른 서비스 개발자와 조율하느라 시간을 허비하지 않는다. 서비스가 DB 테이블을 서로 공유하지 않기 때문에 런타임 격리도 향상된다. 어떤 서비스가 DB 락을 획득하여 다른 서비스를 블로킹하는 일 자체가 불가능하다. **물론 DB를 공유하지 않기 때문에 여러 서비스에 걸쳐 데이터를 쿼리하고 일관성을 유지하는 일은 더 복잡해지는 단점이 있다.**

### 공유 라이브러리의 역할
코드 중복을 방지하기 위해 여러 애플리케이션에서 재사용 가능한 기능을 라이브러리(모듈)로 패키징하는 것은 개발자에게 당연한 일이다. MSA에서도 공유 라이브러리를 사용하고픈 유혹에 빠지기 쉬운데, 서비스 코드 중복을 줄이는 것은 좋지만 의도치 않은 서비스 간 결합도를 유발하지 않도록 조심해야 한다.

### 서비스 규모는 별로 중요하지 않다
크기보다는 작은 팀이 가장 짧은 시간에, 다른 팀과 협동하는 부분은 최소로 하여 개발 가능한 서비스를 설계해야 한다. 이론적으론 한 팀이 한 서비스를 맡을 수도 있는데, 이런 경우라면 마이크로서비스가 '마이크로'하다고 볼 수 없다. 반대로 대규모 팀을 꾸려야 하거나 서비스를 테스트하는 시간이 너무 오래 걸리면 팀과 서비스를 분할해야 한다. 다른 서비스의 변경분 때문에 내가 맡은 서비스도 계속 바꾸어야 한다거나, 내 서비스 때문에 다른 서비스가 바뀌어야 한다면 서비스가 느슨하게 결합되지 않았다는 반증이다.