# 8장. 외부 API 패턴
모놀리식 애플리케이션은 그 자체의 API가 클라이언트에 표출되지만, 마이크로서비스로 배포하면 서비스마다 API를 갖고 있기 때문에 어떤 종류의 API를 클라이언트에 표출해야 할지 결정해야 한다.

애플리케이션의 외부 API는 클라이언트 종류가 다양한 만큼 설계하기 어렵다. 성격이 다른 클라이언트마다 다른 종류의 데이터를 요구할 것이다. 가령 일반적으로 데스크톱 브라우저 UI는 모바일 앱보다 더 많은 정보를 화면에 표시한다. 또 서비스에 접근하는 네트워크 경로가 클라이언트마다 다르다. 방화벽 내부 클라이언트는 고성능 LAN을 통해 접속하지만 방화벽 외부의 클라이언트는 성능이 낮은 인터넷이나 모바일 네트워크를 통해 들어온다. 따라서 만능 API 같은 것은 없다.

## 외부 API 설계 이슈
아래는 예제 애플리케이션의 서비스 API를 소비하는 네 종류의 클라이언트다.

- 브라우저 기반의 일반 소비자 및 음식점 전용 UI, 내부 관리자용 UI가 구현된 웹 애플리케이션
- 브라우저에서 실행 중인 자바스크립트 애플리케이션
- 소비자용/배달원용 모바일 앱
- 서드파티 애플리케이션

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/85c0c130-24ce-48bc-9c2d-2a572112d8a2)

웹 애플리케이션은 방화벽 내부에서 실행되기 때문에 대역폭이 높고 지연 시간이 짧은 LAN을 통해 서비스에 접속하지만, 다른 클라이언트는 방화벽 외부에 있으므로 상대적으로 대역폭이 낮고 지연이 높은 인터넷 또는 모바일 네트워크 환경에 서비스에 접근한다.

클라이언트가 서비스를 직접 호출하도록 API를 설계할 수도 있다. 그러나 이런 방식은 마이크로서비스 아키텍처에선 다음과 같은 단점이 있어 거의 쓰지 않는다.

- 서비스 API가 잘게 나뉘어져 있어서 클라이언트가 필요한 데이터를 가져오려면 여러 번 요청을 해야 하고, 그만큼 효율이 떨어지고 UX는 나빠진다.
- 클라이언트가 서비스 및 API를 알아야 하는 구조라서 캡슐화가 되지 않고, 나중에 아키텍처와 API를 바꾸기도 어렵다.
- 클라이언트(특히 방화벽 외부에 있는 클라이언트)가 사용하기에 불편하거나 실용적이지 못한 IPC를 서비스에서 사용 중인 경우가 있다.

### API 설계 이슈: FTGO 모바일 클라이언트
소비자는 모바일 클라이언트에 접속해 주문하고 이력을 관리한다. 주문 상태, 지불 상태, 음식점 관점에서의 주문 상태 등의 주문 기본 정보와 배달 중일 경우 현재 위치 및 예상 배달 시간 등의 배달 상태를 한눈에 볼 수 있는 주문 조회 뷰를 개발한다 하자.

모놀리식 버전에선 주문 내역을 반환하는 API 끝점이 있어 모바일 클라이언트가 원하는 정보를 요청 한 번으로 모두 가져올 수 있지만, 마이크로서비스 버전은 주문 데이터가 여러 서비스에 분산되어 있다.

모바일 클라이언트가 서비스를 직접 호출하는 구조라면, 서비스를 여러 번 호출해서 데이터를 가져올 수밖에 없다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/510ad3d8-57dd-4fc9-bbe2-769801ebca96)

모바일 앱이 여러 서비스를 호출해서 그 결과를 조합하는 API 조합기 역할을 맡은 것이다. 이렇게 설계하는 것도 그리 나쁘지 않아 보이지만, 몇 가지 심각한 문제점을 안고 있다.

#### 클라이언트가 요청을 여러 번 전송하기 때문에 UX가 나빠진다
모바일 앱이 사용자에게 보여 줄 데이터를 여러 번 요청해서 가져와야 한다. 애플리케이션과 서비스 간 상호 작용이 너무 자주 발생하면 애플리케이션이 멎은 것처럼 보일 수 있다. 인터넷은 LAN보다 대역폭이 훨씬 낮고 지연 시간이 길다. 모바일 네트워크는 사정이 더 나쁘다.

모바일 앱은 동시에 요청을 실행해 지연을 최소화하기 때문에 주문 내역을 조회할 때 더 높은 지연 시간이 문제가 되지 않을 수도 있다. 전체 응답 시간이 요청 하나의 응답 시간보다 길지 않다. 하지만 클라이언트가 요청을 순차 실행할 수 밖에 없는 상황이라면 UX가 형편없이 나빠질 것이다.

네트워크 지연으로 인한 UX가 나빠지는 것도 문제지만, 모바일 개발자가 복잡한 API 조합 코드를 작성할 일이 많아지게 되면 결국 UX를 개선해야 하는 본연의 임무를 달성하기 어렵다. 네트워크 요청 횟수가 늘어날수록 전력 소모도 커질 테니 모바일 기기의 배터리도 더 빨리 닳을 것이다.

#### 캡슐화가 되지 않아 프론트엔드 개발자가 백엔드와 맞물려 코드를 변경해야 한다
캡슐화가 되지 않는 것도 문제다. 애플리케이션이 발전함에 따라, 기존 클라이언트와 호환되지 않는 변경을 해야 할 일이 생긴다. 서비스에 관한 지식이 모바일 앱에 포함되어 있으면 서비스 API를 변경하기 아주 곤란해질 수 있다.

#### 클라이언트에 비친화적인 IPC를 사용 중인 클라이언트도 있다
클라이언트가 소비하기 어려운 프로토콜을 사용하는 서비스도 있다. gRPC 기반의 서비스도 있고, AMQP 같은 메시징 프로토콜을 쓰는 서비스도 있을 것이다. 이런 종류의 프로토콜은 내부에선 잘 작동되지만, 모바일 클라이언트가 소비하기 어려운 경우가 많다. 더욱이 방화벽에 친화적이지 않은 프로토콜도 있다.

### API 설계 이슈: 다른 종류의 클라이언트
모바일 클라이언트뿐만 아니라 방화벽 외부에 있는 다른 종류의 클라이언트도 마찬가지다.

#### 웹 애플리케이션
전통적인 서버 쪽 웹 애플리케이션은 브라우저에서 HTTP 요청을 받아 HTML 페이지를 반환하며, 방화벽 내부에서 실행되고 LAN을 통해 서비스에 접근한다. 웹 애플리케이션에 API 조합 로직을 구현하는 데 있어 네트워크 대역폭과 지연 시간은 장애물이 아니다.

#### 브라우저 기반의 자바스크립트 애플리케이션
브라우저 기반의 자바스크립트 애플리케이션은 서비스 API 변경 시 업데이트하긴 쉽지만, 모바일 앱처럼 인터넷을 통해 서비스에 접근하기 때문에 네트워크 지연 문제는 별만 다를 바 없다. 보통 일반 모바일 앱보다 더 정교한 브라우저 기반의 UI는 더 많은 서비스를 조합해야 할 필요가 있다. 따라서 인터넷으로 접속한 소비자, 음식점 애플리케이션은 서비스 API를 효율적으로 조합하기 어려울 것이다.

#### 서드파티 애플리케이션
서드파티 애플리케이션은 인터넷을 통해 API에 접속하기 때문에 API 조합이 비효율적인 공산이 크지만, 이는 서드파티 애플리케이션용 API를 설계하는 어려움에 비하면 사소한 문제다. 서드파티 개발자에겐 안정된 API가 필요하기 때문이다.

호환성을 문제로 무작정 버전 업그레이드를 강요할 수는 없다. 장기간 하위 호환성을 관리할 책임을 백엔드 서비스 개발자에게 지우기란 현실적으로 어렵다. 따라서 서드파티 개발자에게 직접 서비스를 표출하는 대신 별도 팀에서 개발한 퍼블릭 API를 따로 가져가는 것이 좋다. 이런 퍼블릭 API를 API 게이트웨이라는 아키텍처 컴포넌트로 구현한다.

## API 게이트웨이 패턴
서비스에 직접 접근하면 여러모로 문제가 많다.

- 클라이언트가 인터넷을 통해 API를 조합한다는 것 자체가 실용적인 발상이 아니다.
- 캡슐화가 안되므로 개발자가 서비스를 분해하고 API를 변경하기도 어렵다.
- 방화벽 외부에서 부적절한 프로토콜로 통신하는 서비스도 있기 때문에 API 게이트웨이를 사용하는 것이 훨씬 나은 방법이다.

### API 게이트웨이 패턴 개요
**API 게이트웨이는 방화벽 외부의 클라이언트가 애플리케이션에 API 요청을 하는 단일 창구 역할을 하는 서비스다.** 퍼사드처럼 API 게이트웨이도 내부 애플리케이션 아키텍처를 캡슐화하고 자신의 클라이언트에는 API를 제공한다. 인증, 모니터링, 사용량 제한 등 부수적인 일도 담당한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/d067bb05-65be-40c5-b79e-13c28270fe7f)

API 게이트웨이는 요청 라우팅, API 조합, 프로토콜 변환을 관장한다. 외부 클라이언트의 API 요청은 모두 API 게이트웨이로 향하고, API 게이트웨이는 적절한 서비스로 요청을 보낸다. 여러 서비스의 호출 결과를 취합하는 API 조합 패턴 방식으로 요청을 처리하기도 하며, 클라이언트에 친화적인 프로토콜과 비친화적인 프로토콜 간 변환도 한다.

#### 요청 라우팅
요청이 들어오면 API 게이트웨이는 라우팅 맵을 찾아보고 어느 서비스로 요청을 보낼지 결정한다. 라우팅 맵은 HTTP 메서드와 서비스의 HTTP URL을 매핑한 것이다. Nginx 같은 웹 서버의 리버스 프록시와 똑같다.

#### API 조합
API 게이트웨이는 단순 리버스 프록시보다 더 많은 일을 한다. API 조합도 그 중 하나다.

모바일 앱이 API 게이트웨이에 요청을 한 번 하면 API 게이트웨이는 여러 서비스에서 주문 내역 데이터를 조회한다. API 게이트웨이는 모바일 클라이언트가 요청 한 번으로 필요한 데이터를 조회할 수 있도록 대단위 API를 제공한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/5e0c2ab6-7bdc-4f35-9681-1a4ac767b60f)

#### 프로토콜 변환
애플리케이션 내부에서 REST와 gRPC를 혼용할 경우에도 외부 클라이언트에는 REST API를 제공할 수 있다. 프로토콜 변환이 필요한 경우, API 작업을 구현한 코드에서 외부 REST API ↔ 내부 gRPC API 변환을 한다.

#### API 게이트웨이는 클라이언트마다 적합한 API를 제공한다
만능 API를 제공한다. 개별 API는 각기 다른 클라이언트마다 요건도 천차만별이라는 문제가 있다. 퍼블릭 API는 어떤 필드와 객체를 반환해야 할지 클라이언트가 요청 시 지정하게 하면 되겠지만, 이렇게 클라이언트에 제어권을 순순히 내어주는 경우는 거의 없다.

API 게이트웨이가 각 클라이언트에 맞춤 API를 제공하는 방법이 좋다. 모바일 클라이언트에는 모바일 요건에 맞게 설계된 API를 제공하는 것이다. 뒤에 나오겠지만 BFF 패턴은 클라이언트마다 API 게이트웨이를 따로 정의해서 클라이언트 맞춤 API 개념을 발전시킨 것이다.

#### 엣지 기능 구현
- 인증
- 인가
- 사용량 제한
- 캐싱
- 지표 수집
- 요청 로깅

위와 같은 엣지 기능이 구현된 곳은 세 군데다.

- 백엔드 서비스: 캐싱, 지표 수집, 인증 같은 기능은 백엔드에 있어야 할 것 같지만, 요청이 서비스에 도달하기 전에 미리 애플리케이션이 요청을 인증하는 것이 더 안전하다.
- 외부 클라이언트와 직접 맞닿은 API 게이트웨이의 상류: 요청이 API 게이트웨이에 들어오기 전에 엣지 기능을 처리한다.
- 전용 엣지 서비스: 관심사가 분리되는 큰 장점이 있다. API 게이트웨이는 API 라우팅/조합에 집중하고 중요한 엣지 기능을 중앙화 할 수 있다. 특히 다양한 언어/프레임워크로 개발된 API 게이트웨이가 여러 개인 애플리케이션에서 유용하다.
  - 단점은 hop 카운트가 늘어나기 때문에 네트워크 지연이 증가하고 애플리케이션 복잡도 역시 증가한다는 점이다.

결론적으로 전용 엣지 서비스를 사용하되, 인증 같은 엣지 기능은 API 게이트웨이에 구현하는 방법이 간편하고 좋다. 네트워크 홉이 하나만 줄어도 지연 시간은 짧아지고, 가동부 개수가 줄면 복잡도도 낮아진다.

#### API 게이트웨이 아키텍처
API 게이트웨이는 API 계층과 공통 계층으로 구성된 모듈 아키텍처 구조다. API 계층에는 독립적인 하나 이상의 API 모듈이 있고, 각 API 모듈에는 특정 클라이언트용 API가 구현되어 있다. 공통 계층에는 엣지 기능 등의 공통 기능이 구현되어 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/65852a80-13dd-425b-8531-e5cb1401f470)

- 모바일 API
- 브라우저 API
- 퍼블릭 API

API 모듈은 두 가지 방법으로 각 API 작업을 구현한다.

- 서비스 API 하나에 직접 매핑되는 API 작업은 해당하는 각각의 서비스 API로 요청을 보낸다. 라우팅 규칙이 기술된 구성 파일을 읽어 들여 작동되는 범용 라우팅 모듈을 응용할 수 있다.
- API를 조합하는 복잡한 API 작업은 사용자 정의 코드로 구현한다. API 작업을 구현한 코드는 각각 여러 서비스를 호출하여 결과를 조합하는 방법으로 요청을 처리한다.

#### API 게이트웨이 소유권 모델
API 게이트웨이 개발/운영은 누가 담당할까? 몇 가지 방안이 있다.

먼저 API 게이트웨이를 전담할 팀을 따로 신설한다. 그러나 모바일 앱 개발자가 어떤 서비스 API에 접근해야 할 경우, API 게이트웨이 팀에 공식 요청한 후 원하는 API가 표출될 때까지 마냥 기다릴 수밖에 없다. 이렇게 중앙에서 병목 현상이 발생하는 모양새는 느슨하게 결합된 자율 팀을 지향하는 마이크로서비스 아키텍처의 사상과 배치된다.

넷플릭스에서 권장하는 바와 같이, API가 표출된 모듈은 해당 클라이언트 팀이 소유하는 구조가 바람직하다. API 게이트웨이 팀은 공통 모듈 개발 및 게이트웨이 운영 이슈에 집중하는 것이다. 이 소유권 모델에 따르면 API를 개발한 팀별로 권한을 부여한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/0d799bb5-64b1-4d16-99a3-56b71dea361e)

API를 변경할 일이 생기면 해당 팀이 변경된 소스를 API 게이트웨이 소스 리포지터리에 체크인한다. 매끄러운 협업을 위해 API 게이트웨이 배포 파이프라인을 완전히 자동화해야 한다. 안 그러면 클라이언트 팀은 API 게이트웨이 팀이 새 버전을 배포할 때까지 마냥 기다려야 한다.

#### 프론트엔드 패턴을 위한 백엔드
책임 소재가 불분명해진다는 문제가 있다. 여러 팀 사람들이 동일한 코드베이스에 소스를 커밋하고, API 게이트웨이 팀이 그 운영을 맡는 구조는 책임 소재가 불분명해지는 문제가 있다.

해결 방법은 각 클라이언트마다 API 게이트웨이를 따로 두는 BFF(Backends For Frontends) 패턴을 적용하는 것이다. 이 패턴은 SoundCloud사의 필 칼카도와 그의 동료들이 창안했다. 각 API 모듈이 하나의 클라이언트 팀이 개발/운영하는 스탠드얼론 API 게이트웨이가 되는 구조다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/39c57ccd-369b-457c-9714-dcd0c3e4a5ea)

퍼블릭 API 팀은 자기네 API 게이트웨이를 소유/운영하고, 모바일 팀도 자기네 API 게이트웨이를 소유/운영하는 식이다. 이론적으론 API 게이트웨이마다 다른 기술을 사용하여 개발할 수 있지만, 공통 기능 코드가 중복될 우려가 있어 모든 API 게이트웨이에 동일한 기술 스택을 적용하는 것이 좋다. 공통 기능은 API 게이트웨이 팀이 개발한 공유 라이브러리다.

책임을 명확히 정의하는 것 외에도 BFF 패턴은 장점이 많다.

- API 모듈이 서로 격리되어 신뢰성이 향상된다.
- 어느 한 API가 오동작하더라도 다른 API는 영향을 받지 않는다.
- API 모듈이 자체 프로세스로 작동되므로 관측성도 좋아지고, 각 API를 독립적으로 확장할 수 있다.
- API 게이트웨이를 더 작고 단순한 애플리케이션으로 만들 수 있어 시동 시간도 단축된다.

### API 게이트웨이의 장점
- 애플리케이션의 내부 구조를 캡슐화하는 것이다.
- API 게이트웨이는 클라이언트마다 최적의 API를 제공하므로 클라이언트-애플리케이션 간 왕복 횟수도 줄고 클라이언트 코드 역시 단순해진다.

### API 게이트웨이의 단점
- 개발, 배포, 관리를 해야 하는 고가용 컴포넌트가 하나 더 늘어나는 부담은 감수해야 한다.
- API 게이트웨이가 개발 병목 지점이 될 우려도 있다.

이런 단점들은 있지만, 필요 시 BFF 패턴을 이용해 팀별로 API를 독립적으로 개발/배포할 수 있으니 실제로 애플리케이션을 개발할 때는 API 게이트웨이를 사용하는 편이 합리적이다.

### API 게이트웨이 설계 이슈
다음과 같은 문제를 검토해야 한다.

- 성능과 확장성
- 리액티브 프로그래밍 추상체를 이용하여 관리 가능한 코드 작성
- 부분 실패 처리
- 애플리케이션 아키텍처에서 선량한 시민 되기