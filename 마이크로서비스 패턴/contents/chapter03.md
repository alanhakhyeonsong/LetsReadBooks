# 3장. 프로세스 간 통신
## 마이크로서비스 아키텍처 IPC 개요
서비스에 적용 가능한 IPC 기술은 선택의 폭이 넓다.
- 동기 요청/응답 기반: HTTP REST, gRPC
- 비동기 메시지 기반: AMQP, STOMP

메시지 포맷 역시
- 텍스트 포맷: JSON, XML
- 바이너리 포맷: Avro, Protocol Buffer

### 상호 작용 스타일
클라이언트/서비스 상호 작용 스타일은 두 가지 기준으로 분류할 수 있다.

첫째, 일대일/일대다 여부이다.
- 일대일: 각 클라이언트 요청은 정확히 한 서비스가 처리한다.
  - 요청/응답: 클라이언트는 서비스에 요청을 하고 응답을 기다린다. 클라이언트는 응답이 제때 도착하리라 기대하고 대기 도중 블로킹할 수 있다. 결과적으로 **서비스가 서로 강하게 결합되는 상호 작용 스타일**이다.
  - 비동기 요청/응답: 클라이언트는 서비스에 요청을 하고 서비스는 비동기적으로 응답한다. 클라이언트는 대기 중에 블로킹하지 않고, 서비스는 오랫동안 응답하지 않을 수 있다.
  - 단방향 알림: 클라이언트는 서비스에 일방적으로 요청만 하고 서비스는 응답을 보내지 않는다.
- 일대다: 각 클라이언트 요청을 여러 서비스가 협동하여 처리한다.
  - 발행/구독: 클라이언트는 알림 메시지를 발행하고, 여기에 관심 있는 0개 이상의 서비스(즉, 관심 있는 서비스가 없는 경우도 있음)가 메시지를 소비한다.
  - 발행/비동기 응답: 클라이언트는 요청 메시지를 발행하고 주어진 시간 동안 관련 서비스가 응답하길 기다린다.

둘째, 동기/비동기 여부이다.
- 동기: 클라이언트는 서비스가 제시간에 응답하리라 기대하고 대기 도중 블로킹할 수 있다.
- 비동기: 클라이언트가 블로킹하지 않는다. 응답은 즉시 전송되지 않아도 된다.

### 마이크로서비스 API 정의
어떤 IPC를 선택하든, 서비스 API를 IDL(Interface Definition Language)로 정확하게 정의해야 한다. 인터페이스 명세를 작성한 후 클라이언트 개발자와 함께 의논하는 과정을 몇 차례 되풀이하며 API를 정의한 후 서비스를 구현해야 한다. 이런 선 설계 후 구현 방식으로 진행하면 클라이언트 니즈에 좀 더 부합한 서비스를 구축할 수 있다.

## 동기 RPI 패턴 응용 통신
**RPI는 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC이다.** 메시징으로 통신하는 클라이언트와 달리 응답이 제때 도착하리라 가정한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/c6e6b8fe-1745-47f8-9a0e-204087b99547)

### 동기 RPI 패턴: REST
REST는 (거의 항상) HTTP로 소통하는 IPC이다. 현재 API 개발은 REST 스타일이 대세이다.

> 📌 REST는 컴포넌트 상호 작용의 확장성, 인터페이스 일반화, 컴포넌트 독립적 배포, 상호 작용 지연을 줄이기 위해 중간 컴포넌트, 보안 강화, 레거시 시스템의 캡슐화에 역점을 둔 아키텍처 제약 조건 세트를 제공한다. - Roy Fielding

레너드 리처드슨의 REST 성숙도 모델은 고민해 볼 필요가 있다.
- 레벨 0: 클라이언트는 서비스별로 유일한 URL 끝점에 HTTP POST 요청을 하여 서비스를 호출한다. 요청을 할 때마다 어떤 액션을 수행할지, 그 대상은 무엇인지 지정한다. 필요한 매개변수도 함께 전달한다.
- 레벨 1: 서비스는 리소스 개념을 지원한다. 클라이언트는 수행할 액션과 매개변수가 지정된 POST 요청을 한다.
- 레벨 2: 서비스는 HTTP 동사를 이용해 액션을 수행하고, 요청 쿼리 매개변수 및 본문, 필요 시 매개변수를 지정한다. 덕분에 서비스는 GET 요청을 캐싱하는 등 웹 인프라를 활용할 수 있다.
- 레벨 3: 서비스를 HATEOAS(Hypertext As The Engine Of Application State) 원칙에 기반하여 설계한다. HATEOAS는 GET 요청으로 반환된 리소스 표현형에 그 리소스에 대한 액션의 링크도 함께 태워 보내자는 생각이다. 가령 클라이언트는 GET 요청으로 주문 데이터를 조회하고 이때 반환된 표현형 내부 링크를 이용해서 해당 주문을 취소할 수도 있다. HATEOAS를 사용하면 하드 코딩한 URL을 클라이언트 코드에 욱여넣지 않아도 된다.

REST 리소스는 비즈니스 객체 중심이다. 어떻게 하면 클라이언트가 요청 한 번으로 연관된 객체를 모두 가져올 수 있을지 고민하게 된다.  
이 문제를 해결하는 한 가지 방법은 클라이언트가 리소스를 획득할 때 연관된 리소스도 함께 조회하도록 API가 허락하는 것이다. 그러나 시나리오가 복잡해지면 효율이 떨어지고 구현 시간이 많이 소요되는 문제도 있다. 이런 까닭에 **데이터를 효율적으로 조회할 수 있게 설계된 GraphQL이나 넷플릭스 팔코 등 대체 API 기술이 각광받기 시작했다.**

**비즈니스 객체에 수행할 작업을 HTTP 동사에 어떻게 매핑할지도 고민거리이다.** PUT 사용 시 필수 요건인 멱등성이 보장되지 않는 업데이트도 있다.  
한 가지 해결 방법은 리소스의 특정 부위를 업데이트하는 하위 리소스를 정의하는 것이다. 동사를 URL 쿼리 매개변수로 지정하는 방법도 있지만 REST 답지 않아 gRPC 같은 REST 대체 기술이 점점 인기를 끌고 있는 추세기도 하다.

REST의 장점은 다음과 같다.
- 단순하고 익숙하다.
- Postman 같은 브라우저 플러그인이나 curl 등의 CLI 도구를 사용해서 HTTP API를 간편하게 테스트할 수 있다.
- 요청/응답 스타일의 통신을 직접 지원한다.
- HTTP는 방화벽 친화적이다.
- 중간 브로커가 필요하지 않기 때문에 시스템 아키텍처가 단순해진다.

단점은 다음과 같다.
- 요청/응답 스타일의 통신만 지원한다.
- 가용성이 떨어진다. 중간에서 메시지를 버퍼링하는 매개자 없이 클라이언트/서비스가 직접 통신하기 때문에 교환이 일어나는 동안 양쪽 다 실행 중이어야 한다.
- 서비스 인스턴스(들)의 위치(URL)을 클라이언트가 알고 있어야 한다. 요즘 애플리케이션은 서비스 디스커버리 매커니즘을 이용해서 클라이언트가 서비스 인스턴스 위치를 찾을 수 있으므로 큰 단점은 아니다.
- 요청 한 번으로 여러 리소스를 가져오기 어렵다.
- 다중 업데이트 작업을 HTTP 동사에 매핑하기 어려울 때가 많다.

### 동기 RPI 패턴: gRPC
HTTP는 한정된 동사만 지원하기 때문에 다양한 업데이트 작업을 지원하는 REST API를 설계하기가 쉽지 않다. 그래서 등장한 기술이 gRPC이다.

**gRPC는 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크이다.** 이진 메시지 기반의 프로토콜이므로 서비스를 API 우선 방식으로 설계할 수 밖에 없다. gRPC API는 프로토콜 버퍼 기반의 IDL로 정의하며, 프로토콜 버퍼 컴파일러로 클라이언트 쪽 스텁 및 서버 쪽 스켈레톤을 생성할 수 있다. 이 컴파일러를 이용하면 Java, C#, Node.js, Go 등 다양한 언어의 코드를 생성할 수 있다. **클라이언트/서버는 프로토콜 버퍼 포맷의 이진 메시지를 HTTP/2를 통해 교환한다.**

gRPC API는 **하나 이상의 서비스와 요청/응답 메시지 데피니션으로 구성된다.** Java Interface와 비슷한 서비스 데피니션은 정적 타입 메서드를 모아 놓은 것이다. 단순 요청/응답 RPC는 물론 스트리밍 RPC도 지원하므로 서버가 클라이언트에 메시지 스트림을 응답하는 것도 가능하다. 반대로 클라이언트가 서버로 메시지 스트림을 보낼 수도 있다.

gRPC는 **프로토콜 버퍼 메시지 포맷을 사용한다.** 이는 간결하고 효율적인 이진 포맷이다. 프로토콜 버퍼 메시지는 각 필드마다 번호가 매겨지고 타입 코드가 할당된다. 메시지 수신자는 자신이 필요한 필드만 추출하고 모르는 필드는 그냥 건너뛸 수 있기 때문에 하위 호환성을 유지하며 API를 발전시킬 수 있다.

```
service OrderService {
    rpc createOrder(CreateOrderRequest) returns (CreateOrderReply) {}
    rpc createOrder(CancelOrderRequest) returns (CancelOrderReply) {}
    rpc createOrder(ReviseOrderRequest) returns (ReviseOrderReply) {}
    // ...
}

message CreateOrderRequest {
    int64 restaurantId = 1;
    int64 consumerId = 2;
    repeated LineItem lineItems = 3;
    // ...
}

message LineItem {
    string menuItemId = 1;
    int32 quantity = 2;
}

message CreateOrderReply {
    int64 orderId = 1;
}
```

gRPC는 다음과 같은 장점이 있다.
- 다양한 업데이트 작업이 포함된 API를 설계하기 쉽다.
- 특히 큰 메시지를 교환할 때 콤팩트하고 효율적인 IPC이다.
- 양방향 스트리밍 덕분에 RPI, 메시징 두 가지 통신 방식 모두 가능하다.
- 다양한 언어로 작성된 클라이언트/서버 간 연동이 가능하다.

단점은 다음과 같다.
- JavaScript 클라이언트가 하는 일이 REST/JSON 기반 API보다 더 많다.
- 구형 방화벽은 HTTP/2를 지원하지 않는다.

gRPC는 REST를 대체할 만한 유력한 방안이지만, REST 처럼 동기 통신하는 메커니즘이라 부분 실패 문제는 풀어야 할 숙제이다.

### 부분 실패 처리: Circuit Breaker(회로 차단기) 패턴
분산 시스템은 서비스가 다른 서비스를 동기 호출할 때마다 부분 실패할 가능성이 항상 존재한다. 클라이언트/서비스는 모두 개별 프로세스로 동작하기 때문에 서비스가 클라이언트 요청에 제때 응답하지 못하거나, 유지보수 또는 기술적 오류 때문에 서비스가 내려갈 수 있다. 서비스에 과부하가 걸려 응답이 매우 늦어지는 경우도 있다.

클라이언트는 응답 대기 도중 블로킹되기 때문에 서비스 실패는 클라이언트의 클라이언트로 거슬러 올라가면서 전체 시스템의 중단을 초래할 수 있다.

**Circuit Breaker 패턴은 연속 실패 횟수가 주어진 임계치를 초과하면 일정 시간 동안 호출을 즉시 거부하는 RPI 프록시다.**

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/6c6a83ac-fa21-423f-844c-e26d5d4ecf4c)

`OrderServiceProxy`를 그냥 구현하면 응답을 기다리며 무한정 블로킹할 것이다. 스레드 같은 주요 리소스가 고갈되어 결국 API Gateway가 요청을 처리할 수 없게 된다. 그 결과 전체 API는 사용 불능 상태가 될 것이다. 따라서 부분 실패가 애플리케이션 전체에 전파되지 않도록 서비스를 설계해야 한다. 솔루션은 두 부분으로 나뉜다.
- 무응답 원격 서비스를 처리하기 위해 `OrderServiceProxy` 같은 견고한 RPI 프록시를 설계한다.
- 원격 서비스가 실패하면 어떻게 조치해야 할지 결정한다.

넷플릭스 기술 블로그를 보면 서비스가 다른 서비스를 동기 호출할 때 자기 스스로를 방어하는 방법이 명쾌하게 기술되어 있다.
- 네트워크 타임아웃: 응답 대기 중에 무한정 블로킹하면 안 되고 항상 타임아웃을 걸어 둔다. 이렇게 해야 리소스가 마냥 붙잡히지 않는다.
- 미처리 요청 개수 제한: 클라이언트가 특정 서비스에 요청 가능한 미처리 요청의 최대 개수를 설정한다. 이 개수에 이르면 더 이상의 요청은 무의미하므로 즉시 실패 처리하는 것이 타당하다.
- 회로 차단기 패턴: 성공/실패 요청 개수를 지켜보다 에러율이 주어진 임계치를 초과하면 그 이후 시도는 바로 실패 처리한다. 실패된 요청이 많다는 것은 서비스가 불능 상태고 더 이상의 요청은 무의미하단 뜻이다. 타임아웃 시간 이후 클라이언트가 재시도해서 성공하면 회로 차단기는 닫힌다.

Netflix Hystrix는 이와 같이 다양한 패턴이 구현된 오픈 소스 라이브러리다.

히스트릭스 같은 라이브러리는 부분적인 솔루션에 불과하다. **무응답 원격 서비스를 어떻게 복구하면 좋을지는 그때그대 상황에 맞게 판단해야 한다.** 그냥 알기 쉽게 서비스가 클라이언트에 에러를 반환하는 것이 나을 때가 있다. 부분 실패 시 미리 정해진 기본값이나 캐시된 응답 등 대체 값을 반환하는 방법도 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/5385fd42-6471-4407-b223-85626685865a)

모든 서비스의 데이터가 클라이언트에 똑같이 중요하진 않다. 위 그림에선 주문 서비스 데이터가 가장 중요하다. 서비스가 불능 상태가 되어도 다른 서비스 데이터는 상대적으로 덜 중요하기 때문에 API Gateway는 캐시된 버전의 데이터 또는 에러를 반환한다.

부분 실패를 처리하도록 서비스를 설계하는 것 외에도 RPI 사용 시 해결해야 할 이슈는 많다. **어떤 서비스가 다른 서비스를 RPI로 호출할 때 해당 서비스 인스턴스의 네트워크 위치를 알고 있어야 하는 것도 문제다.** 별거 아닌 것 같지만 실제로는 꽤 골치 아픈 문제다.