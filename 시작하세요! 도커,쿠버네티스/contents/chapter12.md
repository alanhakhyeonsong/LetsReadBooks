# 12장. 커스텀 리소스와 컨트롤러
쿠버네티스에선 포드와 같이 기본적인 리소스 외에도 우리가 직접 리소스의 종류를 정의해 사용할 수도 있는데, 이를 커스텀 리소스라고 부른다.

커스텀 리소스를 제대로 사용하려면 컨트롤러라는 별도의 컴포넌트를 이해하고 구현할 수 있어야 한다. 쿠버네티스의 컨트롤러는 클라우드 네이티브 인프라스트럭처 생태계에서 자주 쓰이는 개념을 내포하고 있기 때문에 쿠버네티스를 깊게 이해하려면 컨트롤러에 관련된 개념을 이해하고 넘어가는 것이 좋다.

## 쿠버네티스 컨트롤러의 개념과 동작 방식
### 명령형(Imperative) vs 선언적(Declarative)
쿠버네티스와 도커에서 어떤 리소스를 생성하는 방법은 꽤 다르다. 도커에선 컨테이너를 생성할 때 단순히 `docker run` 명령어를 사용해 컨테이너를 생성했지만, 쿠버네티스에선 `kubectl apply -f` 명령어로 디플로이먼트를 생성하면 레플리카셋이 포드를 생성하곤 했다.

`docker run` 처럼 특정 명령을 처리하는 주체와 통신해 그 작업을 수행하고 그 결괏값을 돌려받는 방식을 쿠버네티스에선 **명령형**이라고 한다. 쿠버네티스에서도 가끔 포드를 생성할 때 `kubectl run` 명령어를 사용하곤 했는데, 이 또한 명령형 방식에 속한다.

**쿠버네티스에선 이와 반대되는 선언형 방식을 지향한다.**  
**선언형 방식은 최종적으로 도달해야 하는 바람직한 상태(Desired State)를 우리가 정의한 뒤, 현재 상태(Current State)가 바람직한 상태와 다를 경우 이를 일치하도록 만드는 방법이다.** `kubectl apply` 명령어가 바로 대표적인 예시다.

`kubectl apply -f` 뒤에 오는 YAML 파일은 '최종적으로 도달해야 하는 상태'를 의미하며, 쿠버네티스는 현재 상태가 해당 YAML 파일과 일치하도록 특정 동작을 수행한다. 이 명령어는 특정 YAML 파일이 최종적으로 완성돼야 하는 상태라는 것을 쿠버네티스에게 알려줄 뿐, 실제로 어떠한 동작을 취해야 하는지는 명시하지 않는다. **최종적으로 완성돼야 하는 상태가 되기 위해 어떠한 동작을 취할지는 쿠버네티스에서 컨트롤러라고 불리는 개체가 내부적으로 결정한다.**

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/be9a8aa5-465c-48ad-b60a-d79db54accb2)

쿠버네티스의 대부분의 상태는 etcd와 같은 분산 코디네이터에 저장돼있다. 따라서 우리가 정의하는 바람직한 상태 또한 etcd에 저장돼 있으며, 컨트롤러는 쿠버네티스 API 서버의 Watch API를 통해 ectd에 저장된 상태 데이터를 받아와 동작을 수행한다.

이러한 이유로 쿠버네티스에선 유독 '바람직한 상태'라는 단어가 자주 등장한다. 디플로이먼트를 생성한 뒤 레플리카셋의 상태를 확인해 보면 `Desired`라는 항목이 존재한다. 레플리카셋의 입장에서 바람직한 상태는 '특정 개수의 포드가 생성되어 실행 중인 상태'다. 만약 의도적으로 포드 중 하나를 삭제하면 레플리카셋은 바람직한 상태를 유지하기 위해 새로운 포드를 생성할 것이다. 레플리카셋이 라벨 셀렉터가 일치하는 포드를 생성할 때에도 선언형 방식의 일종을 사용하고 있는 셈이다.

대부분의 쿠버네티스 오브젝트는 이러한 원리에 따라 제어된다. 이론적으로 쿠버네티스의 컨트롤러는 모두 개별적으로 존재할 수도 있으나, 쿠버네티스는 전체 구성의 복잡성을 줄이기 위해 컨트롤러 로직을 **쿠버네티스 컨트롤러 매니저**라는 하나의 컴포넌트에서 구현해 놓았다. 컨트롤러 매니저 또한 쿠버네티스의 핵심 컴포넌트이기 때문에 `kube-system` 네임스페이스에서 포드로 실행되고 있다.

컨트롤러 매니저에는 디플로이먼트 컨트롤러, 노드 컨트롤러 등 다양한 컨트롤러가 동시에 실해된다. 이러한 컨트롤러들은 쿠버네티스 리소스의 상태 변화를 감지하고 적절한 작업을 수행하도록 구현돼 있다.

해당 목록을 확인하고 싶다면, 다음과 같이 목록을 출력해보자.

```bash
kubectl get pods -n kube-system
```

## 커스텀 리소스에 대한 개념
**커스텀 리소스는 말 그대로 우리가 직접 정의해 사용할 수 있는 사용자 정의 리소스다.** 커스텀 리소스 또한 포드, 디플로이먼트, 서비스 등과 동일한 리소스의 한 종류로 간주된다.

커스텀 리소스를 사용하는 방법에는 여러 가지가 있다. 디플로이먼트, 서비스 등의 오브젝트의 묶음을 커스텀 리소스로 추상화함으로써 쿠버네티스 리소스를 묶어 놓은 패키지처럼 사용할 수도 있고, 쿠버네티스와 전혀 상관이 없는 로직을 커스텀 리소스와 연동할 수도 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/8a625bc3-add2-4351-babf-39ca0b4044c4)

예를 들어, 위 그림처럼 웹 애플리케이션을 WebApp이라는 이름의 커스텀 리소스로 만들었다면 이 커스텀 리소스에는 프론트엔드 서버, 백엔드 서버, 데이터베이스 디플로이먼트, 그리고 각 포드가 서로 통신하기 위한 여러 서비스 리소스가 포함될 수 있다. 이때 WebApp 커스텀 리소스를 하나 생성하는 것만으로도 이러한 리소스를 한꺼번에 생성할 수 있고, 각 리소스의 생애 주기를 쉽게 관리할 수 있다. **커스텀 리소스를 사용함으로써 복잡하고 많은 리소스에 대한 관리의 복잡성을 줄일 수 있으며, 쿠버네티스 오브젝트를 원하는 대로 확장해 사용할 수 있다.**

### 커스텀 리소스를 사용하기 위한 단계
1. 현재 상태를 커스텀 리소스에 대한 바람직한 상태로 변화시킬 수 있는 컨트롤러를 구현하고, 컨트롤러를 실행한다.
2. 커스텀 리소스의 상세 정보를 정의하는 CRD(Custom Resource Definition) 리소스를 생성한다.
3. CRD에 정의된 데이터에 맞춰 커스텀 리소스를 생성한다.
4. 1번에서 실행한 컨트롤러는 커스텀 리소스의 생성을 감지하고, 커스텀 리소스가 원하는 바람직한 상태가 되도록 적절한 작업을 수행한다.

## 커스텀 리소스를 정의하기 위한 CRD(Custom Resource Definition)
**쿠버네티스에서 커스텀 리소스는 `customresourcedefinition`이라는 오브젝트를 통해 정의할 수 있다.** `crd`라는 이름으로 줄여서 부르는 것이 일반적이며, `kubectl get crd`를 통해 그 목록을 확인할 수 있다.

CRD는 '커스텀 리소스를 정의'하는 리소스다. 즉, 커스텀 리소스를 어떻게 사용할 것인지 쿠버네티스에 등록하는 선언적인 리소스일 뿐, CRD 자체가 커스텀 리소스를 의미하는 것이 아니다. CRD를 생성한 다음 해당 CRD의 규격에 맞는 커스텀 리소스를 생성해야만 비로소 의미를 갖는다.

CRD 또한 쿠버네티스 오브젝트이기 때문에, YAML 파일에 정의해 생성할 수 있다. 간단한 예시를 살펴보자.

```yaml
# my-crd-example.yaml
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: alices.k106.com  # CRD의 이름
spec:
  group: k106.com        # 커스텀 리소스의 API 그룹
  version: v1alpha1      # 커스텀 리소스의 API 버전
  scope: Namespaced      # 커스텀 리소스가 네임스페이스에 속하는지 여부
  names:
    plural: alices       # 커스텀 리소스의 이름(복수형)
    singular: alice      # 커스텀 리소스의 이름(단수형)
    kind: Alice          # YAML 파일 등에서 사용될 커스텀 리소스의 Kind
    shortNames: ["ac"]   # 커스텀 리소스의 줄임말
  validation:
    openAPIV3Schema:     # 커스텀 리소스의 데이터를 정의
      required: ["spec"] # 커스텀 리소스에는 반드시 "spec"이 존재해야 함
      properties:        # 커스텀 리소스에 저장될 데이터 형식을 정의
        spec:
          required: ["myvalue"]
          properties:
            myvalue:
              type: "string"
              minimum: 1
```

- CRD의 이름은 반드시 `spec.names.plural + "." + spec.group` 형태여야 한다.
- 일반적으로 리소스의 버전은 `API그룹/버전` 형태로 사용돼야 한다.
- `spec.validation` 항목에선 실제로 커스텀 리소스에 어떠한 데이터가 저장돼야 하며, 어떠한 항목이 반드시 설정돼야 하는지 정의한다.

```yaml
# my-cr-example.yaml
apiVersion: k106.com/v1alpha1
kind: Alice
metadata:
  name: my-custom-resource
spec:
  myvalue: "This is my value"
```

```bash
kubectl apply -f my-crd-example.yaml

kubectl apply -f my-cr-example.yaml
kubectl describe ac my-custom-resource
```

## 커스텀 리소스와 컨트롤러
**커스텀 리소스 그 자체는 `etcd`에 저장된 단순한 데이터일 뿐, 실제로 동작하고 있는 포드나 서비스는 아니다.** 커스텀 리소스를 생성했을 때 특정 동작을 수행하도록 정의하는 컨트롤러를 별도로 구현해야만 커스텀 리소스가 비로소 의미를 갖게 된다.

예를 들어, 레플리카 셋의 목적은 '라벨 셀렉터가 일치하는 일정 개수의 포드를 생성하는 것'이었고, 이를 위한 동작은 컨트롤러 매니저라는 컴포넌트 내부에서 수행된다. 이처럼 커스텀 리소스가 어떠한 목적을 위해 생성되는지 비즈니스 로직으로 구현해 놓은 별도의 컨트롤러가 필요하다. 이 비즈니스 로직은 커스텀 리소스가 원하는 바람직한 상태를 계속해서 유지하도록 만드는 소스코드로 구현되어야 한다.

커스텀 리소스를 위한 컨트롤러가 어떻게 동작하는지 간단하게 나타내보면 다음과 같다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/6dbef565-c159-4f42-bea6-02aabdf747ef)

직접 구현한 컨트롤러는 API 서버의 Watch를 통해 새로운 커스텀 리소스가 생성됐다는 것을 감지하고, 커스텀 리소스가 원하는 바람직한 상태가 되도록 특정 동작을 수행한다. 바람직한 상태는 우리가 커스텀 리소스의 역할을 어떻게 정의하느냐에 달려있다.

- alice와 bob이라는 두 개의 포드가 존재하는 것일 수도
- 웹 서버 구축을 위한 여러 개의 서버 포드와 서비스가 존재하는 것일 수도
- AWS에서 EC2 인스턴스를 새롭게 하나 생성하는 것일 수도

현재 상태가 바람직한 상태가 되도록 특정 동작을 수행하는 것을 쿠버네티스에서는 Reconcile이라 부른다. 레플리카셋으로부터 생성된 포드를 일부러 하나 삭제하면 즉시 그 자리에 새로운 포드를 새롭게 생성해 바람직한 상태를 유지하는 것도 이것의 일종으로 볼 수 있다.

그리고 이러한 일련의 동작을 통해 CRD를 사용할 수 있도록 컨트롤러를 구현하는 방법을 오퍼레이터 패턴이라 하며, 쿠버네티스의 기능을 확장할 때 매우 중요하게 여겨지는 원리 중 하나다.

이번 장의 내용은 쿠버네티스 공식 문서에서 더 자세히 살펴보도록 하자.