# 3장. 네트워크 통신하기

## 4. TCP와 UDP

OSI 7계층 중 4계층에서 동작하는 프로토콜의 목적은 **목적지 단말 안에서 동작하는 여러 애플리케이션 프로세스 중 통신해야 할 목적지 프로세스를 정확히 찾아가고 패킷 순서가 바뀌지 않도록 잘 조합해 원래 데이터를 잘 만들어내는 것이다.**

### 4계층 프로토콜(TCP, UDP)과 서비스 포트

데이터를 보내고 받는 인캡슐레이션, 디캡슐레이션 과정에 각 계층에서 정의하는 헤더가 추가되고 여러가지 정보가 들어간다. 다양한 정보 중 가장 중요한 두 가지 정보는 다음과 같다.

- 각 계층에서 정의하는 정보  
  → 수신 측의 동일 계층에서 사용하기 위한 정보이다. 송신 측에서 추가한 2계층 헤더의 MAC 주소 정보는 수신 측의 2계층에서 확인하고 사용된다. 마찬가지로 송신 측에서 추가한 3계층 IP 주소는 수신 측 3계층에서 사용한다. 4계층의 정보는 시퀀스 번호, ACK 번호가 있다.
- 상위 프로토콜 지시자 정보  
  → 디캡슐레이션 과정에서 상위 계층으 프로토콜이나 프로세스를 정확히 찾아가기 위한 목적으로 사용된다.  
  2계층: 이더 타입  
  3계층: 프로토콜 번호  
  4계층: 포트 번호

TCP/IP 프로토콜 스택에서 4계층은 TCP와 UDP가 담당하는데, 4계층의 목적은 **목적지를 찾아가는 주소가 아니라 애플리케이션에서 사용하는 프로세스를 정확히 찾아가고 데이터를 분할한 패킷을 잘 쪼개 보내고 잘 조립하는 것**이다.  
패킷을 분할하고 조립하기 위해 TCP 프로토콜에서는 **시퀀스 번호와 ACK 번호를 사용한다.**

![](https://images.velog.io/images/songs4805/post/8a6c77b5-14d5-4cd6-8eca-b9fb5148fd75/D9C3D0FA-C28A-4CFD-836D-4B34A2AD0880_1_102_a.jpeg)

> 📌 Well Known Port
>
> HTTP TCP 80, HTTPS TCP 443, SMTP TCP 25와 같이 잘 알려진 포트를 Well Known 포트 라고 한다. 이러한 포트는 인터넷 주소 할당기구인 IANA(Internet Assigned Numbers Authority)에 등록되고 1023번 이하의 포트번호를 사용한다.

### TCP

TCP는 4계층의 특징을 대부분 포함하고 있다.

- 신뢰할 수 있다.  
  → 신뢰할 수 없는 공용망에서도 정보유실 없는 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할하고 분할된 패킷이 잘 전송되었는지 확인하는 기능이 있다.
- 패킷에 번호(Sequence Number)를 부여해서 전송 상태를 확인한다.
- 잘 전송되었는지에 대한 응답(Acknowledge Number) 한다.
- 한 번에 얼마나 보내야 수신자가 잘 처리할 수 있는지 전송 크기(Window Size)까지 고려해 통신한다.
- 네트워크 상태를 크게 고려하지 않고 특별한 개발 없이도 쉽고 안전하게 네트워크를 사용할 수 있다.

#### 패킷 순서, 응답 번호

![](https://images.velog.io/images/songs4805/post/1bff0e8a-bd88-42bb-a904-2c7bafc2b5d4/image.png)

- 분할된 패킷을 잘 분할하고 수신 측이 잘 조합하도록 패킷에 순서를 주고 응답 번호를 부여한다.
- **시퀀스 번호**: 패킷에 순서를 부여하는 것
- **ACK 번호**: 응답 번호를 부여하는 것
- 두 번호(시퀀스, ACK)를 이용해 패킷의 순서가 바뀌거나 중간에 패킷이 손실된 것을 파악할 수 있다.
- 보내는 쪽에서 패킷에 번호를 부여하면 받는 쪽은 이 번호의 순서가 맞는지 확인한다. (이 숫자를 ACK 번호라 함)
- 송신 측에서 ACK 번호를 수신받으면 확인 후 다음 패킷에 번호를 부여해 송신한다.

![](https://images.velog.io/images/songs4805/post/0abca77c-7927-4551-aee4-0bda8ceace45/image.png)

1. 출발지에서 시퀀스 번호를 0으로 보낸다.(SEQ = 0)
2. 수신 측에서는 0번 패킷을 잘 받았다는 표시로 응답 번호(ACK)에 1을 적어 응답한다. 이때 수신 측에서는 자신이 처음 보내는 패킷이므로 자신의 패킷에 시퀀스 번호 0을 부여한다.
3. 이 패킷을 받은 송신 측은 시퀀스 번호를 1로(수신 측이 ACK 번호로 1번 패킷을 달라고 요청했으므로), ACK 번호는 상대방의 0번 시퀀스를 잘 받았다는 의미로 시퀀스 번호를 1로 부여해 다시 전송한다.

#### 윈도 사이즈와 슬라이딩 윈도

- 윈도 사이즈: 한 번에 받을 수 있는 데이터의 크기
- 슬라이딩 윈도: 네트워크 상황에 따라 윈도 사이즈를 조절하는 것

TCP는 상대방이 얼마나 잘 받았는지 확인하기 위해 ACK 번호를 확인하고 다음 패킷을 전송한다. 패킷이 잘 전송되었는지 확인하기 위해 별도 패킷을 받는 것 자체가 통신 시간을 늘리지만, 송/수신자간 거리가 멀수록 왕복 지연시간(RTT)이 늘어나므로 응답을 기다리는 시간이 더 길어진다.

그래서 데이터를 보낼 때 패킷을 하나만 보내는 것이 아니라 많은 패킷을 한꺼번에 보내고 응답을 하나만 받는다. 최대한 많은 패킷을 한꺼번에 보내는 것이 효율적이지만, 네트워크 상태가 안좋으면 패킷 유실 가능성이 커지므로 적절한 송신량을 결정해야 한다. 한 번에 데이터를 받을 수 있는 데이터 크기를 **윈도 사이즈**라 하고 네트워크 상황에 따라 이를 조절하는 것을 **슬라이딩 윈도**라 한다.

### 3방향 핸드셰이크

TCP는 유실없는 안전한 통신을 위해 통신 시작 전, 사전 연결작업을 진행한다. 목적지가 데이터를 받을 준비가 안 된 상황에서 데이터를 일방적으로 전송하면 목적지에서는 데이터를 정상적으로 처리할 수 없어 데이터가 버려진다.

TCP 프로토콜은 이런 상황을 만들지 않기 위해 3번의 패킷을 주고받으면서 통신을 서로 준비하므로 '3방향 핸드셰이크'라 부른다.

![](https://images.velog.io/images/songs4805/post/0f659b5b-75e3-4f97-bf03-201101bdd18f/image.png)

3방향 핸드셰이크 과정이 생기다보니 기존 통신과 새로운 통신을 구분해야한다. 이를 구분하기 위해 헤더에 플래그(Flag)라는 값을 넣어 통신한다.

![](https://images.velog.io/images/songs4805/post/e7bafbe1-3217-4034-abf1-cf11dbb3f8a2/image.png)

TCP 플래그는 총 6가지가 있고 통신의 성질을 나타낸다. 초기 연결, 응답, 정상 종료, 비정상 종료 등의 용도로 사용된다.

- SYN: 연결 시작 용도로 사용. 연결이 시작될 때 이 플래그에 1로 표시해 보낸다.
- ACK: ACK 번호가 유효할 경우 1로 표시해 보낸다. 초기 SYN이 아닌 모든 패킷은 기존 메시지에 대한 응답이므로 ACK 플래그가 1로 표기된다.
- FIN: 연결 종료 시 1로 표시된다. 데이터 전송을 마친 후 정상적으로 양방향 종료 시 사용된다.
- RST: 연결 종료 시 1로 표시된다. 연결 강제 종료를 위해 일방적으로 끊을 때 사용된다.
- URG: 긴급 데이터인 경우, 1로 표시해 보낸다.
- PSH: 서버 측에서 전송할 데이터가 없거나 데이터를 버퍼링 없이 응용 프로그램으로 즉시 전달할 것을 지시할 때 사용.

![](https://images.velog.io/images/songs4805/post/c5ff9766-9d40-40ff-87f2-c23a3582b595/image.png)

3방향 핸드셰이크 과정은 위와 같다.

1. 통신 최초 시도시 송신자는 플래그에 있는 SYN 필드를 1로 표기하고 시퀀스 번호를 적어 보낸다.
2. SYN 패킷을 받은 수신자는 SYN, ACK 비트를 플래그에 1로 표기해 응답한다. 수신자가 보내는 첫 패킷이므로 SYN은 1이고 기존 송신자의 응답이기도 하므로 ACK 비트도 함께 1로 표기한다. 이 때 ACK 번호는 송신자가 보낸 시퀀스 번호에 1을 추가한 값을 넣어 응답한다. (시퀀스 번호로 10을 받았으니 ACK 번호는 11을 보내면 됨)
3. 수신자의 응답(SYN, ACK)을 받은 송신자는 연결을 확립하기 위해 다시 응답을 보낸다. 이때는 기존 메시지의 응답이기에 ACK 필드만 1로 표기된다. 수신자가 시퀀스 번호를 20으로 보냈기 때문에 송신자의 ACK 번호는 20+1인 21이 된다.

### UDP

UDP는 TCP와는 다르게 4계층 프로토콜이 가져야 할 특징이 거의 없다.

**TCP 헤더에 있던 내용들(시퀀스 번호, ACK 번호, 플래그, 윈도 사이즈 등)이 모두 존재하지 않는다.**  
데이터 통신은 데이터 전송의 신뢰성이 핵심이다. 애플리케이션에서 걱정하지 않고 데이터를 만들고 사용하게 하는 것이 데이터 통신의 목적이지만, **UDP는 데이터 전송을 보장하지 않는 프로토콜이므로 제한된 용도로만 사용된다.**

- 음성 데이터나 실시간 스트리밍  
  : 실시간성이 보장되야하는 시간에 민감한 프로토콜이나 애플리케이션을 사용하는 경우 UDP 프로토콜이 사용됨
- 단방향으로 다수의 단말과 통신하며 응답을 받기 어려운 환경  
  : 사내 방송, 증권 시세 데이터 전송 등

즉, 신뢰성보다는 일부 데이터가 유실되더라도 시간에 맞추어 계속 전송하는 것이 중요한 시스템에서 UDP를 사용한다. UDP는 중간에 데이터가 일부 유실되더라도 그냥 유실된 상태로 데이터를 처리해버린다.

또한 다음과 같은 특징이 있다.

- UDP는 TCP와 다르게 3방향 핸드셰이크처럼 사전에 연결을 확립하는 과정이 없다. 대신 UDP의 첫 데이터는 리소스 확보를 위해 인터럽트(interrupt)를 거는 용도로 사용되고 유실된다.
- UDP 프로토콜을 사용하는 앱 대부분은 이런 상황을 인지하고 동작한다.
- 연결 확립은 TCP 프로토콜을 이용하고 앱끼리 모든 준비를 마친 후 실제 데이터만 UDP를 이용하는 경우가 대부분이다.

📌 TCP와 UDP 특징 비교

| TCP                            | UDP                                  |
| ------------------------------ | ------------------------------------ |
| 연결 지향(Connection Oriented) | 비연결형(Connectionless)             |
| 오류 제어 수행함               | 오류 제어 수행 안 함                 |
| 흐름 제어 수행함               | 흐름 제어 수행 안 함                 |
| 유니캐스트                     | 유니캐스트, 멀티캐스트, 브로드캐스트 |
| 전이중(Full Duplex)            | 반이중(Half Duplex)                  |
| 데이터 전송                    | 실시간 트래픽 전송                   |

## 5. ARP

OSI 7계층 중 2, 3계층이 주소를 가지고 있고 통신할 때 목적지를 찾아갈 수 있도록 하지만, 사실 두 계층의 주소간에는 아무 관계가 없다.

2계층 MAC 주소는 하드웨어 생산업체가 임의적으로 할당한 주소이고 NIC에 종속된 주소이다.  
3계층 IP 주소는 우리가 직접 할당하거나 DHCP를 이용해 자동으로 할당받는다.

실제로 통신은 IP 주소 기반으로 일어나고 MAC 주소는 상대방의 주소를 자동으로 알아내 통신하게 된다.  
이때, **상대방의 MAC 주소를 알아내기 위해 사용되는 프로토콜이 ARP(Address Resolution Protocol)** 이다.

![](https://images.velog.io/images/songs4805/post/804d8016-3f21-4979-9c37-8a6830175f31/image.png)

TCP-이더넷 프로토콜과 같이 3계층 논리적 주소와 2계층 물리적 주소 사이에 관계가 없는 프로토콜에서 ARP 프로토콜과 같은 메커니즘을 사용해 물리적 주소와 논리적 주소를 연결한다.

호스트에서 아무 통신이 없다가 처음 통신을 시도하면 패킷을 바로 캡슐화 할 수 없다. 통신을 시도할 때 출발지와 목적지 IP는 미리 알고 있어 문제가 없지만, 상대방의 MAC 주소를 알 수 없어 2계층 캡슐화를 수행할 수 없다. 상대방의 MAC 주소를 알아내려면 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방의 MAC 주소를 질의해야 한다.

ARP 브로드캐스트를 받은 목적지는 ARP 프로토콜로 자신의 MAC 주소를 응답하는데, 이 작업이 완료되면 이제 부족했던 정보인 목적지의 MAC 주소도 알아냈기에 패킷은 정상적으로 인캡슐레이션되어 상대방에게 전달 될 수 있다.

### 목적지 MAC 주소를 매번 ARP 브로드캐스트를 통해 알아내야 하는 것은 아니다

ARP 브로드캐스트를 매번 수행하면 네트워크 통신의 효율성이 크게 저하되므로 메모리에 이 정보를 저장해두고 재사용한다.

IP 주소와 MAC 주소를 1:1로 대응하여 테이블로 저장해두는데 이를 **ARP Table**이라 한다.

- 성능을 위해서는 ARP 테이블이 한 번 생성되면 오래 유지될수록 좋다.
- 논리 주소는 언제든지 바뀔 수 있기 때문에 일정 시간 이상 통신이 없으면 이 테이블은 삭제된다.
- 네트워크 장비에서 ARP 작업은 CPU에서 직접 수행하기 때문에 짧은 시간에 많은 ARP요청이 들어오면 네트워크 장비에는 큰 부하가 걸린다.
- 이 외에도 DNS 캐시나 라우팅 캐시와 같이 다양한 계층에서 네트워크의 성능을 높이기 위한 캐시 테이블을 가지고 있다.

### ARP 동작

ARP 프로토콜 필드 중 다음 4가지 필드가 중요하다.

- 송신자 하드웨어 MAC 주소
- 송신자 IP 프로토콜 주소
- 대상자 MAC 주소
- 대상자 IP 프로토콜 주소

#### 1. 서버 A → 서버 B로 최초 통신 시도

![](https://images.velog.io/images/songs4805/post/1aa2af92-d149-463f-aed5-d4f7ec3c07ed/image.png)

- 목적지 MAC 주소를 모르기에 패킷을 완성할 수 없음
- 서버 A는 서버 B의 MAC 주소를 알아내기 위해 ARP 요청을 브로드캐스트 해야 함.

#### 2. 서버 A → 서버 B로 ARP 브로드캐스트

![](https://images.velog.io/images/songs4805/post/0f9c9a37-a5d6-493c-b256-a4d59f96c55d/image.png)

- 2계층 MAC 주소는 출발지를 자신의 MAC으로, 도착지는 브로드캐스트(FF-FF-FF-FF-FF-FF)
- ARP 프로토콜 필드의 전송자 MAC과 IP 주소에는 자신의 주소로 채운다.
- 대상자 IP 주소는 1.1.1.2로 대상자 MAC 주소는 00-00-00-00-00-00으로 채워보낸다.

#### 3. 브로드캐스트를 받은 서버에서는 IP 비교 후 자신의 MAC 주소 반환

![](https://images.velog.io/images/songs4805/post/2e52eb90-dfff-4163-ad5a-eff66f6f2356/image.png)

- 이전 단계에서 브로드캐스트로 전송했기에 ARP 패킷은 같은 네트워크 내의 모든 단말에 보내졌다. 모든 단말은 각자 ARP 프로토콜을 확인한 뒤 대상자 IP가 자신의 IP와 비교해서 일치하지 않으면 폐기한다. 만약 일치한다면 받은 ARP 프로토콜 필드를 통해 목적지 정보(IP, MAC)도 알 수 있기 때문에 이를 이용해 ARP 프로토콜을 보내는데 모든 값이 채워져 있으므로 유니캐스트로 전송된다.

#### 4. ARP 캐시 테이블 갱신 및 서버 A → 서버 B 패킷 송신

![](https://images.velog.io/images/songs4805/post/bcc3a762-a789-4a29-9f13-78a152399f06/image.png)

- 서버 A는 서버 B로부터 ARP 응답을 받아 자신의 ARP 캐시 테이블을 갱신한다.
- 이 ARP 캐시 테이블은 정해진 시간동안 서버 B와 통신이 없을때까지 유지되며 시간 내에 통신이 다시 이뤄지면 시간은 다시 초기화된다.
- ARP 캐시 테이블 갱신 후에는 상대방의 MAC 주소를 알고 있으므로 도착지 MAC 주소 필드도 완성해서 인캡슐레이션해서 정상적으로 패킷을 보낼 수 있다.

## 6. 서브넷과 게이트웨이

**원격지 네트워크와의 통신에서 네트워크를 넘어 전달되지 못하는 브로드캐스트의 성질때문에 사용되는 장비를 게이트웨이(Gateway)라 부른다.**

![](https://images.velog.io/images/songs4805/post/2637f3ef-ab25-4595-b528-ae5f63d119c1/image.png)

- 기본 게이트웨이는 3계층 장비가 수행하며 여러 네트워크와 연결되어 적절한 경로를 지정해주는 역할을 한다.
- 출발지와 목적지 네트워크가 동일한 LAN 내에서 통신하는 것인지 다른 네트워크 간의 통신인지에 따라 통신 방식이 달라지기에 먼저 목적지의 범위를 **서브넷 마스크**를 이용해 확인한다.
- 원격지 통신은 ARP가 라우터를 넘어가지 못하는 브로드캐스트이기에 게이트웨이라는 장비를 사용해야 한다.

### 2계층 통신 vs 3계층 통신

![](https://images.velog.io/images/songs4805/post/9b8bd264-95f7-4a63-8603-bdcb4f4e7454/image.png)

- **3계층 통신**: 원격지 네트워크 통신  
  원격지 네트워크와 통신해야 할 경우 라우터와 같은 3계층 장비의 도움이 필요하기 때문에 해당 패킷을 전송하는 네트워크 장비에서 3계층 정보까지 확인해야 하며 이를 L3 통신이라 한다. 도착지 MAC 주소와 IP 주소가 다르다. 도착지 IP 주소는 실제 도착지이고 도착지 MAC 주소는 디폴트 게이트웨이의 MAC 주소가 사용된다.
- **2계층 통신**: 로컬 네트워크 통신  
  로컬 네트워크에서 직접 통신할 경우 라우터와 같은 3계층 장비 없이도 통신이 가능하다. 그래서 2계층까지만 정보를 확인 후 ARP 요청을 보낼 때 직접 브로드캐스트를 이용하기에 L2 통신이라 한다.
