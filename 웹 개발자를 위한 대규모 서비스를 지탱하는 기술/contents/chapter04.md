# Chapter 4 - 분산을 고려한 MySQL 운용
## 인덱스를 올바르게 운용하기
분산을 고려한 MySQL 운용의 세 가지 포인트는 다음과 같다.
- OS 캐시 활용
  - 전체 데이터 크기에 주의해서 데이터량이 물리 메모리보다 가능한 한 적어지도록 유지한다.
  - 메모리가 부족할 경우에는 증설
  - 스키마 설계가 데이터 크기에 미치는 영향을 고려한다.
    - 대량의 데이터를 저장하려는 테이블은 레코드가 가능한 한 작아지도록 컴팩트하게 설계하도록 하자.
- 인덱스를 적절하게 설정하기
- 확장을 전제로 한 설계

### 인덱스의 중요성
MySQL의 인덱스는 기본적으로 B+트리라는 데이터 구조다. 각 노드 내에 자식 노드로의 포인터만 가지고 있고 포인터 이외에 데이터로서의 실제 값 등은 제일 마지막인 leaf 노드에만 가지고 있는 구조다. DB에 데이터를 저장하는 데 좀 더 최적화된 데이터 구조다.

- 외부기억장치 탐색 시에 Seek 횟수를 최소화하는 트리구조
- 색인의 계산량: O(n) → O(log n)

### 인덱스의 효과
대규모가 되면 될수록 인덱스 유무의 차이가 크지만, 데이터 건수가 1000건 정도라면 오히려 트리를 먼저 순회하는 오버헤드가 더 커서 선형탐색이 더 빠른 경우도 많다.

- ex) 4000만 건 태그 테이블 탐색
  - 인덱스 없음: 선형 탐색
    - O(n): 최대 4000만 번 탐색
  - 인덱스 있음: B트리 이분탐색
    - O(log n): 최대 25.25번 탐색

기본적으로 인덱스가 사용되는 것은 `where`, `order by`, `group by` 조건에 지정된 컬럼이다. 인덱스로서 작용하는 것은 명시적으로 추가한 인덱스나 PK, unique key 제약을 건 칼럼에 해당한다. 복수 컬럼에 동시에 인덱스를 태우고자 할 경우엔 복합 인덱스를 사용해야만 한다.

쿼리 속도에 신경 쓰고자 할 때는 `explain` 명령으로 SQL에 제대로 인덱스가 작용하는지 여부를 확인하면서 개발하자.
- `Extra` 열 확인
  - `Using filesort`, `Using temporary`가 나오는 것은 그다지 틀이 좋은 쿼리는 아니다.

## MySQL의 분산
MySQL엔 기본 기능으로 replication 기능이 있다. 마스터를 정하고 이를 뒤따르는 슬레이브를 정해두면 마스터에 쓴 내용을 슬레이브가 폴링해서 동일한 내용으로 자신을 갱신하는 기능이다. 슬레이브는 마스터의 레플리카가 되는 것이다. 이런 식으로 동일한 내용의 서버를 여러 대 마련할 수 있다.

Read는 슬레이브로, Write는 마스터로 던지도록 로드밸런서를 구성하곤 한다.

### 마스터/슬레이브의 특징
- Read 쿼리는 확장
  - 서버를 늘리기만 하면 된다.
  - 대수를 늘리기보다도 메모리에 맞추는 것이 중요함.
- 마스터는 확장하지 않는다.
  - Write 쿼리가 늘어나면 험난해진다.
  - 단, 웹 애플리케이션은 대부분의 경우 90% 이상이 Read 쿼리
  - 마스터 부하는 테이블 분할이나 다른 구현 등으로 연구

## MySQL의 스케일아웃과 파티셔닝
### MySQL의 스케일아웃 전략
- 데이터가 메모리에 올라가는 크기면 메모리에 올린다.
- 그렇지 않다면 메모리를 증설한다.

### 파티셔닝
파티셔닝이란 테이블 A와 B를 서로 다른 서버에 놓아 분산하는 방법이다.

- 테이블 단위로 분할
- 특정 알고리즘으로 분할

보통 1:N의 관계로 DB 테이블이 잡혀있을 때 데이터를 뽑으려면 `JOIN` 쿼리를 사용한다. 하지만 이를 던지기 위해선 두 테이블을 분할할 수 없다. 서로 다른 머신에 올리고 싶지만, MySQL에는 서로 다른 서버에 있는 테이블을 `JOIN`하는 기능이 기본적으로 없다. 그러므로 `JOIN`을 사용한다면 두 테이블을 다른 서버에 위치시킬 수 없다.

`JOIN`을 배재한다.

```sql
-- 다음 두 쿼리는 같음
select url from entry INNER JOIN bookmark on entry.eid = bookmark.eid
  where bookmark.uid = 169848 limit 5;

--
select eid from bookmark where uid = 169848 limit 5;
select url from entry where eid in (0,4,5,6,7);
```

### 파티셔닝의 상반관계
좋은 점은 부하가 내려가고 국소성이 늘어나 캐시 효과가 높아진다. 하지만 단점도 크다.

- 운용이 복잡해진다.
  - 고장확률이 높아지고 복구에 시간이 걸린다.
  - 비용이 늘어난다.

파티셔닝은 어디까지나 마지막 카드다.