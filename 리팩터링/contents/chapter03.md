# 3장. 코드에서 나는 악취
인스턴스 변수를 삭제하거나 상속 계층을 만드는 것은 간단한 문제이지만, 이런 일들을 **'언제' 해야 하는지**에 대해서는 명확하게 정립된 규칙이 없다. 책의 저자는 리팩터링이 필요한, 때로는 아주 절실한 코드에 대해 일정한 패턴이 있다는 사실을 발견했다고 한다.

- 단, 언제 리팩터링을 멈춰야 하는지 판단하는 정확한 기준을 제시하진 않을 것이다.
- 종료 기준보단 리팩터링하면 해결할 수 있는 문제의 징후를 제시한다.

## 기이한 이름
- 코드는 단순하고 명료하게 작성해야 한다.
  - 가장 중요한 요소 하나는 **이름**이다.
- 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기, ...
- 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.
- 혼란스러운 이름을 잘 정리하다 보면 훨씬 간결해질 때가 많다.

## 중복 코드
- **똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하자.**
  - **코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야** 하는 부담이 생긴다.
  - 그중 하나를 변경할 땐 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야 한다.
- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우 → `함수 추출하기`
- 코드가 비슷하긴 한데 완전히 똑같진 않은 경우 → `문장 슬라이드하기`로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용가능한지 살펴본다.
- 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있는 경우 → 각자 따로 호출되지 않도록 `메서드 올리기` 적용

## 긴 함수
저자의 경험에 비추어보면 오랜 기간 잘 활용되는 함수들은 대체로 길이가 짧았다.

- 짧은 함수들로 구성된 코드베이스를 훑어보면 자기가 계산하는 구조보다 위임하는 구조로 보인다. 이런 위임하는 구조는 코드를 이해하고 공유하기 쉽다.
- 짧은 함수로 만든다는 건 하나의 긴 함수처럼 모든 계산을 하는 것이 아니라 짧은 함수 여러개를 호출하는 구조이다.
- 이런 구조 때문에 성능 상으로 떨어진다는 생각을 할 수 있지만 요즘 프로그래밍 언어에서 이는 문제가 되지 않는다.
- **짧은 함수와 좋은 이름의 조합은 짧은 함수의 구현을 보지 않아도 어떠한 일을 하는지 명확하게 알 수 있어 코드를 이해하기가 훨씬 쉬워진다.**
  - 이를 위해서는 함수 자체를 적극적으로 짧게 구성하도록 해야한다.
- **긴 함수에서 우리가 주석으로 달아야 할 만한 부분은 무조건 함수로 빼내자.**
  - 그리고 그 **함수의 이름은 동작 방식에 집중하지 말고 의도에 집중**하자.
- **함수의 이름은 의도가 중요하고 이 의도와 실제 구현과의 괴리감이 얼마나 있느냐**가 잘 짓는 기준이다.
  - 즉 무엇을 하는지 설명해주지 못한다면 함수의 이름을 잘 지은게 아니다.
  - 코드가 단 한줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.
- 함수를 짧게 만드는 방법의 99% 는 `함수 추출하기`로 이뤄진다.
  - 함수가 매개변수와 임시 변수를 많이 사용한다면 추출하기 어렵다.
- 많은 임시 변수는 `임시 변수를 질의 함수로 바꾸기` 기법을 사용하면 되고 많은 매개변수는 `매개변수 객체 만들기`와 `객체 통째로 떠넘기기`에 집중한다.
- 이런 리팩토링 기법을 적용해도 여전히 임시 변수와 매개 변수가 많다면 `함수를 명령으로 만들기` 기법을 사용해도 좋다.
- 조건문이나 반복문도 추출의 대상이 된다.
  - `조건문 분해하기`로 대응하거나 switch 문을 구성하는 case 문 마다에 있는 내용을 함수로 추출하는 함수 추출하기를 사용하거나 같은 조건을 기준으로 나뉘는 switch 문이 여러개라면 `조건문을 다형성으로 바꾸기`를 적용하면 된다.
- 반복문도 그 안의 코드와 함께 추출해서 함수로 만드는 것도 가능하다.
- 추출한 반복문에 마땅한 이름이 떠오르지 않는다면 성격이 다른 두 가지의 일을 하는 것일 수도 있다.
  - 이는 반복문 쪼개기 (8.7절) 를 사용하자.

## 긴 매개변수 목록
- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.
- 종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 `매개변수를 질의 함수로 바꾸기`로 제거할 수 있다.
- 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드 → `객체 통째로 넘기기`를 적용해서 원본 데이터 구조를 그대로 전달.
- 항상 함께 전달되는 매개변수들 → `매개변수 객체 만들기`로 하나로 묶는다.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수 → `플래그 인수 제거하기`로 없앤다.
- 클래스는 매개변수 목록을 줄이는 데 효과적인 수단이기도 하다.
  - 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때. → `여러 함수를 클래스로 묶기`를 이용해 공통 값들을 클래스의 필드로 정의한다.
  - functional programming → 일련의 부분 적용 함수들을 생성한다.

## 전역 데이터
- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.
  - 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.
- 이를 방지하기 위해 대표적으론 **`변수 캡슐화하기`를 사용**한다.
  - **다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다.**
  - 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있다.
  - 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.
- 전역 데이터가 가변이라면 특히나 다루기 까다롭다.

## 가변 데이터
## 뒤엉킨 변경
## 산탄총 수술
## 기능 편애
## 데이터 뭉치
## 기본형 집착
## 반복되는 switch문
## 반복문
- 지금은 일급 함수를 지원하는 언어가 많아졌기 때문에 `반복문을 파이프라인으로 바꾸기`를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다.
- `filter`, `map` 같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

## 성의 없는 요소
- 코드의 구조를 잡을 때 프로그램 요소(언어가 제공하는 함수, 클래스, 인터페이스 등)를 이용하곤 한다. 그 구조를 변형하거나 재활용할 기회가 생기고, 혹은 단순히 더 의미 있는 이름을 가졌기 때문이다.
- 하지만, **이 구조가 필요 없을 때도 있다.**
  - 본문 코드를 그대로 쓰는 것과 진배없는 함수
  - 실질적으로 메서드가 하나뿐인 클래스
  - 이런 구조는 나중에 본문을 더 채우거나 다른 메서드를 추가할 생각이었지만, 어떤 사정으로 인해 그렇게 하지 못한 결과일 수 있다.
  - 또는 원래는 풍성했던 클래스가 리팩터링을 거치며 역할이 줄어들었을 수 있다.
- 이런 프로그램 요소는 제거하자.
  - `함수 인라인하기`, `클래스 인라인하기` 적용.
  - 상속 사용 시엔 `계층 합치기`를 적용.

## 추측성 일반화
## 임시 필드
## 메시지 체인
## 중개자
## 내부자 거래
## 거대한 클래스
## 서로 다른 인터페이스의 대안 클래스들
## 데이터 클래스
- 데이터 클래스 : 데이터 필드와 getter/setter로만 구성된 클래스.
  - 데이터 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다.
- 이런 클래스에 `public` 필드가 있다면 `레코드 캡슐화하기`로 숨기자.
- 변경하면 안되는 필드는 `세터 제거하기`로 접근을 원천 봉쇄한다.
- 다른 클래스에서 데이터 클래스의 getter/setter를 사용하는 메서드를 찾아 `함수 옮기기`로 그 메서드를 옮길 수 있는지 살펴보자.
- 메서드를 통째로 옮기기 어렵다면 `함수 추출하기`를 이용해 옮길 수 있는 부분만 별도 메서드로 뽑아낸다.
- 한편, 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다.
  - 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다.
  - 예외 케이스는 다른 함수를 호출해 얻은 결과 레코드(데이터 객체)로는 동작 코드를 넣을 이유가 없다.
    - eg) `단계 쪼개기` 결과로 나온 중간 데이터 구조 - 이 구조는 불변이다. → 불변 필드는 굳이 캡슐화할 필요가 없고, 불변 데이터로부터 나오는 정보는 getter를 통하지 않고 그냥 필드 자체를 공개해도 된다.

```java
// 예시
// 주문 정보를 담는 간단한 클래스
public class Order {
    private final double subtotal;

    public Order(double subtotal) {
        this.subtotal = subtotal;
    }

    public double getSubtotal() {
        return subtotal;
    }
}

// 불변 중간 데이터 구조: 각 단계의 계산 결과를 담는다.
// 불변이므로 setter가 없고, 필드를 직접 노출해도 안전하다.
public class CalculationResult {
    public final double discount;
    public final double tax;
    public final double shipping;
    public final double total;

    public CalculationResult(double discount, double tax, double shipping, double total) {
        this.discount = discount;
        this.tax = tax;
        this.shipping = shipping;
        this.total = total;
    }
}

// 주문 처리 로직: 단계 쪼개기를 통해 중간 계산 결과를 생성한 후 최종 결과를 활용한다.
public class OrderProcessor {

    public double processOrder(Order order) {
        // 중간 계산 단계에서 결과를 담은 불변 객체를 생성
        CalculationResult result = calculateIntermediateResult(order);

        // 필요에 따라 result의 각 값을 활용할 수 있다.
        // 예를 들어, 로그를 남기거나 추가 처리를 수행할 수 있다.
        System.out.println("Discount: " + result.discount);
        System.out.println("Tax: " + result.tax);
        System.out.println("Shipping: " + result.shipping);
        System.out.println("Total: " + result.total);

        return result.total;
    }

    // 주문의 subtotal을 기반으로 할인, 세금, 배송비 등을 계산하는 단계
    private CalculationResult calculateIntermediateResult(Order order) {
        double subtotal = order.getSubtotal();
        
        // 예시 계산: 할인은 10%, 세금은 5%, 배송비는 고정 3원
        double discount = subtotal * 0.10;
        double tax = subtotal * 0.05;
        double shipping = 3.0;
        double total = subtotal - discount + tax + shipping;

        // 중간 계산 결과를 불변 객체에 담아 반환한다.
        return new CalculationResult(discount, tax, shipping, total);
    }
    
    // 간단한 테스트 실행
    public static void main(String[] args) {
        Order order = new Order(100.0);
        OrderProcessor processor = new OrderProcessor();
        double finalTotal = processor.processOrder(order);
        System.out.println("Final Total: " + finalTotal);
    }
}
```

## 상속 포기
## 주석
