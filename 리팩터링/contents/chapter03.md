# 3장. 코드에서 나는 악취
인스턴스 변수를 삭제하거나 상속 계층을 만드는 것은 간단한 문제이지만, 이런 일들을 **'언제' 해야 하는지**에 대해서는 명확하게 정립된 규칙이 없다. 책의 저자는 리팩터링이 필요한, 때로는 아주 절실한 코드에 대해 일정한 패턴이 있다는 사실을 발견했다고 한다.

- 단, 언제 리팩터링을 멈춰야 하는지 판단하는 정확한 기준을 제시하진 않을 것이다.
- 종료 기준보단 리팩터링하면 해결할 수 있는 문제의 징후를 제시한다.

## 기이한 이름
- 코드는 단순하고 명료하게 작성해야 한다.
  - 가장 중요한 요소 하나는 **이름**이다.
- 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기, ...
- 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.
- 혼란스러운 이름을 잘 정리하다 보면 훨씬 간결해질 때가 많다.

## 중복 코드
- **똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하자.**
  - **코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야** 하는 부담이 생긴다.
  - 그중 하나를 변경할 땐 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야 한다.
- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우 → `함수 추출하기`
- 코드가 비슷하긴 한데 완전히 똑같진 않은 경우 → `문장 슬라이드하기`로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용가능한지 살펴본다.
- 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있는 경우 → 각자 따로 호출되지 않도록 `메서드 올리기` 적용

## 긴 함수
저자의 경험에 비추어보면 오랜 기간 잘 활용되는 함수들은 대체로 길이가 짧았다.

- 짧은 함수들로 구성된 코드베이스를 훑어보면 자기가 계산하는 구조보다 위임하는 구조로 보인다. 이런 위임하는 구조는 코드를 이해하고 공유하기 쉽다.
- 짧은 함수로 만든다는 건 하나의 긴 함수처럼 모든 계산을 하는 것이 아니라 짧은 함수 여러개를 호출하는 구조이다.
- 이런 구조 때문에 성능 상으로 떨어진다는 생각을 할 수 있지만 요즘 프로그래밍 언어에서 이는 문제가 되지 않는다.
- **짧은 함수와 좋은 이름의 조합은 짧은 함수의 구현을 보지 않아도 어떠한 일을 하는지 명확하게 알 수 있어 코드를 이해하기가 훨씬 쉬워진다.**
  - 이를 위해서는 함수 자체를 적극적으로 짧게 구성하도록 해야한다.
- **긴 함수에서 우리가 주석으로 달아야 할 만한 부분은 무조건 함수로 빼내자.**
  - 그리고 그 **함수의 이름은 동작 방식에 집중하지 말고 의도에 집중**하자.
- **함수의 이름은 의도가 중요하고 이 의도와 실제 구현과의 괴리감이 얼마나 있느냐**가 잘 짓는 기준이다.
  - 즉 무엇을 하는지 설명해주지 못한다면 함수의 이름을 잘 지은게 아니다.
  - 코드가 단 한줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.
- 함수를 짧게 만드는 방법의 99% 는 `함수 추출하기`로 이뤄진다.
  - 함수가 매개변수와 임시 변수를 많이 사용한다면 추출하기 어렵다.
- 많은 임시 변수는 `임시 변수를 질의 함수로 바꾸기` 기법을 사용하면 되고 많은 매개변수는 `매개변수 객체 만들기`와 `객체 통째로 떠넘기기`에 집중한다.
- 이런 리팩토링 기법을 적용해도 여전히 임시 변수와 매개 변수가 많다면 `함수를 명령으로 만들기` 기법을 사용해도 좋다.
- 조건문이나 반복문도 추출의 대상이 된다.
  - `조건문 분해하기`로 대응하거나 switch 문을 구성하는 case 문 마다에 있는 내용을 함수로 추출하는 함수 추출하기를 사용하거나 같은 조건을 기준으로 나뉘는 switch 문이 여러개라면 `조건문을 다형성으로 바꾸기`를 적용하면 된다.
- 반복문도 그 안의 코드와 함께 추출해서 함수로 만드는 것도 가능하다.
- 추출한 반복문에 마땅한 이름이 떠오르지 않는다면 성격이 다른 두 가지의 일을 하는 것일 수도 있다.
  - 이는 반복문 쪼개기 (8.7절) 를 사용하자.

## 긴 매개변수 목록
- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.
- 종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 `매개변수를 질의 함수로 바꾸기`로 제거할 수 있다.
- 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드 → `객체 통째로 넘기기`를 적용해서 원본 데이터 구조를 그대로 전달.
- 항상 함께 전달되는 매개변수들 → `매개변수 객체 만들기`로 하나로 묶는다.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수 → `플래그 인수 제거하기`로 없앤다.
- 클래스는 매개변수 목록을 줄이는 데 효과적인 수단이기도 하다.
  - 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때. → `여러 함수를 클래스로 묶기`를 이용해 공통 값들을 클래스의 필드로 정의한다.
  - functional programming → 일련의 부분 적용 함수들을 생성한다.

## 전역 데이터
- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.
  - 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.
- 이를 방지하기 위해 대표적으론 **`변수 캡슐화하기`를 사용**한다.
  - **다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다.**
  - 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있다.
  - 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.
- 전역 데이터가 가변이라면 특히나 다루기 까다롭다.

## 가변 데이터
- 데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있다.
- 함수형 프로그래밍에선 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 원래 데이터는 그대로 둔 채 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.
- 무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다.
  - `변수 캡슐화하기`를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
  - 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 `변수 쪼개기`를 이용해 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다.
  - 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다. → `문장 슬라이드하기`, `함수 추출하기`
  - API를 만들 땐 `질의 함수와 변경 함수 분리하기`를 활용하자.
  - 가능한 한 `세터 제거하기`도 적용한다.
- 값을 다른 곳에서 설정할 수 있는 가변 데이터가 풍기는 악취는 고약하다. 이럴 땐 `파생 변수를 질의 함수로 바꾸기`를 활용하자.
- `여러 함수를 클래스로 묶기`나 `여러 함수를 변환 함수로 묶기`를 활용해 변수를 갱신하는 코드들의 유효범위를 클래스나 변환으로 제한한다.
- 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 `참조를 값으로 바꾸기`를 적용하여, 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.

## 뒤엉킨 변경
- 소프트웨어의 구조를 변경하기 쉬운 형태로 조직하자. 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아 그 부분만 수정할 수 있기를 바란다.
- 뒤엉킨 변경은 **단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타난다.** 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.
  - 지원해야 할 DB가 추가될 때마다 함수 세 개를 바꿔야 하고, 금융 상품이 추가될 때마다 또 다른 함수 네 개를 바꿔야 하는 모듈이 있다면 뒤엉킨 변경이 발생했다는 뜻이다.
- DB에서 데이터를 가져와 금융 상품 로직에서 처리해야 하는 일처럼 순차적으로 실행되는 게 자연스러운 맥락이라면, 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다. (`단계 쪼개기`)
- 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다. (`함수 옮기기`)
- 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 `함수 추출하기`부터 수행한다.
- 모듈이 클래스라면 `클래스 추출하기`가 맥락별 분리 방법을 잘 안내해줄 것이다.

## 산탄총 수술
뒤엉킨 변경과 비슷하면서도 정반대다.

||뒤엉킨 변경|산탄총 수술|
|--|--|--|
|원인|맥락을 잘 구분하지 못함|
|해법(원리)|맥락을 명확히 구분|
|발생 과정(현상)|한 코드에 섞여 들어감|여러 코드에 흩뿌려짐|
|해법(실제 행동)|맥락별로 분리|맥락별로 모음|

- 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다. 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.
- 함께 변경되는 대상들을 `함수 옮기기`와 `필드 옮기기`로 모두 한 모듈에 묶어두면 좋다.
- 비슷한 데이터를 다루는 함수가 많다면 `여러 함수를 클래스로 묶기`를 적용한다.
- 데이터 구조를 변환하거나 보강하는 함수들에는 `여러 함수를 변환 함수로 묶기`를 적용한다.
- 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 `단계 쪼개기`를 적용한다.
- 어설프게 분리된 로직을 `함수 인라인하기`나 `클래스 인라인하기` 같은 인라인 리팩터링으로 하나로 합치는 것도 좋은 방법이다.
  - 메서드나 클래스가 비대해지지만, 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수도 있다.

## 기능 편애
- **기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새다.**
- 실행 과정에서 외부 객체의 게터 메서드 대여섯 개를 호출하도록 작성된 함수의 예시
  - 이 함수가 데이터와 가까이 있고 싶어하는 의중이 뚜렷이 드러나므로 데이터 근처로 옮겨주자. (`함수 옮기기`)
- 함수의 일부에서만 기능을 편애하는 경우 → 그 부분만 독립 함수로 빼낸 다음 원하는 모듈로 보내준다. (`함수 추출하기`, `함수 옮기기`)
- 어디로 옮길지 명확하게 드러나지 않거나 함수가 사용하는 모듈이 다양하다면, 가장 많은 데이터를 포함한 모듈로 옮긴다. `함수 추출하기`로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결되는 경우도 많다.
- 이런 규칙을 거스르는 복잡한 패턴으론 전략 패턴, 방문자 패턴이 있다. 켄트 벡의 자기 위임도 여기에 속한다.
  - 뒤엉킨 변경 냄새를 없앨 때 활용하는 패턴들로, 함께 변경할 대상을 한데 모으는 것이 기본이 되는 원칙이다.
  - 이를 적용하면 오버라이드해야 할 소량의 동작 코드를 각각의 클래스로 격리해주므로 수정하기 쉬워지지만, 간접 호출이 늘어난다.

## 데이터 뭉치
- 데이터 항목들은 서로 어울려 노는 걸 좋아한다. 보통 데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐다니는 모습을 흔히 볼 수 있다.
  - 클래스 두어 개의 필드, 혹은 여러 메서드의 시그니처에서.
- 가장 먼저 필드 형태의 데이터 뭉치를 찾아 `클래스 추출하기`로 하나의 객체로 묶는다.
- 메서드 시그니처에 있는 데이터 뭉치의 경우, `매개변수 객체 만들기`나 `객체 통째로 넘기기`를 적용해서 매개변수 수를 줄여본다.
- 데이터 뭉치인지 판별하려면 값 하나를 삭제해보자. 그럴 때 나머지 데이터만으론 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.
- 간단한 레코드 구조가 아닌 '클래스'로 만드려는 이유는 클래스를 이용하면 좋은 향기를 흩뿌릴 기회가 생기기 때문이다.
- 새로운 클래스를 만들었다면, 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴보자.
- 이런 연계 과정은 종종 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스를 탄생시키는 결과로 이어지기도 한다.

## 기본형 집착
- 대부분의 프로그래밍 언어에서는 기본형 타입을 지원한다. 정수, 부동소수점 수, 문자열과 같은 다양한 기본형을 제공해준다.
- 그래서인지 모르겠지만 프로그래머들은 이런 기본형들을 그냥 사용하는걸 선호하지 자신의 문제를 해결하기 위한 클래스로 만들어서 사용하는걸 꺼려한다. (화폐, 전화번호, 좌표 등)
- 그리고 기본형을 통해 그냥 if 절에서 계산하는 걸 볼 수 있다. 이것 보단 클래스의 메소드로 정의하는게 훨씬 좋다.
- 이 냄새는 특히 문자열 변수에서 특히 심한데 전화번호를 단순 문자열 표현이라고만 생각하는 경우가 많다. 전화번호가 제공해주는 기능이 꽤 있는데도 말이다.
- 이런 기본형을 객체로 바꿔주는 작업을 토해서 문명 사회로 이끌어줘야 한다.
- 또 기본형으로 표현된 코드가 조건절에서 타입을 이용하는 코드로 사용하고 있다면 이는 `타입 코드를 서브 클래스로 바꾸기` 기법과 조건부 로직을 `다형성으로 바꾸기` 기법을 사용하는것도 가능해진다.
- 추가로 자주 몰려다니는 기본형 타입이 있다면 이들을 한 클래스로 묶어주는 `클래스 추출하기 기법`도 필요하다.

## 반복되는 switch문
- 다형성의 가치를 모르던 시절에는 switch 문의 남발로 인해 switch 문을 보면 `조건부 로직을 다형성으로 바꾸기` 기법을 사용하는 걸 추천했다.
- 하지만 요즘에는 다형성을 잘 알고 있으므로 그 정도까지 검토하지는 않겠다.
- switch 문이 진짜 나쁜 경우는 중복해서 사용하고 있을 경우다.
  - 이 경우에 하나의 케이스가 추가되기만 하면 모든 switch 문을 찾아서 넣어줘야 하는 작업이 필요해진다.
  - 이렇게 중복이 발생하고 있다면 조건부 로직을 다형성으로 바꿔주자.

## 반복문
- 지금은 일급 함수를 지원하는 언어가 많아졌기 때문에 `반복문을 파이프라인으로 바꾸기`를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다.
- `filter`, `map` 같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

## 성의 없는 요소
- 코드의 구조를 잡을 때 프로그램 요소(언어가 제공하는 함수, 클래스, 인터페이스 등)를 이용하곤 한다. 그 구조를 변형하거나 재활용할 기회가 생기고, 혹은 단순히 더 의미 있는 이름을 가졌기 때문이다.
- 하지만, **이 구조가 필요 없을 때도 있다.**
  - 본문 코드를 그대로 쓰는 것과 진배없는 함수
  - 실질적으로 메서드가 하나뿐인 클래스
  - 이런 구조는 나중에 본문을 더 채우거나 다른 메서드를 추가할 생각이었지만, 어떤 사정으로 인해 그렇게 하지 못한 결과일 수 있다.
  - 또는 원래는 풍성했던 클래스가 리팩터링을 거치며 역할이 줄어들었을 수 있다.
- 이런 프로그램 요소는 제거하자.
  - `함수 인라인하기`, `클래스 인라인하기` 적용.
  - 상속 사용 시엔 `계층 합치기`를 적용.

## 추측성 일반화
- 추측성 일반화는 나중에 이게 필요할 것이라는 이유로 당장은 필요없는 코드로 인해 풍기는 악취다.
- 이런 이유는 물론 이해하지만 코드 관리가 어렵다면 쓸데없는 낭비일 뿐이다.
- 당장 걸리적 거리는 코드는 모두 지워버리자.
- 하는 일이 거의 없는 클래스는 `계층 합치기`로 제거하고 쓸데 없이 위임하는 코드는 `함수 인라인 하기`와 `클래스 인라인 하기`로 삭제하자.
- 본문에서 사용하지 않는 매개변수는 `함수 선언 바꾸기`로 제거하자.
- 추측성 일반화는 주로 테스트 코드 말고는 사용하는 경우가 없는데 이런 경우에는 테스트 케이스부터 삭제한 뒤 `죽은 코드 제거하기`로 날려버리자.

## 임시 필드
- 간혹 클래스 필드에서 특정한 상황에서만 그 필드에 값이 들어가는 경우가 있다.
- 이런 필드는 대부분의 상황에서는 값이 들어가 있지 않기 때문에 다른 사람들이 그 클래스를 보면 이해하기가 어려워진다.
- 원래 클래스라는 것 자체가 모든 필드가 다 들어있다는 전제하에 객체를 만든다.
- 그러므로 이런 임시 필드가 있다면 이런 필드만 따로 뽑는 `클래스 추출하기`기법을 통해서 제 살 곳을 찾아줘야한다.
- 그 다음 `함수 옮기기`기법으로 임시 필드와 관련 있는 함수들을 모두 클래스로 옮겨주자.
- 또 기존 클래스에 임시 필드의 여부와 관련해서 동작하는 메소드가 있다면 `특이 케이스 추가하기`기법을 통해서 해결할 수 있다.

## 메시지 체인
- 메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 후 연속적으로 객체를 찾아나가는 과정을 말한다.
- 가령 `getSomething()` 과 같은 메소드를 연속적으로 호출해서 객체를 찾아나가는 걸 말한다.
- 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 말한다. 중개자의 역할만 하는 객체는 딱히 의미는 없다.
- 이와 같은 문제는 `위임 숨기기`로 해결하는게 가능하다.
- 하지만 이 기법을 많이 사용하면 중간 객체가 중재자와 같은 역할을 하게 되므로 결국에 찾는 최종 객체에게 어떠한 행동을 바라는지를 알아보고 그 행동을 `함수 추출하기`로 추출한 후 `함수 옮기기`로 옮기는 걸 생각해보자.

## 중개자
- 객체의 대표적인 기능 중 하나로 캡슐화 (encapsulation) 이라는 기능이 있다.
- 캡슐화를 통해서 객체는 다른 객체에게 작업을 위임하고 구현을 몰라도 된다.
- 예로 팀장과 미팅을 잡는다고 하면 팀장은 일정을 조율하고 답을 줄 것이다. 근데 일정을 잡는 과정에서 다이어리를 쓰든, 캘린더를 쓰든, 비서를 쓰든 그건 알바가 아니다.
- 이렇게 캡술화를 사용하면 구현을 몰라도 원하는 바를 얻을 수 있는 장점이 있다.
- 이게 지나치면 문제가 되는데 클래스의 메소드의 절반이 다른 객체에게 위임하고 있는 구조라면 그 객체는 Middle Man 이다.
- 그 객체를 제거하는 `중개자 제거하기`기법을 통해서 객체와 직접적으로 소통하도록 하자.

## 내부자 거래
- 소프트웨어 개발자는 모듈 사이에 벽을 두껍게 세우기를 좋아한다.
- 이 말은 모듈 사이의 필요없는 결합은 줄이고 싶어한다는 말을 의미한다.
- 만약에 은밀하게 모듈 끼리 데이터를 주고 받는 일이 있다면 `필드 옮기기` 기법이나 `함수 옮기기` 기법을 사용해서 결합을 줄이는게 좋다.
- 여러 모듈이 같은 관심사를 공유해서 결합하는 일이 많다면 제 3의 모듈을 만드는 기법이나 `위임 숨기기` 기법을 이용해서 다른 모듈이 중간자의 역할을 하도록 한다.
- 상속 구조에서 부모와 자식 클래스간의 결합이 많아 진다고 하면 헤어져야 한다. 이 경우에는 `서브 클래스를 위임으로 바꾸기` 기법이나 `부모 클래스를 위임으로 바꾸기`를 이용하면 된다.

## 거대한 클래스
- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 늘어난다.
- 필드 수가 많아지면 필드의 이해가 떨어져서 중복 코드가 발생할 확률이 높아진다.
- 이럴 떈 `클래스 추출하기` 기법으로 관련있는 필드끼리 묶는다.
- 주로 접두어가 같은 필드끼리 묶어서 클래스로 만든다고 생각하면 된다.
- 이렇게 클래스로 추출할 일이 있을 수 있고 상속관계로 만드는게 나을 수도 있다. 이 경우에는 `슈퍼 클래스 추출하기` 기법을 사용하는 방법도 있고 타입 코드가 있고 이를 서브 클래스로 추출하는 `타입 코드를 서브 클래스로 바꾸기`를 이용할 수 도 있다.
- 목표는 클래스가 항시 모든 필드를 사용하도록 하자.
- 또 거대 클래스 중에서 코드량이 많다면 중복 코드가 있을 확률이 높다. 그 클래스안에서 중복 코드를 제거하는 `함수 추출하기`를 이용하자.

## 서로 다른 인터페이스의 대안 클래스들
- **클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다. 단, 교체하려면 인터페이스가 같아야 한다.**
- `함수 선언 바꾸기`로 메서드 시그니처를 일치시킨다.
- `함수 옮기기`를 이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다.
- 대안 클래스들 사이에 중복 코드가 생기면 `슈퍼클래스 추출하기`를 적용할지 고려해본다.

## 데이터 클래스
- 데이터 클래스 : 데이터 필드와 getter/setter로만 구성된 클래스.
  - 데이터 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다.
- 이런 클래스에 `public` 필드가 있다면 `레코드 캡슐화하기`로 숨기자.
- 변경하면 안되는 필드는 `세터 제거하기`로 접근을 원천 봉쇄한다.
- 다른 클래스에서 데이터 클래스의 getter/setter를 사용하는 메서드를 찾아 `함수 옮기기`로 그 메서드를 옮길 수 있는지 살펴보자.
- 메서드를 통째로 옮기기 어렵다면 `함수 추출하기`를 이용해 옮길 수 있는 부분만 별도 메서드로 뽑아낸다.
- 한편, 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다.
  - 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다.
  - 예외 케이스는 다른 함수를 호출해 얻은 결과 레코드(데이터 객체)로는 동작 코드를 넣을 이유가 없다.
    - eg) `단계 쪼개기` 결과로 나온 중간 데이터 구조 - 이 구조는 불변이다. → 불변 필드는 굳이 캡슐화할 필요가 없고, 불변 데이터로부터 나오는 정보는 getter를 통하지 않고 그냥 필드 자체를 공개해도 된다.

```java
// 예시
// 주문 정보를 담는 간단한 클래스
public class Order {
    private final double subtotal;

    public Order(double subtotal) {
        this.subtotal = subtotal;
    }

    public double getSubtotal() {
        return subtotal;
    }
}

// 불변 중간 데이터 구조: 각 단계의 계산 결과를 담는다.
// 불변이므로 setter가 없고, 필드를 직접 노출해도 안전하다.
public class CalculationResult {
    public final double discount;
    public final double tax;
    public final double shipping;
    public final double total;

    public CalculationResult(double discount, double tax, double shipping, double total) {
        this.discount = discount;
        this.tax = tax;
        this.shipping = shipping;
        this.total = total;
    }
}

// 주문 처리 로직: 단계 쪼개기를 통해 중간 계산 결과를 생성한 후 최종 결과를 활용한다.
public class OrderProcessor {

    public double processOrder(Order order) {
        // 중간 계산 단계에서 결과를 담은 불변 객체를 생성
        CalculationResult result = calculateIntermediateResult(order);

        // 필요에 따라 result의 각 값을 활용할 수 있다.
        // 예를 들어, 로그를 남기거나 추가 처리를 수행할 수 있다.
        System.out.println("Discount: " + result.discount);
        System.out.println("Tax: " + result.tax);
        System.out.println("Shipping: " + result.shipping);
        System.out.println("Total: " + result.total);

        return result.total;
    }

    // 주문의 subtotal을 기반으로 할인, 세금, 배송비 등을 계산하는 단계
    private CalculationResult calculateIntermediateResult(Order order) {
        double subtotal = order.getSubtotal();
        
        // 예시 계산: 할인은 10%, 세금은 5%, 배송비는 고정 3원
        double discount = subtotal * 0.10;
        double tax = subtotal * 0.05;
        double shipping = 3.0;
        double total = subtotal - discount + tax + shipping;

        // 중간 계산 결과를 불변 객체에 담아 반환한다.
        return new CalculationResult(discount, tax, shipping, total);
    }
    
    // 간단한 테스트 실행
    public static void main(String[] args) {
        Order order = new Order(100.0);
        OrderProcessor processor = new OrderProcessor();
        double finalTotal = processor.processOrder(order);
        System.out.println("Final Total: " + finalTotal);
    }
}
```

## 상속 포기
- 서브클래스는 부모로부터 메서드와 데이터를 물려받는다. 하지만 부모의 유산을 원치 않거나 필요 없다면 어떻게 해야 할까?
- 예전에는 계층구조를 잘못 설계했기 때문으로 봤다. 이 관점에서의 해법은, 먼저 같은 계층에 서브클래스를 하나 새로 만들고, `메서드 내리기`와 `필드 내리기`를 활용해서 물려받지 않을 부모 코드를 모조리 새로 만든 서브 클래스로 넘긴다. 그러면 부모에는 공통된 부분만 남는다.
- 한 걸음 더 나아가 부모 클래스는 모두 추상 클래스여야 한다고 말하는 사람도 많다.
- 하지만, 위 방식을 권하진 않는다. 일부 동작을 재활용하기 위한 목적으로 상속을 활용하기도 하는데, 실무 관점에서 아주 유용한 방식이다. 솔직히 냄새를 풍기긴하지만, 보통 참을만한 경우가 많다.
- 상속을 포기할 시 혼란과 문제가 생긴다면 예전 방식을 따른다. (단, 무조건 이래야 한다는 건 아니다.)
- **상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다.**
- 구현을 따르지 않는 것은 이해할 수 있지만 인터페이스를 따르지 않는다는 것은 상당히 무례한 태도다.
- `서브클래스를 위임으로 바꾸기`나 `슈퍼클래스를 위임으로 바꾸기`를 활용해 아예 상속 메커니즘에서 벗어나보자.

## 주석
- 주석은 악취가 아닌 향기를 입힌다. 문제는 주석을 탈취제처럼 사용하는 데 있다.
- 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.
- 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 `함수 추출하기`
- 이미 추출되어 있는 함수임에도 여전히 설명이 필요하다면 `함수 선언 바꾸기`
- 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 `어셔선 추가하기`
- **주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.**
- 뭘 할지 모를 때, 현재 진행 상황뿐만 아니라 확실하지 않은 부분에 주석을 남긴다. 코드를 지금처럼 작성한 이유를 설명하는 용도로 달 수도 있다.