# 1장. 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다
- 범위: 1.1 ~ 1.5 (프로그래밍 언어, 컴파일러, 링커, 추상화)
- 공통: 코드 → 실행파일까지 큰 흐름 잡기
- FE: JS/Python 같은 인터프리터 언어와 비교, 프론트 런타임 이해
- BE: JIT, 바이트코드, JVM과 비교
- DevOps: 빌드/배포, 링커, 동적 라이브러리 → 컨테이너 이미지와 연계

---
## 프로그래밍 언어를 만든다면?
boolean logic -> CPU

### 창세기 : CPU는 똑똑한 바보
CPU는 매우 원시적이다. 데이터를 한곳에서 다른곳으로 옮기고 간단히 연산한 후 다시 그 데이터를 또 다른 자리로 옮기는 작업 외에는 할 줄 모른다.  
매우 간단하고 멍청한 작업만 할 수 있는 것 처럼 보이나, CPU의 가장 큰 장점은 속도가 엄청나게 빠르다는 것이다.

- 천공 카드로 컴퓨터 작업 제어
  - 프로그래머는 CPU 의지에 따라 직접 0과 1로 구성된 명령어를 작성. - 코드, 소스
  - 이 시기의 프로그래머는 CPU 관점에서 코드를 작성해야 했다.

```
1101101010011010
1001001100101001
1100100011011110
1011101101010010
```

### 어셈블리어 등장
CPU를 주의 깊게 연구한 결과, CPU는 가산 명령어, 점프 명령어 등 겨우 몇 가지 명령어만 실행할 수 있다는 사실을 발견함.
- **기계어와 해당 특정 작업을 간단하게 대응시켜 기계어를 인간이 읽고 이해할 수 있는 단어와 대응 시킴**

```
sub  $8, %rsp
mob  $.LC0, %edi
call puts
mov  $0, %eax
```

- 이제 프로그래머는 `add`, `sub`, `mov` 처럼 인간이 인식할 수 있는 단어만 기억하면 됨.
- 인간이 인식 가능한 기계 명령어를 CPU가 인식할 수 있는 0과 1로 구성된 바이너리로 변환하는 프로그램을 사용.

→ 어셈블리어 탄생

### 저수준 계층의 세부 사항 대 고수준 계층의 추상화
어셈블리어는 기계어와 마찬가지로 여전히 저수준 언어에 해당함.  
→ 프로그래머가 모든 세부 사항에 신경써야 함.

'데이터를 한곳에서 다른 곳으로 이동시키고, 간단히 연산한 후 또다시 다른 곳으로 이동시키는 것'처럼 몇 가지 간단한 명령어를 사용해 정렬 같은 복잡한 문제를 구현해야 함.

인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 자동으로 변환할 수 있는 방법이 있다면 프로그래머의 생산성을 획기적으로 높일 수 있을 것.

### 가득한 규칙 : 고급 프로그래밍 언어의 시작
![](https://velog.velcdn.com/images/songs4805/post/819dcbb0-5e03-4c5c-af1f-4973eb25cbe1/image.png)

- CPU가 실행하는 명령어는 대부분 매우 단도직입적이다. 이런 명령어에 statement라는 이름을 붙인다.
- 이 명령어 중엔 구체적으로 특정 행동을 하는 것 외에도 특정 상황에 따라 어떤 명령어를 실행할지 결정해야 하는 선택이 필요하다.

```
if ***
  blablabla
else ***
  blablabla
```

- 어떤 경우엔 일정한 명령어를 계속 반복해야 한다.
```
while ***
  blablabla
```

- 어떤 경우엔 개별적인 세부 사항만 다소 차이가 있을 뿐 계속 반복된다.
  - 매개변수(parameter)
  - 별도로 분리하고 매개변수를 제외한 나머지 명령어를 하나로 묶어 하나의 코드로 지정한다.
  - 함수

```
fun abc:
  blablabla
```

### 인셉션과 재귀 : 코드 본질
- `f(x) = f(x-1) + f(x-2)`
if문 안에 포함되어 있는 statement, 그 statement 안에 또다시 if문 포함. 결국 이 재귀라는 개념이 프로그래밍 언어에 포함되었다.

```
if: if expr statement else statement
for: while expr statement
statement: if | for | statement
```

이 몇 가지 표현에 **구문(syntax)** 라는 이름을 붙였다.

### 컴퓨터가 재귀를 이해하도록 만들기
컴퓨터가 재귀 구문으로 표현된 문자열을 인식할 수 있게 하려면??  
→ 재귀 구문에 따라 작성된 코드를 tree 구조로 표현. **구문 트리(syntax tree)**

### 컴파일러
- 컴퓨터는 프로그래밍 언어를 처리할 때 구문 정의에 따라 트리 형태로 코드를 구성할 수 있다. 이 트리는 구문에 따라 생성되기 때문에 여기에 구문 트리라는 매우 고급스러운 이름을 붙였다.
- 리프 노드의 표현이 매우 간단하게 바뀌어서 매우 간단하게 기계 명령어로도 번역할 수 있다.
  - 이 결과를 부모 노드에 적용할 수 있고, 차례대로 올라가다보면 결국 전체 트리를 구체적인 기계 명령어로 번역할 수 있다.

### 해석형 언어의 탄생
- 세상에는 다양한 CPU가 있는데, 형식이 다른 CPU는 각각 자신만의 고유한 언어가 있다.
- 통용과 표준에 해당하는 명령어 집합을 정의해서 CPU의 기계 명령어 실행 과정을 모방하는 프로그램을 작성하여 사용하자.
- 한 번의 코드 작성으로 어디서나 그 코드를 실행하는 방법.
- Virtual Machine, Interpreter

![](https://velog.velcdn.com/images/songs4805/post/f36fa54b-568e-4454-bdf7-38b7a4aeddfa/image.png)

- C/C++ 처럼 기계 명령어로 번역하여 CPU에 직접 넘기거나
- Java처럼 바이트 코드로 변환한 후 가상 머신으로 넘겨 실행하거나

## 컴파일러는 어떻게 작동하는 것일까?
컴파일러는 일반적인 프로그램일 뿐이다. 크게 보면 번역기, 작게 보면 텍스트 처리 프로그램이다.

```c
int a = 1;
int b = 2;

while (a < b)
{
  b = b - 1;
}
```

### 각각의 토큰 추출하기
- 키워드 : `int`
- 토큰 : 각 항목에 추가로 정보를 결합한 것.
  - 아래 예시에서 각각의 줄은 하나의 토큰을 의미
  - T로 시작하는 왼쪽 열은 토큰 의미
  - 오른쪽 열은 각 토큰이 가지는 값

```
T_Keyword    int
T_Identifier a
T_Assign     =
T_Int        1
T_Semicolon  ;
T_Keyword    int
T_Identifier b
T_Assign     =
T_Int        2
T_Semicolon  ;
T_While      while
T_LeftParen  (
T_Identifier a
T_Less       <
T_Identifier b
T_RightParen )
T_OpenBrace  {
T_Identifier b
T_Assign     =
T_Identifier b
T_Minus      -
T_Int        1
T_Semicolon  ;
T_CloseBrace }
```

- 소스코드에서 토큰을 추출하는 과정을 어휘 분석(lexical analysis)라고 함.

### 개략적인 과정
- 각 프로그래밍 언어 별 추상 구문 트리 동작은 아래 링크를 참고할 것.
  - [Abstact Syntax Tree explorer](https://astexplorer.net/)

![](https://velog.velcdn.com/images/songs4805/post/c00574f6-858d-4ea6-b4de-5f26a0609993/image.png)

사람이 이해 가능한 프로그래밍 언어가 컴퓨터가 이해 가능한 기계어로 변환되기까지의 과정은 개략적으로 아래와 같다.
```
[소스 코드]
     ↓
[토큰]
  └─ 렉싱(Lexical Analysis)
     ↓
[구문 트리]
  └─ 파싱(Parsing)
     ↓
[의미 분석 (Semantic Analysis)]
  └─ 타입, 스코프 검사
     ↓
[중간 코드 (Intermediate Representation, IR)]
  └─ 플랫폼 중립적인 코드 형태
     ↓
[어셈블리어 (Assembly)]
  └─ 기계 명령어 수준으로 번역
     ↓
[기계어 (Machine Code)]
  └─ CPU가 직접 실행 가능한 코드
```

참고로, 아래와 같은 차이는 있을 수 있다.

|구분|방식|특징|
|--|--|--|
|C / C++|정적 컴파일 (Ahead-of-Time)|전체 코드를 한 번에 기계어로 컴파일 후 실행|
|JavaScript / Python|인터프리터 (Interpreter)|한 줄씩 해석 및 실행 (즉시성은 높지만 속도는 느림)|
|Java / Kotlin / Scala|바이트코드 + JVM|한 번 컴파일된 후, JVM이 실행 중에 해석하거나 **JIT(Just-In-Time)**으로 기계어 변환|
|Go / Rust|네이티브 컴파일|빌드 시 모든 코드가 기계어로 컴파일되어 독립 실행 가능|
|C# / .NET|CLR 기반 JIT|Java와 유사하게 바이트코드를 런타임에 최적화 실행|

구문 트리를 기반으로 중간 코드(IR Code)를 생성한다면 아래와 같은 형태로 표현된다.

```
  a = 1
  b = 2
  goto B
A: b = b - 1
B: if a < b goto A
```

## 링커의 말할 수 없는 비밀
프로그래밍 언어로 작성된 여러 소스 파일(.c) 은 각각 컴파일러를 통해 목적 파일(.o) 로 변환된다. 그러나 .o 파일은 단독으로 실행될 수 없으며, 서로의 함수, 전역 변수 등 심벌(Symbol) 을 참조하기 때문에 이들을 하나의 실행 파일(Executable) 로 묶어주는 과정이 필요하다.

이 과정을 수행하는 프로그램이 바로 링커(Linker) 이다.
```
|----------|
|A.c → A.o |
|B.c → B.o | → 링크 → 정적 라이브러리 → 실행 파일
|C.c → C.o |
     |
  [컴파일]
```

링커는 크게 아래와 같은 일을 한다.
- 모듈 종속성 / 심벌 해석
  - 여러 개의 목적 파일 간에 존재하는 함수/변수 참조 관계를 해석한다. 예를 들어, A.o에서 foo()를 호출했지만 foo()는 B.o에 정의되어 있다면, 링커가 이를 찾아 연결한다.
  - 심벌(Symbol) 은 전역 변수나 함수 이름을 의미한다. 링커는 모든 목적 파일의 심벌 테이블(Symbol Table) 을 읽고, “심벌의 정의(공급)”와 “심벌의 참조(수요)”를 매칭하여 연결한다.
- 실행 파일 생성
- 재배치
  - 여러 개의 .o 파일을 하나의 실행 파일로 병합하기 위해, 각 목적 파일이 갖고 있던 상대 주소(Relative Address)를 절대 주소(Absolute Address) 로 재배치한다.
	-	예를 들어, A.o 내 함수 main()이 0x100에, B.o 내 함수 foo()가 0x200에 배치되도록 실제 메모리 주소를 조정한다

---
- 심벌 : 전역 변수, 함수 포함 변수 이름들
- 지역 변수는 모듈 내 사용이라 링커의 관심 대상이 아니다. → 스택 영역
- 심벌 테이블은 공급과 수요라고 보면 좋다.
  - 공급자(Symbol Definition) : 함수나 전역 변수를 정의한 위치
    - `int count = 0;`
  - 수요자(Symbol Reference) : 다른 모듈에서 이를 참조하는 부분
    - `extern int count;`
- 정적 라이브러리는 매번 다시 컴파일을 해야 하는 이슈나 용량 이슈가 있어 동적 라이브러리가 이를 커버한다. (동적 링크, 공유)

링커 이후 메모리 구조는 아래와 같다. 실행 파일은 보통 다음과 같은 영역으로 구성된다.
```
┌────────────────┐
│ 코드 영역 (Text)     │  → 함수, 명령어 저장
├────────────────┤
│ 데이터 영역 (Data)   │  → 전역/정적 변수 저장
├────────────────┤
│ 힙 영역 (Heap)       │  → 동적 메모리
├────────────────┤
│ 스택 영역 (Stack)    │  → 지역 변수, 함수 호출 스택
└────────────────┘
```

### 정적 라이브러리, 동적 라이브러리
|구분|정적 라이브러리 (Static Library)|동적 라이브러리 (Dynamic Library / Shared Object)|
|--|--|--|
|확장자|.a (Unix), .lib (Windows)|.so (Unix), .dll (Windows)|
|링크 시점|컴파일/링크 타임|실행(Runtime)|
|실행 파일 크기|큼 (라이브러리 코드가 포함됨)|작음 (필요한 심벌 정보만 포함)|
|업데이트|라이브러리 수정 시 재컴파일 필요|실행 시 최신 버전 자동 사용 가능|
|예시|libm.a, libpthread.a|libm.so, libc.so|

- 정적 라이브러리 : 컴파일 단계에 실행 파일에 함께 복사
  - 실행 시 별도 의존성이 없어 배포가 간단하지만, 용량 증가 및 재빌드 필요성이 단점이다.
- 동적 라이브러리 : 여기에 의존하는 실행파일엔 컴파일 단계에서 필수 정보만 저장. 실제 프로그램 실행 시점까지 동적 링크를 미룸.
  - 실행 파일에는 심벌 정보(참조 정보)만 저장하고, 실제 코드는 프로그램 실행 시 로드된다.
  - OS 로더가 프로그램 실행 시 .so 또는 .dll을 메모리에 적재해 연결한다.
  - 장점
    - 프로그램 크기 감소
    - 여러 프로그램이 동일 라이브러리를 공유 (메모리 절약)
    - 라이브러리 교체 시 재컴파일 불필요