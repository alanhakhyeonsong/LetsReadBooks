# 1장. 사용자 수에 따른 규모 확장성
## 단일 서버
웹 앱, 데이터베이스, 캐시 등이 전부 서버 한 대에서 실행된다.

![](https://velog.velcdn.com/images/songs4805/post/f1732207-5697-49ff-a018-aae03de167af/image.jpeg)

1. 사용자는 도메인 이름을 이용하여 웹사이트에 접속한다. 이 접속을 위해 도메인 이름을 DNS에 질의하여 IP 주소로 변환하는 과정이 필요하다. DNS는 third party가 제공하는 유료 서비스이다.
2. DNS 조회 결과로 IP 주소가 반환되고 이 주소는 웹 서버의 주소이다.
3. 해당 IP 주소로 HTTP 요청이 전달된다.
4. 요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.

## 데이터베이스
![](https://velog.velcdn.com/images/songs4805/post/937fc0f8-2a1d-4012-89de-8feefb6fecd8/image.jpeg)

사용자가 늘면 서버 하나로는 충분하지 않아 여러 서버를 두어야 한다. 하나는 웹/모바일 트래픽 처리 용도고, 다른 하나는 데이터베이스용이다. 웹/모바일 트래픽 처리 서버(웹 계층)와 데이터베이스 서버(데이터 계층)를 분리하면 그 각각을 독립적으로 확장해 나갈 수 있게 된다.

### 어떤 데이터베이스를 사용할 것인가?
- RDBMS: 테이블, 열, 칼럼으로 자료를 표현하고 SQL을 사용하며 조인 연산을 지원함
- NoSQL: 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소. 조인 연산 지원하지 않음

구축하려는 시스템에 관계형 데이터베이스 이외의 저장소도 필요한 경우가 있다. 다음과 같은 경우에는 NoSQL을 고려하자.
- 아주 낮은 응답 지연시간(latency)이 요구됨
- 다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님
- 데이터(JSON, YAML, XML 등)를 직렬화하거나(serialize) 역직렬화(deserialize) 할 수 있기만 하면 됨
- 아주 많은 양의 데이터를 저장할 필요가 있음

## 수직적 규모 확장 vs 수평적 규모 확장
- scale up(수직적 규모 확장): 서버에 고사양(더 좋은 CPU, 더 많은 RAM 등)을 추가하는 행위
  - 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법이 없다.
- scale out(수평적 규모 확장): 더 많은 서버를 추가하여 성능을 개선하는 행위
  - 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않는다.
  - 서버에 장애가 발생하면 웹사이트/앱은 완전히 중단된다.

대규모 애플리케이션을 지원하는 데는 수평적 규모 확장법이 보다 적절하다.  
앞서 본 설계에서 사용자는 웹 서버로 바로 연결된다. 웹 서버가 다운되면 사용자는 웹 사이트에 접속할 수 없다. 또한, 너무 많은 사용자가 접속하여 웹 서버가 한계 상황에 도달하게 되면 응답 속도가 느려지거나 서버 접속이 불가능해질 수도 있다. 이 문제를 해결하기 위해 부하 분산기 또는 로드 밸런서(load balancer)를 도입하는 것이 최선이다.

### 로드밸런서
![](https://velog.velcdn.com/images/songs4805/post/e1a8fc99-be3c-40ee-97a0-6f4021260a6a/image.jpg)

**로드밸런서는 부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할**을 한다.

사용자는 로드밸런서의 공개 IP 주소로 접속한다. 따라서 웹 서버는 클라이언트의 접속을 직접 처리하지 않는다. 더 나은 보안을 위해, 서버 간 통신에는 사설 IP 주소가 이용된다. 사설 IP 주소는 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 주소로 인터넷을 통해 접속할 수 없다. 로드밸런서는 웹 서버와 통신하기 위해 바로 이 사설 주소를 이용한다.

- 서버 1이 다운되면 모든 트래픽은 서버 2로 전송된다. 그 결과 웹 사이트 전체가 다운되는 일이 방지된다. 부하를 나누기 위해 새로운 서버를 추가할 수도 있다.
- 로드밸런서가 있으므로 웹 서버 계층에 더 많은 서버를 추가하기만 하면 자동으로 트래픽이 분산된다.

### 데이터베이스 다중화
![](https://velog.velcdn.com/images/songs4805/post/9b1c08e4-26fb-4680-84c0-d0e0ca907cfd/image.jpg)

보통은 master-slave 관계를 설정하고 데이터 원본은 master 서버에, 사본은 slave 서버에 저장하는 방식이다.

쓰기 연산은 master에서만 지원한다. slaver DB는 master DB로부터 그 사본을 전달받으며, 읽기 연산만을 지원한다. 데이터베이스를 변경하는 명령어들(insert, delete, update 등)은 master로만 전달되어야 한다.  
대부분의 애플리케이션은 읽기 연산의 비중이 쓰기 연산보다 훨씬 높다. 따라서 통상 slave DB의 수가 master DB의 수보다 많다.

데이터베이스를 다중화하면 다음과 같은 이득이 있다.
- 더 나은 성능: master-slave 다중화 모델에서 모든 데이터 변경 연산은 master로만 전달되는 반면, 읽기 연산은 slave 서버들로 분산된다. 병렬로 처리될 수 있는 query의 수가 늘어나므로, 성능이 좋아진다.
- 안정성: 자연 재해 등의 이유로 데이터베이스 서버 가운데 일부가 파괴되어도 데이터는 보존될 것이다.
- 가용성: 데이터를 여러 지역에 복제해 둠으로써, 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스할 수 있게 된다.

![](https://velog.velcdn.com/images/songs4805/post/da07647a-b273-4e9c-8cc0-ca79c75e7ad9/image.jpg)

## 캐시
**캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소다.** 이전 구조에선 웹 페이지를 새로고침 할 때마다 표시할 데이터를 가져오기 위해 한 번 이상의 데이터베이스 호출이 발생한다.  
애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우되는데, 캐시는 그런 문제를 완화할 수 있다.

### 캐시 계층
캐시 계층은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다. 별도의 캐시 계층을 두면 성능이 개선될 뿐 아니라 데이터베이스의 부하를 줄일 수 있고, 캐시 계층의 규모를 독립적으로 확장시키는 것도 가능해진다.

![](https://velog.velcdn.com/images/songs4805/post/00686c22-9516-4dd2-a3d5-9a84790000c7/image.jpg)

위와 같은 캐시 전략을 일기 주도형 캐시 전략이라 한다. 이 외에 다양한 캐시 전략이 있는데, 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택하면 된다.

### 캐시 사용시 유의할 점
- 캐시는 어떤 상황에 바람직한가? 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려해볼 만하다.
- 어떤 데이터를 캐시에 두어야 하는가? 캐시는 데이터를 휘발성 메모리에 두므로, 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.