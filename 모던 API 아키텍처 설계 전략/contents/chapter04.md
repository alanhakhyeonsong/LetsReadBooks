# 4장. 서비스 메시: 서비스 간 트래픽 관리
## 서비스 메시가 유일한 해결책인가
- SDK, DB Driver?
  - HTTP, TCP/IP Protocol
- 소비자와 제공자의 수가 증가하다보면 서비스 메시가 가장 확장 가능하고 유지보수가 용이하며 안전한 옵션.

## 서비스 메시란
- '서비스 메시'란 **분산 소프트웨어 시스템에서 모든 서비스 간 통신을 관리하는 패턴**
- API GW와 여러모로 유사하지만 두 가지 차이가 있음.
  - 서비스 메시 구현은 클러스터나 데이터센터 내의 서비스 간 또는 수평 트래픽을 처리하는 데 최적화
  - 요청의 시작은 사용자 장치나 애플리케이션 외부에서 실행 중인 서비스가 아니라 잘 알려진 내부 서비스인 경우가 대부분.
- 서비스 메시는 메시 네트워킹이 아님.
- 서비스 메시 패턴은 트래픽 관리(라우팅), 회복성, 관측용이성 그리고 서비스 간 통신에 대한 보안을 중점적으로 제공하는 패턴.
- 제어 부분과 데이터 부분 2개 기반 컴포넌트로 구현되며, 항상 별도로 배포.
  - 제어 부분 : 운영자가 서비스 메시를 조작해 라우팅과 정책, 필요한 텔레메트리를 정의
  - 데이터 부분 : 제어 부분에서 지정한 모든 작업의 발생, 네트워크 패킷의 라우팅, 정책의 반영, 텔레메트리 정보의 송신 등이 일어나는 부분
- 사이드카 프록시
  - 기반 애플리케이션이 프록시의 존재를 눈치채지 못하도록 투명하게 라우팅되므로 모든 트래픽을 필요에 따라 안전하게 라우팅하고 관측할 수 있음.

<img width="905" height="475" alt="Image" src="https://github.com/user-attachments/assets/b9ed5678-bbee-4f14-a7c6-be763969ac95" />

## 서비스 메시가 제공하는 기능들
- 네트워크 수준에서 보면 서비스 메시 프록시는 완전 프록시처럼 동작.
- API GW와는 달리 서비스 메시 데이터 부분과 서비스의 매핑은 보통 1:1 관계
  - 서비스 메시 프록시는 여러 서비스에 대한 호출을 종합하지 않음.
- 사용자 검증, 호출률 제한, 타임아웃/재시도 같은 공통 기능 제공
- 시스템의 관측용이성 구현을 지원하기 위한 지표, 로그, 추적 데이터 등도 제공

## 서비스 메시를 배포하는 위치
- 내부 네트워크나 클러스터 안애 배포한다. 대규모 시스템이나 네트워크는 주로 여러 서비스 메시 인스턴스를 배포해 관리하며, 하나의 메시가 네트워크 세그먼트나 비즈니스 도메인을 담당한다.
- 네트워크 DMZ나 외부 시스템 또는 다른 네트워크나 클러스터로 엔드포인트를 노출하기도 한다. 보통 '메시 게이트웨이', '종점 게이트웨이', '환승 게이트웨이'라 부르는 프록시를 이용해 구현한다.

![Image](https://github.com/user-attachments/assets/755e7332-c10b-402f-abcf-085e3d78ee58)

## 서비스 메시는 다른 네트워크 토폴로지와 어떻게 통합될까

![Image](https://github.com/user-attachments/assets/c73285d4-2c10-4a60-ac86-474533f03d3c)

## 서비스 메시를 사용해야 하는 이유
- 라우팅, 신뢰성, 트래픽 관리에 대한 세분화된 제어
- 투명한 관측용이성의 제공
- 보안의 적용: 전송 보안, 인증, 인가
- 여러 언어의 교차 기능적 통신의 지원
- 인그레스 트래픽과 서비스 간 트래픽 관리의 분리

||인그레스(수직) 트래픽|서비스 간(수평) 트래픽|
|--|--|--|
|트래픽 근원지|외부(사용자, 서드파티, 인터넷)|(신뢰 경계 내의) 내부|
|트래픽 목적지|공개 또는 비즈니스와 관련된 API 또는 웹사이트|서비스 또는 도메인 API|
|인증|'사용자'(실세계의 엔티티) 위주|'서비스'(머신 엔티티)와 '사용자'(실세계의 엔티티) 위주|
|인가|'사용자' 역할 또는 역량 수준|'서비스' 신원 또는 네트워크 세그먼트 위주 및 '사용자' 역할 또는 역량 수준|
|TLS|단방향이며 대부분 강제적(eg. 프로토콜 업그레이드)|상호적이며 필수일 수 있음(엄격한 mTLS)|
|주요 구현체|API GW, 리버스 프록시|서비스 메시, 애플리케이션 라이브러리|
|주 소유자|게이트웨이/네트워킹/운영 팀|플랫폼/클러스터/운영 팀|
|조직 사용자|아키텍트, API 관리자, 개발자|개발자|

## 서비스 메시의 진화
<img width="2560" height="1111" alt="Image" src="https://github.com/user-attachments/assets/53a089ef-2151-46a7-935f-bb87c11f0bf7" />

## 서비스 메시의 분류
|사용 사례|라이브러리 기반(프록시 없는)|사이드카, 프록시 기반|OS/커널 기반|
|--|--|--|--|
|언어/플랫폼 지원|단일 언어 라이브러리, 플랫폼 중립적|언어 중립적, 폭넓은 플랫폼 지원|언어 중립적, OS 수준 지원|
|런타임 메커니즘|애플리케이션 내에 패키지로 포함되어 실행|애플리케이션과 별개의 프로세스로 실행|OS 커널의 일부로 실행되며 사용자 및 커널 영역에 완전한 접근이 가능|
|서비스 메시 컴포넌트의 업그레이드|전체 애플리케이션의 재빌드 및 재배포 필요|사이드카 컴포넌트의 재배포 필요(대부분 다운타임 없음)|커널 프로그램 업데이트/패치가 필요|
|관측 용이성|손쉬운 컨텍스트 전파와 함께 애플리케이션과 트래픽의 완전한 통찰이 가능|트래픽에 대한 통찰만 가능. 컨텍스트의 전파는 언어 또는 shim의 지원이 필요|트래픽에 대한 통찰만 가능. 컨텍스트의 전파는 언어 또는 shim의 지원이 필요|
|보안 위협 모델|라이브러리 코드는 애플리케이션의 일부로 실행|사이드카는 보통 애플리케이션과 프로세스 및 네트워크 네임스페이스를 공유|애플리케이션이 시스템 콜을 이용해 OS와 직접 소통|

## 예시
```bash
kubectl label namespace default istio-injection=enabled
```

라우팅 활성화 → Virtual Service 생성

```yaml
apiVersion: networking.istio.io/v1apha3
kind: VirtualService
metadata:
  name: sessions
spec:
  hosts:
  - sessions
  http:
  - route:
    - destination:
        host: sessions
        subnet: v1
---
apiVersion: networking.istio.io/v1apha3
kind: VirtualService
metadata:
  name: attendees
spec:
  hosts:
  - attendees
  http:
  - route:
    - destination:
        host: attendees
        subnet: v1
```

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: sessions
spec:
  host: sessions
  subnets:
  - name: v1
    labels:
      version: v1
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: attendees
spec:
  host: attendees
  subnets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
```

## 서비스 메시의 배포: 장애의 이해와 관리
- 서비스 메시는 단일 실패 지점이다.
  - 당연하겠지만 서비스 메시의 기능에 더 의존할수록 더 큰 위험을 수반하며 장애의 영향도 커질 수밖에 없다.

## 정리
- 기본적으로 '서비스 메시'는 분산 소프트웨어 시스템상에서 모든 서비스 간 통신을 관리하는 패턴이다.
- 네트워크 수준에서 서비스 메시 프록시는 완전 프록시처럼 동작해 다른 서비스로부터 유입되는 모든 인바운드 트래픽을 수신하며 다른 서비스로 향하는 모든 아웃바운드 요청을 발생시킨다.
- 서비스 메시는 내부 네트워크나 클러스터에 배포한다. 대형 시스템이나 네트워크는 보통 서비스 메시 인스턴스를 여러 개 배포해 관리하며, 하나의 메시로 네트워크 세그먼트나 비즈니스 도메인을 담당하게 하는 경우가 대부분이다.
- 서비스 메시는 네트워크 비무장지대나 외부 서비스 또는 추가 네트워크/클러스터 등에 엔드포인트를 노출하기도 하지만 이는 보통 '인그레스', '종점' 또는 '환승' 게이트웨이로 구현한다.
- 제품 수명주기 관리, 신뢰성, 다중 언어 통신 지원, 관측 용이성, 보안, 유지보수성, 확장성 등 모든 내부 서비스에 공통적으로 필요한 API 관련 기능은 여러 가지가 있다. 서비스 메시는 이런 문제를 해결하는 데 도움이 된다.
- 서비스 메시는 특정 언어용 라이브러리, 사이드카 프록시, 프록시 없는 통신 프레임워크(gRPC) 또는 eBPF 같은 커널 기반 기술을 이용해 구현할 수 있다.
- 서비스 메시에서 가장 불안한 컴포넌트는 보통 제어 부분이다. 이 부분은 반드시 보호되어야 하고 모니터링해야 하며 고가용성 서비스로 운영해야 한다.
- 서비스 메시를 ESB 또는 GW처럼 사용하는 방법이나 네트워크 계층이 많은 경우는 서비스 메시의 안티패턴에 해당한다.
- 서비스 메시를 구현하기로 결정하고 관련된 기술을 선택하는 것도 한 가지 결정 방법이다. 이 경우에는 연구와 요구사항 분석, 적절한 설계가 반드시 수반되어야 한다.
- 서비스 메시 패턴을 도입하기로 결정했다면 직접 구현하기보다는 오픈 소스 구현체나 상용 솔루션을 도입해 표준화하는 것이 최선이다.