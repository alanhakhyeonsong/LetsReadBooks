# 2장. API 테스트
## 테스트 전략
### 테스트 사분면
<img width="1536" height="1210" alt="Image" src="https://github.com/user-attachments/assets/251fa81b-82e0-438d-adef-18cdefe6bbc9" />

- Q1
  - 단위 테스트, 컴포넌트 테스트는 기술을 위한 것. 이 테스트는 서비스가 동작하는지 검증하는 것이며, 이런 검증은 자동화된 테스트를 이용해 수행해야 함.
- Q2
  - 비즈니스와 연관
  - 구현한 서비스가 목적을 달성하는지 확인. 자동화된 테스트로 수행할 수도 있고 사람이 직접 테스트할 수도 있다.
- Q3
  - 비즈니스와 연관
  - 기능적 요구사항을 만족시키는지 확인하는 것이며 탐색 테스트도 포함하고 있음. 수동으로만 가능한 테스트였으나, 이 영역에서도 이젠 자동화가 가능함.
- Q4
  - 기술적 측면에서 기존에 있던 것들이 제대로 동작하는지 확인.
  - 보안 정책의 적용, SLA 무결성, 오토스케일링 등

### 테스트 피라미드
<img width="1186" height="690" alt="Image" src="https://github.com/user-attachments/assets/31e556c6-0f17-433f-a391-733f22f7763d" />

테스트는 애플리케이션의 동작에 대한 더 많은 확신을 주지만 여러 조각들이 어우러져 동작해야 하므로 테스트의 범위가 커진다. 게다가 유지보수가 어렵고 속도가 떨어진다.

- [End-To-End Testing considered harmful - Steve Smith](https://www.stevesmith.tech/blog/end-to-end-testing-considered-harmful/)
- [On the Diverse And Fantastical Shapes of Testing - Martin Fowler](https://martinfowler.com/articles/2021-test-shapes.html)

## 계약 테스트
- 소비자와 생산자라는 2개의 엔티티가 존재.
  - 소비자는 API에게 데이터를 요청(eg. 웹 클라이언트, 터미널 쉘)하고 생산자 API 요청에 응답.
- 계약은 소비자와 생산자 사이의 상호작용을 정의.
  - endpoint 경로
  - HTTP method
  - request body 구조
  - response body 구조
  - 필드 타입
  - 상태 코드

---
마이크로서비스에서 이런 문제가 생김
- 서비스 A(Consumer)가
- 서비스 B(Provider)를 호출한다.

그런데 B가 응답 필드를 바꾸거나, 타입을 바꾸거나, 필수 필드를 제거하면?

- A는 런타임에서 깨진다
- 이걸 잡으려고 E2E 테스트를 많이 만들면 느리고 불안정해짐

그래서 등장한 게 계약 테스트.

### 계약 테스트를 더 선호하는 이유
- API는 명세를 가져야 하며 API가 명세에 정의된 응답을 리턴하는 것이 중요함.
- 상호작용의 정의를 기록 해두면 소비자가 API를 계속 사용하면서 테스트를 생성할 수 있도록 생산자가 그 정의를 따라야 함.
- 계약에는 응답에 대한 정의도 있으므로 스텁 서버를 생성하는 것도 가능.
- 로컬 환경에서도 계약 테스트 가능.

CDC(Consumer-Driven Contract) 기반 수행.
- Consumer와 Provider를 동시에 띄워서 통합 테스트하지 않음
- 각자 독립적으로 계약 파일을 기준으로 테스트함
- 그래서 빠르고, 안정적임
- E2E 테스트 수를 줄일 수 있음

Pact?
- 계약을 JSON 파일로 저장 (pact file)
- Pact Broker를 통해 계약 공유
- CI에서 자동 검증 가능
- https://docs.pact.io/implementation_guides/jvm/consumer/junit5

```javascript
provider
  .given("User 1 exists")
  .uponReceiving("a request for user 1")
  .withRequest({
    method: "GET",
    path: "/users/1"
  })
  .willRespondWith({
    status: 200,
    body: {
      id: 1,
      name: "Alice"
    }
  })
```

## API 컴포넌트 테스트
컴포넌트 테스트는 여러 단위 컴포넌트가 원활하게 협업하는지 검증하는 방법이며 동작의 검증에 사용해야 한다. API에 요청을 보내고 응답을 검증하는 것은 컴포넌트 테스트의 좋은 예다.
- 이 방법이 계약 테스트와 다른 점은 서비스가 올바른 동작을 수행하는지 직접 확인해야 한다는 점이다.
  - eg. 새 참석자를 생성하는 과정을 테스트한다면 최종적으로 서비스가 DB를 호출하는지 검증해야 함.
  - 단순히 계약 테스트처럼 응답만 검증하는 것이 아님.

다음의 상황을 검증해야 한다.
- 요청이 발생했을 때 올바른 상태 코드를 리턴하는가?
- API가 올바른 데이터를 리턴하는가?
- 요청에 빈 파라미터나 null 값을 전달하면 서비스가 요청 처리를 거부하는가?
- XML 콘텐츠를 리턴해달라는 요청을 보내면 데이터가 원하는 형식으로 리턴되는가?
- 올바른 자격을 갖추지 않은 사용자가 요청을 보내면 어떤 응답이 리턴되는가?
- 빈 데이터셋이 리턴되면 어떤 응답이 리턴되는가? 404 에러인가, 아니면 빈 배열인가?
- 리소스를 새로 생성하면 새로 생성된 리소스를 가리키는 경로가 Location 헤더에 포함되어 리턴되는가?

## API 통합 테스트
**통합 테스트란 개발 중인 모듈과 그 외의 외부 의존성 사이의 경계를 넘는 테스트다.** 일종의 서비스 테스트이며, 통합 테스트를 수행할 때는 경계를 넘어서는 통신이 올바르게 이뤄지는지 확인해야 한다.
- 상호작용이 올바르게 이뤄지는지 여부
  - REST 서비스의 경우 올바른 URL을 호출하는지 또는 응답 본문이 올바른지를 확인하는 것 등이 해당.
- 외부 서비스와 통합된 단위가 리턴된 응답을 올바르게 처리하는지 여부

### 스텁 서버를 사용해야 하는 이유와 방법
- 항상 계약으로 자동 생성한 스텁 서버를 사용할 수 있는 것은 아니다.
- 가장 간단한 방법은 서비스가 요청을 보내고 응답을 받는 서비스의 동작을 흉내 내는 스텁 서버를 직접 구현하는 것이다.
  - 스텁이 정확하게 동작하도록 하는 것이 가장 중요함.
  - 부정확한 URL을 제공하거나 응답의 속성 이름과 값을 잘못 전달하는 등의 실수를 하기가 매우 쉽기 때문.
- 이 방법은 아주 괜찮은 방법에 속함.

부정확성을 피하고 URL에 대한 요청과 응답을 정확하게 확인할 수 있는 방법은 레코더를 이용하는 것.
- 엔드포인트에 대한 요청과 그 응답을 기록하고 스텁 서버에 활용할 수 있는 파일을 생성하는 도구를 사용하는 것도 가능.
- 생성 시점의 데이터를 정확히 표현 가능함.
- 스텁 서버는 요청이 유입되면 매핑 파일에서 일치하는 요청을 찾고 그 요청에 매핑된 응답을 리턴.
- 레코딩을 사용한다면 기록된 결과를 항상 최신 상태로 유지해야 함.

### 테스트 컴포넌트의 컨테이너화: Testcontainers
- https://www.testcontainers.org
- 애플리케이션을 컨테이너 이미지로 빌드하는 것은 보편적이며 우리의 서비스가 통합할 수많은 애플리케이션이 컨테이너로 존재할 수 있음을 의미.
- 이런 이미지를 로컬 머신에서 실행해 테스트에 활용할 수 있다.
- 외부 서비스와의 통신을 테스트할 수 있을 뿐만 아니라 프로덕션 환경에서 같은 이미지를 실행할 수도 있다.
- 테스트의 실행 시간이 길어지나, 통합 테스트는 보통 그 수가 적으며 시간 대비 솔루션을 통해 얻을 수 있는 더 큰 확신은 충분히 가치가 있는 트레이드오프다.

## 종단 간 테스트
종단 간 테스트의 기본은 **테스트 서비스와 그 의존성이 함께 어우러져 의도대로 동작하는지 검증하는 것이다.**
- 어떤 요청을 보냈을 때 목적지에 제대로 전달되는지 검증
- 요청이 모든 경로를 흘러가 소비자가 올바른 응답을 얻게 되는지 검증

이 검증을 통해 시스템 전체가 의도대로 동작한다는 확신을 얻을 수 있다.

### 종단 간 검증의 자동화
- 종단 간 테스트에 있어 실제로 동작하는 우리의 서비스 인스턴스가 함께 상호작용하는 것이 이상적.
  - 경우에 따라선 해당 조건을 갖추기 어려울 때가 있음.
  - 일부 엔티티는 스텁으로 대체해도 무방함.

종단간 테스트에도 경계가 필요함.

### 종단 간 테스트의 종류
- 시나리오 테스트
  - 보편적인 형태의 종단 간 테스트
  - 전형적인 사용자의 행동을 테스트
  - BDD
  - 장점은 어떤 컴포넌트가 프로덕션 환경보다 느리게 동작하더라도 염려하지 않아도 된다는 점. 중요한 것은 올바른 동작과 원하는 결과.
- 성능 테스트
  - 목표하는 SLO 내에 요청을 서비스하는지 검증하는 것에 집중해야 함.
  - 성능 테스트를 통해 서비스에 (eg. 실수로 블로킹 코드를 넣는다던지) 갑작스러운 지연이 발생하지 않는 것을 확인하고자 할 것.
  - 볼륨이 중요하다면 서비스가 원하는 수준의 부하를 처리할 수 있는지 검증.
    - eg. JMeter, Locust, K6
- 보안 검증
  - TLS가 적용되어 있고 적절한 인증 메커니즘이 구현되어 있는지 여부에 대해서도 확실히 검증해야 함.

## 정리
- 테스트의 기본에 충실하고 API의 중요한 기능은 단위 테스트를 통해 테스트한다.
- 계약 테스트는 일관된 API를 개발하고 다른 API와의 동작을 테스트하는 데 도움이 된다.
- 컴포넌트에 대해 서비스 테스트를 수행하고 통합 지점은 유입 트래픽과 유출 트래픽을 검증하는 것에만 집중한다.
- 중요한 사용자 행위에 대해 종단 간 테스트를 수행하면 API가 올바르게 통합되어 동작하는지 검증하는 데 도움이 된다.
- API에 다른 종류의 테스트를 추가해야 한다면 ADR 가이드라인을 참고하자.