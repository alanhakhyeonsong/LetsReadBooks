# 1장. API 설계, 구현, 명세
## RESTful?
- 생산자와 소비자 간의 상호작용은 생산자가 리소스를 모델링하고 소비자는 그 리소스와 상호작용하는 형태로 정의한다.
- 생산자가 소비자에게 보내는 요청은 상태가 없다. 즉 생상자는 이전 요청의 상세 정보를 캐싱하지 않는다. 소비자는 어떤 리소스에 대한 연속적인 요청을 보내기 위해 생산자가 처리하는 데 필요한 정보를 반드시 전달해야 한다.
- 요청은 캐싱할 수 있다. 즉 생산자는 필요하다면 소비자에게 힌트를 제공할 수 있다. 보통 HTTP는 이런 정보를 헤더에 담아 전달한다.
- 소비자에게 일관된 인터페이스를 제공한다. HTTP 동사, 리소스를 비롯.
- 계층형 시스템이며 시스템의 복잡도를 REST 인터페이스로 추상화한다. 예를 들어, 소비자는 자신이 DB를 사용하는지 다른 서비스를 사용하는지 몰라야 한다.

## RPC?
- 원격 프로시저 호출은 한 프로세스의 메서드를 호출하지만 그 메서드의 실행은 다른 프로세스에서 이뤄진다.
- REST는 도메인 모델을 투영할 수 있고 소비자로부터 기반 기술에 대한 추상화를 제공하지만, **RPC는 한 프로세스의 메서드를 그대로 노출하며 다른 프로세스가 직접 호출하는 것이 가능하다.**
- gRPC 서버를 특정 포트를 통해 노출시켜 메서드를 원격으로 호출할 수 있도록 구성.
- 클라이언트 측에선 stub을 사용해 원격 호출에 대한 복잡도를 추상화.
- gRPC는 생산자와 소비자 간의 상호작용을 모두 처리할 수 있는 스키마가 필요하다.

## REST vs RPC?
- 가장 중요한 차이점은 **상태**
  - REST는 없지만, RPC는 구현에 따라 존재할 수도.

어떤 상태에서 RPC 기반 통합은 응답을 리턴하는 과정에서 상태를 만들기도 한다. 이렇게 상태를 구축하면 신뢰성 및 라우팅 복잡성이라는 잠재적 비용으로 고성능이라는 편의성을 얻을 수 있다.

## REST API의 표준과 구조
- **"개발자는 요청의 처리가 실패하는 경우 에러를 일관되게 처리할 수 있는 하나의 코드 블록을 작성해야 한다."**
- 외부 소비자에게 보내지는 에러 메시지에 스택 추적 및 기타 민감한 정보가 포함되지 않도록 해야 한다.

## API 버저닝
아래 3가지 사항에 대해선 각각 트레이드오프가 있음. (호환성이나 유지보수 측면을 따져보기)
- 새 버전을 릴리스하고 새로운 위치에 배포하는 방법
- 기존 버전의 API와 하위호환성을 갖는 새 버전의 API를 릴리스하는 방법
- 기존 버전 API와의 호환성을 버리고 모든 소비자가 새 API를 사용하기 위해 코드를 업그레이드하도록 하는 방법

시맨틱 버저닝?
- 메이저 버전
- 마이너 버전
- 패치 버전

## 교환 방식과 API 형식의 선택
- 트래픽이 높은 서비스
- 대용량 데이터 페이로드
  - REST 응답의 JSON? encode/decode? 압축?
- HTTP/2
  - gRPC는 기본적으로 HTTP/2를 사용하며, 바이너리 프로토콜을 사용해 교환하는 데이터의 크기를 줄인다.

## 다중 명세 제공 시 어려움?
버저닝, 도메인 결합, 호환성 이슈

## 정리
- REST와 RPC 기반 API를 구현하는 진입 장벽은 대부분 낮다. 오히려 설계와 구조를 신중하게 고려하는 것이 아키텍처 의사결정에 더 중요하다.
- REST와 RPC 모델 중 하나를 선택할 때는 리처드슨의 성숙도 모델 및 생산자와 소비자 사이의 결합도를 고려해야 한다.
- REST는 상당히 느슨한 표준이다. API를 구현할 때 API 표준을 반영하면 API를 일관적으로 설계할 수 있고 소비자가 기대하는 동작을 정의할 수 있다. API 표준은 API 호환성에 문제가 생길 수 있는 설계를 결정하게 되는 상황도 미리 방지할 수 있다.
- OpenAPI 명세는 API 구조를 공유하고 코딩 관련 활동을 자동화하는 데 유용하다. OpenAPI 기능을 적극적으로 도입하고 프로젝트에 어떤 도구나 생성 기능을 도입할 것인지 결정해야 한다.
- 버저닝은 생산자 입장에서는 복잡도가 증가하지만 소비자가 API를 쉽게 사용하는 데 필요한 중요한 주제다. 소비자에게 노출되는 API의 버저닝을 계획하지 않는 것은 위험한 일이다. 버저닝은 프로젝트의 기능 중에서도 적극적으로 결정해야 하는 주제이며 소비자에게 버저닝을 전달하는 메커니즘 역시 결정에 포함해야 한다.
- gRPC는 높은 대역폭의 데이터 교환이 필요할 때 특히 잘 동작하며 수평 데이터 교환에 이상적이다. gRPC 도구는 강력하며 데이터 교환을 모델링할 때 여러 옵션을 제공한다.
- 다중 명세를 모델링하는 것은 까다로운 일이다. 특히 한 명세로부터 다른 명세를 생성할 때 더욱 그렇다. 여기에 버저닝까지 고려하면 일이 더 복잡해지지만, 호환성 문제를 피하기 위한 중요한 요소다. RPC와 REST는 사용성과 소비자 코드의 제어 측면에서 근본적인 차이가 있으므로 RPC와 RESTful API의 결합은 신중하게 결정해야 한다.

---
## 번외 (셀프 질문)
REST vs RPC 얘기할 때 사람들이 “URI냐 메서드냐” 같은 겉모습만 보는데, 실제로 큰 차이는 상태(state)를 어디에 두느냐, 그리고 그게 성능/운영복잡도에 어떤 트레이드오프를 만들냐 쪽이 더 본질임.

### RPC에서 말하는 “상태”가 뭐냐?
REST는 철학적으로 stateless를 강하게 요구함. 즉, 요청 하나가 독립적이고 서버는 “이 클라이언트가 이전에 뭘 했는지”를 기억할 필요가 없어야 한다는 관점.

반면 RPC는 “함수 호출”처럼 동작하다 보니, 구현 방식에 따라 서버나 미들웨어가 연결 단위 / 세션 단위 / 스트림 단위 상태를 가질 수 있음.

이 RPC의 상태는 보통 이런 형태로 생김

#### 1) Connection State (연결 상태)
- HTTP/2, gRPC 같은 RPC는 보통 long-lived connection을 유지해.
- REST는 요청마다 연결을 새로 만드는 건 아니지만(keep-alive 있음), 기본 모델은 “요청-응답 단발성”이 강함.

RPC는 연결을 오래 유지하면서 서버가 다음 정보를 “기억”할 수 있음
- TLS handshake 완료됨
- 인증 토큰 검증 완료됨
- 스트림 ID 관리 중
- flow control 상태
- keepalive ping 상태

이런 것들이 모두 “상태”임.

#### 2) Session / Affinity State (세션/고정 상태)

RPC 시스템에서는 “한 번 붙은 서버에 계속 붙는” 패턴이 흔함.

예를 들어
- 특정 사용자의 호출은 특정 서버 인스턴스에 계속 라우팅
- sticky session / consistent hashing
- stateful load balancing

이러면 서버는 그 세션에 대해
- 캐시
- 컨텍스트
- 임시 데이터
- 인증 결과

를 들고 있을 수 있음.

#### 3) Streaming State (스트리밍 상태)

RPC(gRPC)는 streaming을 강하게 지원.

예를 들어
- client streaming
- server streaming
- bidirectional streaming

이건 본질적으로 서버가 “대화 흐름”을 유지해야 하니까 상태가 생김.

서버는 스트림 동안
- 지금 몇 번째 메시지인지
- partial aggregation 결과
- backpressure 상태
- 중간 버퍼

이런 걸 들고 있음.

### RPC에서 상태가 성능을 올려주는 이유

상태를 유지한다는 건 결국 매 요청마다 반복되는 작업을 생략할 수 있다는 뜻에 해당.

#### 1) 연결 재사용 + HTTP/2 Multiplexing

gRPC는 HTTP/2 기반이라 하나의 TCP 연결로 여러 요청을 동시에 처리 가능함.

REST(HTTP/1.1) 기반이면
- 커넥션을 여러 개 열어야 하고
- HOL(Head-of-line blocking) 문제가 생길 수 있음

HTTP/2는 한 연결에서 stream을 여러 개 뽑아서 동시에 처리하니 latency가 줄어듦.

즉 상태(연결 유지)가 성능을 줌.

#### 2) 인증/보안 처리 비용 절감

REST stateless 모델에서는 종종 매 요청마다
- JWT 검증
- API Key 확인
- 권한 체크
- 헤더 파싱

을 반복해야 함.

RPC에서는 long-lived connection 기반이라면
- connection establish 시 인증
- 이후는 connection context로 처리

같은 식으로 최적화가 가능.

(물론 gRPC도 request 단위 인증이 가능하지만, connection 기반 최적화가 더 자연스러움)

#### 3) 서버 측 캐싱/컨텍스트 축적

RPC는 “이 사용자가 지금 뭘 하고 있는지”를 알고 있으면 최적화가 가능함.

예를 들어
- 추천 시스템에서 사용자의 최근 행동을 connection/session state로 들고 있음
- 대량 처리에서 partial result를 서버 메모리에 누적함

REST는 매 요청이 독립이라, 이런 최적화를 하려면
- Redis 같은 외부 저장소를 써야 하고
- 결국 네트워크 홉이 추가됨

RPC는 프로세스 메모리에 들고 있으면 더 빠름.

#### 4) Binary Protocol + 강한 스키마

gRPC/Thrift 같은 RPC는 JSON보다 compact한 binary encoding을 쓰는 경우가 많아서:
	•	payload size 감소
	•	parsing 비용 감소
	•	CPU 사용량 감소
	•	GC pressure 감소

이게 대규모 트래픽에서 엄청 큰 차이를 냄.

REST도 protobuf를 쓸 수는 있지만, 관행적으로 JSON이 많고 RPC는 애초에 protobuf-first가 많음.

### 하지만 상태는 “대가”가 있다
“신뢰성 및 라우팅 복잡성 비용”이 여기서 나오는 거고, 진짜 핵심이 이것.

#### 1) 라우팅 복잡성 증가 (Sticky / Affinity 문제)

상태를 서버 메모리에 들면, 그 상태가 있는 서버로 계속 보내야 함.

그러면 로드밸런서가 단순 Round-robin이 아니라
- consistent hashing
- sticky session
- 특정 key 기반 라우팅

을 해야 함. 이게 운영 난이도를 올려.

#### 2) 장애 시 복구가 어려움

REST stateless는 서버 하나 죽어도 상관없음. 다른 서버로 요청 보내면 끝.

근데 RPC가 세션/스트림 상태를 들고 있다?
- 서버 죽음 = 세션 상태 소멸
- 진행 중인 스트림 중단
- partial 처리 결과 날아감

즉, 장애에 더 민감해짐.

#### 3) 확장성(Scale-out)에서 제약

stateless는 서버를 그냥 N대 늘리면 끝인데, stateful RPC는
- 상태를 어디에 둘 것인가?
- 상태를 공유할 것인가?
- 상태를 복제할 것인가?

이 문제가 생김.

결국 Redis/DB 같은 external state store를 두면 되지만, 그러면 다시 REST랑 비슷한 구조가 되고 “stateful의 성능 이점”이 약해짐.

#### 4) Connection 폭증 문제

RPC는 connection을 오래 유지하니까, 클라이언트 수가 많아지면 서버는
- connection context 메모리
- keepalive 관리
- file descriptor 소비

를 엄청나게 쓰게 됨.

즉, QPS는 낮아도 connection이 많으면 서버가 터질 수 있음.

REST는 상대적으로 connection churn이 있어도 connection 자체를 덜 “Stateful”하게 관리할 수 있음.

### 결론: RPC의 “상태 기반 성능”이란?

RPC에서 상태를 가진다는 건 보통
- 연결을 유지하고
- 컨텍스트를 메모리에 저장하고
- 반복되는 작업(인증/파싱/라우팅)을 줄이고
- 스트리밍 및 멀티플렉싱으로 네트워크 효율을 끌어올리는 것

이렇게 해서 성능을 얻는다는 뜻.

대신 그 상태는
- sticky routing 필요
- 장애 복구 어려움
- scaling 설계 난이도 증가
- connection 관리 부담 증가

같은 비용을 가져옴.

결론적으로, RPC는 “서버가 기억해주기 때문에 빠른 호출”이 가능하지만, 그 기억 때문에 “운영이 복잡해지고 장애에 취약해질 수 있다”.