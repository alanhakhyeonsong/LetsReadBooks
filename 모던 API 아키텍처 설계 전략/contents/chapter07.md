# 7장. API의 인증과 인가
## 인증
인증은 신원을 확인하는 동작.
- 참석자 API는 이름이나 이메일 주소 같은 개인 식별 정보를 보관하고 있으며 사용자는 이런 정보가 안전하게 보호되기를 원함.
- API 호출자가 누구인가? 사용자의 신원을 확인하는 것을 인증.
- 호출자가 인증되면 참석자 API는 호출자가 어떤 정보에 접근하고 조회할 수 있는지를 확인. 자격 확인을 인가.

### 토큰을 이용한 최종 사용자 인증
사용자가 입력한 사용자 이름과 비밀번호를 토큰으로 교환하게 한다. 토큰 발급 구현의 가장 간단한 방법은 알아보기 힘든 문자열을 사용하는 것. 이 토큰은 REST 요청의 Bearer Authentication Header를 통해 전달.  
이 토큰은 민감 정보이므로 이 정보를 포함한 REST 요청은 HTTPS를 이용해 안전하게 전송해야 한다. 요청에 포함되어 전달한 토큰에 대해선 그 유효성을 검증해야 한다.
- 토큰의 수명은 제한적이어야 하며 토큰이 만료되면 사용자는 새로운 토큰을 얻어야 함.
- 토큰 사용의 장점은 비밀번호처럼 장기간 보존하는 자격 데이터를 매번 네트워크 통과 요청에 포함시킬 필요가 없음.
- 가장 큰 단점은 사용자가 입력한 사용자 이름과 비밀번호가 데이터를 조회하는 API에 전달된다는 점.
- 토큰이 저장소에 생성되면 이 토큰의 유효성을 매번 처리해야 하므로 성능상의 문제가 발생할 수 있음.

더 적합한 방법은 인 프로세스에서 무결성을 검증할 수 있는 토큰을 사용하는 것.

### 시스템 간 인증
**사용자는 관여하지 않고 시스템이 다른 시스템과 통신해야 하는 경우.**  
API Key를 이용한다. (표준화된 방법은 아니지만)

- 암호학적으로 안전한 난수 생성기로 예측할 수 없는 길이의 값을 생성해서 API Key로 사용한다.
- 보통 32문자 길이의 문자열(256bit)를 사용.
- 예측 가능하다면 취약점이 됨.
- API Key로 API에 접근하려면 요청 헤더에 key를 추가해 엔드포인트에 전달하면 된다.

### 키와 사용자를 혼합하면 안 되는 이유
모든 요청의 자격증명 공유 문제

## OAuth2
OAuth2는 사용자가 서드파티 애플리케이션이 본인을 대신해 데이터에 접근하는 것에 동의하도록 설계되었다. **사용자의 동의가 바로 인가, 즉 데이터에 대한 접근을 허용 또는 거부하는 것이다.** OAuth2는 사용자가 데이터를 제어할 수 있는 본인의 자격증명을 서드파티와 공유할 필요가 없다.

- 리소스 소유자(resource owner)
  - 보호된 리소스에 접근을 승인할 능력을 가진 엔티티. 리소스 소유자가 사람이라면 최종 사용자라고 볼 수 있다.
- 인가 서버(authorization server)
  - 리소스 소유자를 성공적으로 인증하고 인가를 얻은 후 클라이언트에 엑세스 토큰을 발급하는 서버. Google이나 Auth0 같은 대부분의 IdP는 OAuth2 인가 서버다.
- 클라이언트(client)
  - 인가 정보를 이용해 리소스 소유자를 대신해 보호된 리소스에 요청을 보내는 애플리케이션.
- 리소스 서버(resource server)
  - 보호된 리소스를 호스팅하는 서버로, 액세스 토큰을 이용해 보호된 리소스에 대한 요청을 수신하고 응답을 리턴한다.

더 자세한 사항은 [OAuth2 명세](https://datatracker.ietf.org/doc/html/rfc6749#section-1.1)를 참고할 것.

### API 사용 시 인가 서버의 역할
인가 서버는 2개의 엔드포인트를 제공한다.
- 리소스 소유자가 보호된 리소스에 대한 접근을 인가받아야 할 때 사용하는 인가 엔드포인트
- 클라이언트가 액세스 토큰을 얻고자 할 때 사용하는 엔드포인트

리소스 서버는 개별 애플리케이션일 필요는 없으며 전체 시스템을 의미할 수도 있다. 보편적인 패턴 중 하나는 API GW를 리소스 서버로 사용하는 패턴이다.

### JWT
JSON Web Token은 [RFC 표준](https://datatracker.ietf.org/doc/html/rfc7519) 토큰 형식으로, OAuth2에서 사실상 표준으로 자리 잡은 토큰이다.
- JWT는 claim으로 구성하며 각 클레임은 관련된 값을 저장한다.
- 표준을 이용해 구성하고 인코딩하므로 수정이 불가하며 암호화를 적용할 수도 있다.
- HTTP Authorization 헤더처럼 공간적 제약이 있는 환경(https://datatracker.ietf.org/doc/html/rfc7519#section-1)에서 정보를 전달할 때 특히 유용하다.
- 예약된 클레임은 특별한 의미를 가지며, 토큰에 반드시 포함되어야 하는 것은 아니지만 최소한의 정보를 제공하는 시작점 역할을 수행한다.

클레임의 약어와 그 의미는 아래와 같다.
- `iss` (issuer) : 이 토큰을 발급한 기관을 의미. 보통은 신원 제공자의 이름을 기록. (eg. Google, Auth0, ...)
- `sub` (subject) : JWT의 자격증명을 구분하는 고유 식별자. 이 값에는 특별한 형식이 정해져 있지 않으므로 이 값을 스스로 정해야 한다면 시스템 내에서나 전역적으로 유일한 값(eg. UUID)을 사용해야 한다.
- `aud` (audience) : 토큰의 발급 대상
- `exp` (expiration time) : 이 토큰이 만료되는 시점
- `nbf` (not before) : 토큰은 이 시간 전에 사용해서는 안 된다.
- `iat` (issued at) : 토큰을 발급한 시간
- `jti` (JWT ID) : JWT의 고유한 식별자

토큰에는 선호하는 이름, 사용자의 이메일, 발급자에 대한 클레임, 토큰을 요청한 애플리케이션 등 다양한 정보를 담을 수 있다. 고도의 보안을 갖춘 API에선 인가 서버의 인증 방식을 담는 것이 보통이며, 이 값을 이용해 리소스 소유자가 인증을 받을 때 MFA를 사용했는지 여부 등을 확인하기도 한다.

#### JSON 웹 토큰의 인코딩과 검증
각자의 형식을 가진 두 가지 방법이 보편적.
- [JSON Web Signatures(JWS)](https://datatracker.ietf.org/doc/html/rfc7515)는 JWT의 무결성을 제공한다. 토큰의 콘텐츠는 토큰을 수신한 누구든 볼 수 있다. 하지만 클레임이 디지털적으로 서명되어 있어 토큰의 콘텐츠가 바뀌면 토큰은 그 즉시 무효화된다.
- [JSON Web Encryption(JWE)](https://datatracker.ietf.org/doc/html/rfc7516)는 무결성을 제공하는 동시에 암호화되어 있다. 즉 토큰의 콘텐츠를 확인할 수 없다.

가장 보편적으로 사용하는 메커니즘은 JWS로 비공개 키를 이용해 디지털 서명을 수행하는 방법이다. 공개 키는 토큰 수신자가 특정 발급자가 서명한 토큰인지 확인하는 용도로 사용한다.

- JWS를 이용한 JWT를 사용한다면 클레임 값에 중요한 정보를 보관해서는 안 된다. 클레임에 대한 무결성은 제공하지만 JWT를 가진 누구든지 클레임을 읽을 수 있다. JWT를 읽을 수 없게 하려면 JWE를 사용해야 한다.
- API 서비스는 JWT를 소비하고 서명을 검증하므로 DB에서 토큰을 조회할 필요가 없다. 액세스 토큰은 대부분 우리가 제어하는 인가 서버가 제공하므로 필요한 모든 정보를 JWT에 포함할 수 있다.

JWT를 수신하면 검증해야 할 부분이 여럿 있다.
- 서명 부분은 원하는 발급자가 발급했으며 수정되지 않았는지 확인
- 토큰이 만료되진 않았는지 또는 허용된 시간 이전에 사용되고 있지는 않은지
- 발행된 모든 토큰은 반드시 짧은 기간에만 유효해야 한다.
  - 공식적인 표준은 없으나 단기 토큰은 1~60분, 장기 토큰은 1~10년을 권장하며 수명은 가능한 한 짧게 유지할 것.

### OAuth2 승인 관련 메커니즘과 용어
<img width="575" height="397" alt="Image" src="https://github.com/user-attachments/assets/c9fb0611-1fad-467e-84be-49a20c673c91" />

1. 클라이언트가 리소스 소유자로부터 인가를 요청
2. 리소스 소유자는 그 리소스에 대한 클라이언트의 접근을 승인 또는 거부
3. 클라이언트는 인가 정보를 가진 액세스 토큰을 인가 서버에 요청
4. 인가 서버는 클라이언트가 리소스 소유자로부터 인가를 받았다면 액세스 토큰을 발행
5. 클라이언트는 리소스 서버에 리소스를 요청
6. 리소스 서버는 액세스 토큰이 유효하면 리소스를 리턴

### 인가 코드 승인
[인가 코드 승인(Authorization Code Grant)](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1)은 OAuth2 승인의 구현체 중 하나로, 앞서 살펴본 추상 프로토콜을 구현하고 있다. 이능 가장 잘 알려진 승인 방식이며 우리도 알지 못한 채 사용해봤을 가능성이 크다.

<img width="672" height="610" alt="Image" src="https://github.com/user-attachments/assets/f2d9d54a-6302-4fe4-8db3-8b07a2170982" />

1. 클라이언트 애플리케이션은 웹 브라우저를 인가 서버로 안내한다. 인가 서버로의 리다이렉션에는 클라이언트의 신원(클라이언트 ID)이 포함되어 있으며, 리다이렉션에 어떤 승인을 사용할 것인지도 포함되어 있다.(이 경우 인가 코드 승인은 코드로 표현되어 있다.)
2. 인가 서버는 리소스 소유자(최종 사용자)에게 자신의 신원을 확인해 줄 것을 요청한다. 인가 서버가 리소스 소유자가 누구인지 알아야 리소스 소유자가 인가 서버에 인증을 받을 수 있다. 그런 후 인가 서버는 리소스 쇼유자가 클라이언트 애플리케이션의 승인을 인가할 것인지 동의를 얻게 된다.
3. 인가가 승인됐다면 유저 에이전트를 통해 인가 코드가 클라이언트 애플리케이션에 전달된다.
4. 이제 클라이언트는 인가 서버에게 인가 코드를 표현하는 액세스 토큰을 요청한다. 인가 서버는 아무데서나 인가 코드를 수신할 수 없다. 클라이언트 애플리케이션은 인가 서버와 클라이언트 애플리케이션이 모두 알고 있는 암호를 이용해 스스로를 인증해야 한다.
5. 클라이언트 애플리케이션의 인증이 성공하고 유효한 인가 코드를 제공했다면 액세스 토큰을 얻게 된다.

SPA 웹사이트는 JS로 구현하며 사용자의 브라우저에서 실행된다. 이는 소스 코드가 완전히 노출된다는 뜻이다. 또한 OAuth2 클라이언트 SPA는 암호를 보호할 수 없는데다 공개 클라이언트로 알려져 있어 인가 코드 승인을 그대로 사용하는 것은 불가능하다.

#### 인가 코드 승인(+ PKCE)
인가 코드 승인 + [PKCE](https://datatracker.ietf.org/doc/html/rfc7636#section-1.1)를 이용하면 SPA 애플리케이션에서 OAuth2를 사용할 수 있다.

- Proof Key for Code Exchange
- 가로채기 공격을 완화하기 위한 목적으로 사용.
- 2개의 추가적인 파라미터가 필요.
  - 인가 요청의 `code_challenge` : `code_verifier` 파라미터 값의 해시 값.
  - 액세스 토큰 요청의 `code_verifier` : 클라이언트가 암호학적으로 임의로 생성한 문자열.
- 클라이언트 애플리케이션은 인가 서버로 요청을 전달할 때 `code_challenge` 파라미터를 함께 보내고, 액세스 토큰을 요청할 때는 `code_verifier` 파라미터에 인가 코드를 제공한다.
- 인가 서버는 `code_verifier` 파라미터 값을 해시해서 토큰 요청의 `code_challenge` 파라미터에 사용한 값과 일치하는지 확인한다.

**원래의 클라이언트만 `code_verifier` 값을 갖고 있으므로 이 방식을 이용하면 승인을 더 안전하게 구현할 수 있다.** 또한 액세스 토큰을 요청할 때 인가 코드를 가로채 바꾸는 공격을 방지할 수도 있다.

<img width="628" height="385" alt="Image" src="https://github.com/user-attachments/assets/afe2f4bd-cf8d-4c27-bd74-4c41d69e813c" />

1. `code_verifier` 파라미터를 포함한 인가 요청이 인가 서버로 전달된다. `t(code_verifier)`는 `code_verifier`를 `code_challenge`로 변환하는 과정이며, `t_m`은 변환 메서드다.
2. 인가 코드 승인과 마찬가지로 인가 코드가 리턴된다.
3. 클라이언트가 인가 요청을 보내 액세스 토큰을 요청한다. 이때 인가 요청에는 인가 코드와 `code_verifier` 파라미터가 전달된다. 공개 클라이언트이므로 클라이언트 암호는 보내지 않는다.
4. 액세스 토큰이 클라이언트 애플리케이션에 발급된다.

### 리프레시 토큰
토큰을 발급할 때 유효 기간은 짧게 설정하는 것이 좋다. 하지만 사용자에게 이름과 비밀번호를 다시 입력하라고 요구하는 것은 그다지 좋지 않은 UX가 될 것이다.  
- 리프레시 토큰은 유효 기간이 긴 토큰으로, 클라이언트가 기존 토큰이 만료되어 새로운 액세스 토큰을 요청할 때 사용한다. 리프레시 토큰은 인가 요청에 포함된다. **즉 추가 액세스 토큰의 요청에 최종 사용자가 개입하지 않아도 된다는 뜻이다.**
- 리프레시 토큰은 별개의 자격증명이며 유효 기간이 기므로 유출되지 않도록 안전하게 보관하는 것이 중요.
- 리소스 소유자가 클라이언트가 더 이상 리소스에 접근하는 것을 원치 않는 경우를 비롯해 클라이언트의 접근이 어느 순간에 거부되면 리프레시 토큰도 폐기된다. 그러면 다음번에 클라이언트 애플리케이션이 새로운 액세스 토큰을 요청해도 받아들여지지 않는다.

### 클라이언트 자격증명 승인
[Client Credential Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.4)의 클라이언트는 암호를 관리해야 하므로 신뢰할 수 있는 클라이언트여야 한다. 이는 머신간 커뮤니케이션이므로 연결이 미리 이뤄지며 클라이언트가 인가를 수행하는 접근 권한도 미리 설정되어 있다.

<img width="631" height="200" alt="Image" src="https://github.com/user-attachments/assets/e83c3d91-6aac-4706-ab0c-a95129fb9660" />

1. 클라이언트 애플리케이션은 인가 서버를 이용해 인증을 수행하고 액세스 토큰을 요청한다. 또한 클라이언트는 `client_credentials` 매개변수에 지정한 승인 정보를 식별한다.
2. 인가 서버는 클라이언트 애플리케이션을 인증하고 액세스 토큰을 리턴한다.

이 과정엔 권한을 허용하는 리소스 소유자가 없으므로 다른 절차는 필요하지 않다. 클라이언트는 다른 사용자를 대신하지 않으므로 클라이언트 자체만 인증하면 된다.

### 추가 OAuth2 승인
- Device Authorization Grant는 입력이 제한적이거나 브라우저가 없는 장치를 위한 방식이다. IoT 장치에 유용.
- SPA는 보통 암시적 승인(Implicit Grant)을 사용했지만 이제는 인가 코드 승인 + PKCE로 점차 대체되었다.
- 리소스 소유자 비밀번호 자격증명 승인(Resource Owner Password Credentials Grant)은 HTTP 기본 인증을 사용하던 클라이언트 애플리케이션을 OAuth2로 전환할 때 사용해왔다. 하지만 이 승인을 사용하는 것은 권장되지 않는다.

### 인가의 수행
인가는 API 보안의 기본이므로 반드시 수행해야 한다.
- 보통 어떤 종류의 자격을 기반으로 한다.
  - [RBAC](https://www.okta.com/en-gb/identity-101/what-is-role-based-access-control-rbac/)
- 정확한 자격 선택은 세부 사항이지만 접근 제어는 어떤 형태로든 존재해야 하며 모든 엔드포인트가 요청을 처리하기 전에 인가 정보를 확인하는 것이 중요하다.

OAuth2를 사용해 인가를 검토할 때 리소스 소유자는 범위를 이용해 클라이언트가 수행할 수 있는 작업을 나열한다는 점을 염두에 둘 필요가 있다. 이는 클라이언트가 최종 사용자의 모든 데이터에 접근해야 한다는 것을 의미하지 않는다.

## OIDC
OAuth2는 클라이언트가 인증과 인가를 이용해 API에 접근하게 하는 메커니즘을 제공한다. 이를 위한 보편적인 요구사항은 클라이언트가 리소스 소유자의 신원을 알아야 한다는 것이다.
- eg) 외부 CFP 시스템의 입장에선 발표자 데이터를 저장할 필요가 있지만, OAuth2 승인은 최종 사용자의 신원을 확인할 수 있는 방법을 제공하지 않는다.

바로 이것이 [OpenID Connect(OIDC)](https://openid.net/developers/how-connect-works/)의 목적이다.
- **신원 계층을 제공하는 것**
- 이 계층은 OAuth2상에 구현되며 OAuth2 인가 서버가 추가 기능을 구현하게끔 한다.
- 이 기능을 구현한 OAuth2 인가 서버는 OpenID 제공자 역할을 하게 된다.
- 클라이언트는 `openid`라는 특별한 범위를 이용해 사용자 정보를 요청할 수 있게 된다. 이 범위는 액세스 토큰에 명시된 다른 범위와 함께 요청에 포함된다.
- `openid` 범위를 사용하면 클라이언트는 사용자와 관련된 클레임을 담은 ID 토큰을 얻을 수 있다.
- `openid` 범위만 사용할 때 리턴되는 ID 토큰은 사용자에 대한 매우 제한된 정보만을 포함한다. 사용자를 식별하는 유일한 클레임은 `subject` 클레임이며 이는 사용자의 고유 ID로 절대 변경하면 안 된다.

OIDC는 ID 토큰의 정보를 얻기 위해 요청에 추가할 수 있는 추가 범위를 지정하고 있다.
- `profile` : `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, `updated_at` 필드
- `email` : `email`과 `email_verified` 필드
- `address` : `address` 필드
- `phone` : `phone_number`와 `phone_number_verified` 필드

위 범위는 액세스 토큰에서는 찾을 수 없다.

OIDC는 인가 코드 흐름(Authorization Code Flow), 암시적 흐름(Implicit Flow), 하이브리드 흐름(Hybrid Flow)이라는 3가지 흐름을 정의하고 있다. OIDC 명세는 ID 토큰의 '흐름'을 얻는 단계를 호출한다. 인가 코드 승인과 마찬가지 이유로 인가 코드 흐름을 사용하는 것이 가장 안전하다.

OAuth2와 OIDC를 같은 것으로 생각하고 API에 접근하는 데 사용하는 방식을 OIDC라 말하는데 서로 다른 것이다.
- OIDC는 클라이언트에 사용자 신원을 제공하는 역할. API에 대한 접근은 제공하지 않는다.

## SAML 2.0
엔터프라이즈 환경에서는 SAML 2.0을 사용하는 것이 보편적이며 보통은 SAML이라 부른다.
- Security Assertion Markup Language
- assertion을 이전하는 개방 표준
- single sign on에 사용하며 이때 이전하는 어설션은 사용자의 신원
- 임직원이 외부 애플리케이션에 로그인하는 것을 허용하기 때문에 엔터프라이즈 환경에서 매우 보편적으로 사용하고 있다.
- 원래 API가 사용하기 위한 것은 아니었지만 OAuth 2.0 클라이언트 인증 및 인가 승인을 위한 SAML 2.0 프로파일 확장 기능에 정의되어 있다.
  - https://datatracker.ietf.org/doc/html/rfc7522
  - 인가 서버에 해당 기능이 구현되어 있다는 가정하에 클라이언트가 SAML을 이용해 액세스 토큰을 요청하는 것을 허용한다.
  - OAuth2 마이그레이션에 SAML이 필요하다면 반드시 기억하자.

## 정리
- 인증은 리소스 소유자의 신원을 확인하는 것으로, API에선 최종 사용자일 수도 있고 시스템 간 통신을 수행할 수 있는 애플리케이션일 수도 있다.
- OAuth2는 Bearer Header에 JWT를 사용해 API를 보호하는 사실상의 표준 방식이다. JWT 토큰은 악의적인 조작이 불가능하도록 인코딩 및 사인이 되어 있다.
- OAuth2 승인은 여러 시나리오를 지원한다. 가장 보편적인 것은 인가 코드 승인 + PKCE와 클라이언트 자격증명 승인이다.
- 리프레시 토큰은 사용자에게 로그인 이름과 비밀번호를 계속 요구할 필요 없이 최종 사용자에게 더 나은 경험을 제공한다.
- OAuth2 범위는 잘 분리된 권한을 제공하며 최종 사용자가 클라이언트의 접근을 설정할 수 있는 기능을 제공한다.
- OIDC는 클라이언트가 최종 사용자 정보를 필요로 할 때 사용한다. OIDC는 인증된 사용자에 대한 기본적인 정보를 제공하며 선택적으로 추가 정보도 제공할 수 있다.