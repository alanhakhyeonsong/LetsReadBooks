# Chapter 2. 이벤트 기반 마이크로서비스 기초
**이벤트 기반 마이크로서비스는 특정한 경계 콘텍스트를 구현하기 위해 개발된 작은 애플리케이션이다.** 컨슈머 마이크로서비스는 하나 이상의 입력 이벤트 스트림으로부터 이벤트를 소비/처리하고, 프로듀서 마이크로서비스는 다른 서비스가 소비할 수 있게 이벤트 스트림에 이벤트를 생산한다. **일반적으로 이벤트 기반 마이크로서비스는 입력 이벤트 스트림 중 하나의 컨슈머인 동시에 다른 출력 이벤트 스트림 중 하나의 프로듀서 역할을 한다.** 이벤트 기반 마이크로서비스는 이벤트 브로커에서 이벤트를 생산/소비하는 공통 기능을 공유하며 완전한 비동기 방식으로 서로 통신한다.

## 토폴로지 구성
토폴로지는 개별 마이크로서비스의 처리 로직을 의미하지만 마이크로서비스, 이벤트 스트림, 요청-응답 API 간의 뒤얽힌 관계를 나타내기도 한다.

### 마이크로서비스 토폴로지
마이크로서비스 토폴로지는 마이크로서비스 내부의 이벤트 기반 토폴로지다. 변환, 저장, 방출 등 인입된 이벤트에 수행할 데이터 주도 연산을 정의한다.

<img width="571" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/5846373b-53ab-42c6-bc9a-1dae573b12d0">

이 마이크로서비스 토폴로지는 이벤트 스트림 A에서 이벤트를 받아 데이터 저장소에 구체화하고, 이벤트 스트림 B에서 받은 데이터는 어떤 조건에 맞는 이벤트를 거르고 변환한 다음 저장된 상태와 조인해서 새로운 이벤트 스트림으로 내보낸다. 마이크로서비스가 이벤트를 인입, 처리, 출력하는 행위가 바로 이 토폴로지의 구성 요소다.

### 비즈니스 토폴로지
비즈니스 토폴로지는 복잡한 비즈니스 로직을 처리하는 마이크로서비스, 이벤트 스트림, API 집합이다.

이는 서비스를 임의로 그룹핑한 것으로, 하나의 팀/부서가 소유한 서비스나 복잡한 비즈니스 기능의 상위 집합을 수행하는 서비스를 나타낸다. 마이크로서비스는 비즈니스 경계 콘텍스트를 구현하며 이벤트 스트림은 전체 콘텍스트의 도메인 데이터를 공유하기 위해 필요한 데이터 통신 수단이다.

<img width="562" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/b9c27e95-2156-4cf6-8ed1-d86e49b48ec0">

위 예시에서 마이크로서비스 1은 이벤트 스트림 A 데이터를 소비/변환한 뒤 그 결과를 이벤트 스트림 B로 보내고, 마이크로서비스 2, 3은 이벤트 스트림 B에서 이벤트를 소비한다. 마이크로서비스 2는 컨슈머 역할만 수행하면서 데이터를 동기식으로 접근할 수 있는 REST API를 제공하고, 마이크로서비스 3은 경계 콘텍스트 요건에 따라 자체 변환한 결과를 이벤트 스트림 C로 보낸다. 새 마이크로서비스와 새 이벤트 스트림은 필요한 만큼 추가해서 이벤트 스트림을 통해 비동기 방식으로 결합할 수 있다.

## 이벤트 콘텐츠
이벤트는 비즈니스 통신 구조 범위에서 발생한 무엇이라도 가능하다. 비즈니스에 중요한 일이라면 어떤 것이라도 이벤트가 될 수 있다. 이를 잘 수집해두면 조직 전반에 걸쳐 이벤트를 유용하게 활용할 수 있는 이벤트 기반 시스템을 구축할 수 있다.

이벤트는 발생한 사건의 기록물이다. 애플리케이션 프로그램에서 벌어지는 모든 일이 로그에 기록되는 것과 비슷하다. 단, 이벤트는 로그와 달리 기록물이면서 단일 진실 공급원이라는 차이점이 있다. 이벤트는 발생한 사건을 정확하게 나타내기 위해 필요한 모든 정보를 담아야 한다.

## 이벤트 구조
이벤트는 보통 키/값 포맷으로 표현한다. 이벤트의 전체 세부 정보는 값에 보관하고, 키는 식별, 라우팅, 그리고 같은 키를 가진 이벤트를 집계하는 작업에 사용한다. 이벤트 종류에 상관없이 키는 필수 필드가 아니다.

|키|값|
|--|--|
|유일 ID|유일 ID에 해당하는 세부 정보|

### 키 없는 이벤트
키 없는 이벤트는 하나의 사실을 진술한 형태로 나타낸 이벤트다. 이 이벤트는 키가 없다.

|키|값|
|--|--|
|N/A|ISBN: 372719, Timestamp: 1538913600|

### 엔티티 이벤트
엔티티는 유일한 것으로 유일한 ID가 키로 부여된다. 엔티티 이벤트는 어느 시점의 엔티티 속성 및 상태를 기술한다.

|키|값|
|--|--|
|ISBN: 372719|Author: Adam Bellemare|

엔티티 상태의 연속된 이력을 제공하고 상태를 궤화하는 용도로 사용 가능한 엔티티 이벤트는 이벤트 기반 아키텍처에서 특히 중요하다. 엔티티의 현재 상태는 마지막 엔티티 이벤트만 있어도 알 수 있기 때문이다.

### 키 있는 이벤트
키를 포함하지만 엔티티를 나타내진 않는다. 주로 이벤트 스트림의 한 파티션 내에서 데이터 지역성을 보장하기 위해 이벤트 스트림을 파티셔닝하는 용도로 쓰인다.

|키|값|
|--|--|
|ISBN: 372719|UserId: A537FE|
|ISBN: 372719|UserId: BB0012|

이벤트를 키별로 집계하면 ISBN별 사용자 리스트를 구성할 수 있으므로 결국 키가 ISBN인 하나의 엔티티 이벤트로 귀결된다.

## 엔티티 이벤트에서 상태를 구체화
엔티티 이벤트 스트림에서 흘로온 엔티티 이벤트를 순서대로 적용하면 상태 저장 테이블을 구체화할 수 있다. 각 엔티티 이벤트는 키/값 테이블에 업서트되므로 키별로 가장 최근에 읽은 이벤트를 알 수 있다. 반대로 각 업데이트를 이벤트 스트림에 발행하여 테이블을 엔티티 이벤트의 스트림으로 바꿀 수도 있다. 이를 테이블-스트림 이원성이라 하며 이벤트 기반 마이크로서비스에서 상태를 생성하는 기본 원리다.

<img width="533" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/ea65f22b-2b4c-4617-945b-7f2a6708ca57">

같은 방법으로, 테이블의 모든 업데이트를 테이블에 기록하여 시간에 따른 테이블 상태를 나타내는 데이터 스트림을 생산할 수 있다.

<img width="566" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/6c09d1b8-acea-4bc6-aaf8-021440b93230">

관계형 DB에서 테이블은 일련의 생성, 수정, 삭제 커맨드를 통해 레코드를 관리한다. 이들 커맨드는 로컬 붙임 전용 파일(ex. MySQL binlog)이나 외부 이벤트 스트림처럼 불변 로그에 대한 이벤트로 생산할 수 있다. 전체 로그 콘텐츠를 재생하면 테이블과 그 내부의 데이터를 모두 정확하게 되살리는 게 가능하다.

**키 있는 이벤트는 툼스톤 이벤트(값을 null로 설정한 키 있는 이벤트)를 만들어 삭제한다.** 이는 업스트림 프로듀서가 어떤 키를 가진 이벤트가 삭제 대상이라 선언했으니 구체화한 데이터 저장소에서 삭제해야 한다는 사실을 다운스트림 컨슈머에게 알려주는 일종의 관례다.

붙임 전용 불변 로그는 컴팩션을 하지 않으면 무한정 커질 수 있다. 컴팩션은 이벤트 브로커가 내부 로그 크기를 줄이고자 키별로 가장 최근 이벤트 하나만 보관하는 작업이다. 같은 키를 가진 옛 이벤트는 삭제하고 살아남은 이벤트는 더 작고 새로운 파일들로 압착한다. **이벤트 스트림 오프셋은 컨슈머가 따로 바꾸지 않아도 문제가 없도록 관리한다.**

<img width="569" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/e0990d3a-f9ad-4de3-be32-a0f0740e3b7a">

컴팩션을 수행하면 이벤트 스트림에 쌓인 이벤트 이력은 포기할 수 밖에 없지만 디스크 사용량이 줄고 현재 상태까지 도달하기까지 처리해야 할 이벤트 수도 감소한다.

비즈니스 로직을 처리하기 위해 상태를 유지하는 것은 이벤트 기반 아키텍처에서 지극히 일반적인 패턴이다. 전체 비즈니스 모델이 순수하게 상태를 저장하지 않는 스트리밍 도메인에 꼭 맞을 가능성은 거의 없다. 과거의 비즈니스 결정은 항상 현재의 비즈니스 결정에 영향을 미치기 때문이다.

## 이벤트 데이터 정의와 스키마
**이벤트 데이터는 서비스 간 통신 수단을 비롯해 구현체와 무관한 장기 데이터 보관소 역할을 하기 때문에 이벤트 프로듀서/컨슈머가 데이터의 의미를 똑같이 이해하는 것이 중요하다.** 컨슈머가 서비스를 생산하는 프로듀서에게 따로 물어보지 않고도 이벤트 콘텐츠와 의미를 해석할 수 있다면 가장 이상적이다. 이렇게 프로듀서/컨슈머가 서로 원활하게 소통하려면 공통적인 언어가 필요한데, 이는 동기식 요청-응답 서비스 간의 API 정의와 비슷하다.

Apach Avro, Google Protobof 같은 스키마화 기술은 이벤트 기반 마이크로서비스에서 아주 많이 쓰이는 두 가지 기능을 제공한다.

- 다운스트림 컨슈머가 코드를 변경하지 않아도 주어진 스키마 벼경을 안전하게 처리할 수 있는 진화 프레임워크 역할을 한다.
- 스키마화 데이터를 우리가 선택한 언어의 일반 객체로 변환할 때 필요한 타입이 정해진 클래스를 생성한다.

결과적으로 마이크로서비스 개발 시 비즈니스 로직을 더 단순하고 투명하게 만들 수 있다.

## 마이크로서비스 단일 작성자 원칙
이벤트 스트림은 정확히 하나의 그 스트림에 생산된 이벤트의 소유자에 해당하는 생산 마이크로서비스를 가진다. 그래서 어떤 이벤트라도 시스템을 흘러가는 데이터 계통을 따라가면 그 이벤트의 진실 공급원을 파악할 수 있다.

## 마이크로서비스를 이벤트 브로커로 강화
**이벤트 브로커는 프로덕션에서 바로 서비스 가능한 이벤트 기반 마이크로서비스 플랫폼의 핵심이다.** 이벤트 브로커는 이벤트를 받아 큐 또는 파티션된 이벤트 스트림에 저장하고 이렇게 저장된 이벤트를 다른 프로세스가 소비할 수 있도록 제공한다. 일반적으로 이벤트는 하부의 논리적 의미에 따라 여러 스트림으로 나누어 발행되는데, 이는 DB에서 특정 타입의 데이터를 포함하도록 논리적으로 분리된 테이블을 여럿 두는 것과 유사하다.

다수의 분산된 이벤트 브로커는 한 클러스터로 동작하면서 이벤트 스트림의 생산/소비 플랫폼을 제공한다. 이는 이벤트 기반 체계를 대규모로 운영할 수 있도록 몇 가지 필수적인 기능을 제공한다.

- 확장성
- 보존성
- 고가용성
- 고성능

이벤트 브로커가 물밑에서 이벤트 데이터를 저장, 복제, 접근하는 방법은 조금씩 다르지만 클라이언트에게 제공하는 저장/접근 메커니즘은 모두 동일하다.

### 이벤트 보관 및 처리
브로커가 사용할 내부적으로 기반이 되는 데이터 스토리지의 최소 요건은 다음과 같다.

- 파티셔닝
- 순서 보장
- 불변성
- 인덱싱
- 무기한 보존
- 재연성

추가적인 고려서항은 다음과 같다.

- 지원 도구
  - 이벤트와 스키마 데이터 조회
  - 쿼터, 접근 제어, 토픽 관리
  - 모니터링, 처리량, 컨슈머 랙 측정
- 호스티드 서비스
- 클라이언트 라이브러리와 처리 프레임워크
- 커뮤니티 지원
- 장기 계층형 스토리지

## 이벤트 브로커 대 메시지 브로커
메시지 브로커는 이벤트 브로커의 기능을 완전히 대체할 수 없다.

메시지 브로커는 발행/구독 메시지 큐를 통해 네트워크 전체를 통신할 수 있다. 프로듀서가 큐에 메시지를 쓰면 컨슈머는 메시지를 받아 적절히 처리하고 메시지가 소비된 것으로 ACK되면 즉시 또는 짧은 시간 내에 삭제되는 구조다. 이는 처음부터 이벤트 브로커와는 다른 종류의 문제를 처리하고자 설계됐다.

**이벤트 브로커는 순서대로 쌓은 사실 로그를 제공할 목적으로 설계되었고 메시지 브로커로는 불가능한 두 가지 구체적인 요건을 충족시킨다.**

- 메시지 큐만 제공하는 메시지 브로커에서 메시지는 큐 단위로 처리되므로 여러 컨슈머가 같은 큐를 소비해도 각자 레코드의 하위 집합만 받을 수 있다. 각 컨슈머는 모든 이벤트의 전체 사본을 얻을 수가 없고 이벤트만 갖고서 상태를 정확하게 통신할 수 없다. 반면, 이벤트 브로커는 레코드 장부를 딱 하나만 보관하고 인덱스를 통해 개별 액세스를 관리하기 때문에 독립적인 여러 컨슈머가 각자 필요한 이벤트를 마음대로 꺼내갈 수 있다.
- 메시지 브로커는 ACK를 받고 이벤트를 바로 삭제하지만 이벤트 브로커는 업무상 필요한 시간 동안 이벤트를 보존할 수 있다. 메시지 브로커는 소비 직후 이벤트를 삭제하므로 모든 애플리케이션에 대해 무기한 보관되고 전역 접근이 가능하면서 재연 가능한 단일 진실 공급원을 제공할 수 없다.

### 불변 로그에서 소비
**명확한 표준은 따로 없지만 이벤트 브로커는 일반적으로 붙임 전용 불변 로그를 사용한다.** 이벤트는 로그 끝부분에 추가되고 자동증가 인덱스 ID가 부여된다. 컨슈머는 이 인덱스 ID가 가리키는 위치부터 접근해서 비즈니스 요건 및 이벤트 브로커에서 사용 가능한 기능 여부에 따라 이벤트 스트림이나 큐로 이벤트를 소비한다.

#### 이벤트 스트림으로 소비
각 컨슈머는 이벤트 스트림에서 이전에 읽은 인덱스를 가리키는 자신만의 위치를 알아서 업데이트한다. 이 인덱스가 바로 현재 이벤트가 이벤트 스트림의 처음부터 몇 번째인지 나타내는 오프셋이다. 오프셋 덕에 여러 컨슈머가 이벤트 스트림에 접속해도 서로 독립적으로 데이터를 소비하면서 진행 상황을 추적할 수 있다.

<img width="540" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/98e48d5f-7696-4719-a4a0-49699a5e69bb">

**컨슈머 그룹은 여러 컨슈머를 하나의 동일한 엔티티로 나타낸 논리적 단위로, 메시지 소비를 수평 확장하는 데 활용된다.** 어떤 컨슈머가 컨슈머 그룹에 새로 들어오면 이벤트 스트림의 파티션을 다시 할당하고 새 컨슈머는 자신에게 할당된 파티션의 이벤트만 소비하며 기존 컨슈머들도 각자 나머지 할당된 파티션의 이벤트를 계속 소비한다. 이런 식으로 동일한 컨슈머 그룹에 대해 이벤트 소비 부하를 분산시킬 수 있고 특정 파티션의 이벤트를 주어진 컨슈머 인스턴스만 독점적으로 소비하도록 보장할 수 있다. 컨슈머 그룹 내 활성 컨슈머 인스턴스 수는 이벤트 스트림의 파티션 수 이하로 제한된다.

#### 큐로 소비
큐로 소비할 경우 각 이벤트는 오직 하나의 마이크로서비스 인스턴스만 소비한다. 이벤트 브로커는 소비가 끝난 이벤트를 '소비됨'으로 표시하고 다른 컨슈머들에게는 제공하지 않는다. 어차피 큐로 소비하면 컨슈머 인스턴스 수는 몇 개라도 소비하는 데 사용할 수 있으니 파티션 수는 중요하지 않다.

큐에서 받은 이벤트는 순서가 보장되지 않는다. 여러 컨슈머가 이벤트를 병렬 소비/처리할 경우, 어떤 컨슈머가 이벤트 처리 도중 실패하면 나중에 처리하기 위해 큐에 반환하고 다음 이벤트로 넘어갈 수도 있기 때문에 순서가 어긋날 수 있다.

### 단일 진실 공급원 제공
저장되는 불변 로그는 단일 진실 공급원에 적합한 저장 메커니즘이다. 이벤트 브로커는 서비스가 데이터를 생산/소비하는 유일한 장소가 되어 모든 컨슈머에게 반드시 똑같은 데이터 사본이 전달된다.

이벤트 브로커가 단일 진실 공급원이 되려면 조직 문화도 달라져야 한다. 전에는 팀마다 직접 SQL 쿼리를 작성해 모놀리스 DB 데이터에 접근해왔겠지만 이젠 모놀리스 데이터도 반드시 이벤트 브로커로 발행해야 한다. 이벤트 스트림과 모놀리스 DB 간의 불일치는 곧 데이터를 생산한 팀의 과실을 의미하므로 모놀리스를 운영하는 개발자는 데이터 정합성이 온전히 유지되는지 확인해야 한다. 더 이상 데이터를 소비하는 컨슈머는 모놀리스에 얽매이지 않고 이벤트 스트림에서 직접 데이터를 갖다 쓰면 된다.

이벤트 기반 마이크로서비스가 정착되면 이벤트 브로커만 있어도 데이터 저장/조회가 가능한 서비스를 개발할 수 있다. 이벤트 브로커는 모든 데이터의 유일한 진실 공급원으로서 기능하고 마이크로서비스는 이벤트 사본을 받아 로컬에서 비즈니스 처리를 하면 된다.

## 대규모 마이크로서비스 관리
마이크로서비스는 서비스가 늘어날수록 점점 더 관리하기 어려워진다. 마이크로서비스마다 필요한 컴퓨팅 리소스, 데이터 스토리지, 구성, 환경 변수, 그밖에 마이크로서비스에 특정한 갖가지 속성이 다른 데다 마이크로서비스를 소유한 팀별로 알아서 관리/배포할 수 있어야 한다. 그래서 **대부분 컨테이너화/가상화 기술을 해당 관리 시스템과 함께 사용하고 팀마다 단일 배포 단위를 통해 마이크로서비스 요건을 커스터마이징 한다.**

### 마이크로서비스를 컨테이너에 넣기
최근 Docker로 컨테이너 기술을 사용하면 애플리케이션을 서로 격리시킬 수 있다. 다수의 컨테이너가 공유 커널 모델을 통해 호스트 OS를 활용하는 한편 환경 변수, 라이브러리, 각종 디펜던시는 각자 설정하는 형태로 구분된다. 컨테이너는 시동 시간이 빠르고 리소스 오버헤드가 작아 적은 비용으로 가상 머신의 장점을 누릴 수 있다.

한편 컨테이너형 애플리케이션은 호스트 OS에서 실행할 수 있어야 하므로 특별한 OS가 필요한 애플리케이션은 독립적인 호스트를 설정해야 한다. 또한 여러 컨테이너가 호스트 머신의 OS 액세스를 공유하는 구조라 보안이 중요하다.

### 마이크로서비스를 가상 머신에 넣기
VM을 쓰면 각 인스턴스를 완벽하게 격리하므로 보안 측면에선 우수하지만 비용은 비싸다.

### 컨테이너와 가상 머신 관리
컨테이너와 VM은 CMS로 관리한다. CMS는 컨테이너 배포, 리소스 할당, 하부 컴퓨팅 리소스와 통합하는 등의 기능을 제공한다. Kubenetes, Docker engine, AWS ECS 등이 있다.

마이크로서비스는 워크로드 변경, 서비스 수준 협약(SLA), 성능 요건에 따라 규모를 늘리고 줄일 수 있어야 한다. CPU, 메모리, 디스크 같은 컴퓨팅 리소스를 조절하는 스케일 업, 인스턴스를 추가/삭제하는 스케일 아웃은 반드시 필요한 기능이다.

**마이크로서비스는 각각 하나의 단위로 배포해야 한다. 비즈니스 요건을 수행하기 위해 실행 파일 하나만 있으면 되기 때문에 단일 컨테이너에 배포할 수 있다.**