# Chapter 9. FaaS 응용 마이크로서비스
서비스로서의 함수(FaaS)는 최근 몇 년간 각광을 받기 시작한 serverless 솔루션이다. FaaS 솔류션을 이용하면 개인이 손수 인프라 오버헤드를 관리하지 않아도 애플리케이션 기능을 구축, 관리, 배포, 확장할 수 있다.

**함수는 특정한 트리거 조건이 발생하면 실행되는 코드 조각이다. 함수가 시작되고 쭉 실행되다 작업이 완료되면 종료된다. FaaS 솔루션은 부하에 맞게 실행 함수 개수를 늘리고 줄이기가 용이해 부하가 매우 가변적인 상황에서도 기민하게 대응할 수 있다.**

정기적으로 실패하는 기본 컨슈머/프로듀서 구현체라고 생각하면 이해가 빠르다. **함수는 미리 정해진 시간이 지나면 항상 종료되며 모든 연관된 연결과 상태도 함께 사라진다. 함수를 설계할 땐 이 부분을 주의해야 한다.**

## 함수 기반 솔루션은 마이크로서비스로 설계
**FaaS 솔루션은 서로 다른 수많은 함수들로 구성되며, 이들이 하는 작업을 합하면 비즈니스 경계 콘텍스트의 솔루션이 된다.**

### 엄격한 경계 콘텍스트의 멤버십 관리
솔루션을 구성하는 함수와 내부 이벤트 스트림은 반드시 어떤 경계 콘텍스트에 속해야 한다. 그래야 함수, 데이터의 소유자가 분명하게 식별된다. 대규모 마이크로서비스로 솔루션을 구축할 경우 기능, 서비스, 이벤트 스트림에 관한 소유권 문제를 잘 따져봐야 한다. 마이크로서비스는 대부분 경계 콘텍스트와 1:1 매핑되며, 여러 함수를 하나의 경계 콘텍스트에서 사용할 수도 있기 때문에 n:1 매핑도 드물지 않다. 함수를 너무 잘게 쪼개면 경계선이 흐려질 수 있으므로 어떤 함수가 어느 경계 콘텍스트에 속하는지 제대로 분간해야 한다.

경계 콘텍스트를 함수로 관리하는 몇 가지 실용적인 방법은 다음과 같다.

- 데이터 저장소를 외부 콘텍스트에서 보이지 않게 보호한다.
- 다른 콘텍스트와 결합할 경우, 표준 요청-응답 또는 이벤트 기반 인터페이스를 사용한다.
- 어떤 함수가 어떤 콘텍스트에 속하는지를 나타낸 메타데이터를 엄격하게 관리한다.
- 경계 콘텍스트에 매핑된 리포지터리 내부에서 함수 코드를 관리한다.

### 처리 완료 이후에만 오프셋 커밋
오프셋은 함수가 시작되거나 처리가 완료될 때 커밋된다. 주어진 이벤트 또는 이벤트 배치가 처리 완료될 이후에만 오프셋을 커밋하는 것이 FaaS의 모범 사례다. 함수 기반 솔루션에서 오프셋을 처리하는 방법은 중요하다.

#### 함수 처리 완료 후 커밋
함수가 처리를 마친 이후 오프셋을 커밋하는 방식은 기본 프로듀서/컨슈머, 스트림 처리 프레임워크 어느 쪽에 기반하는지 상관없이 다른 마이크로서비스 구현체의 오프셋 커밋 방식과 동일하다. 이 방식은 적어도 한 번 이상 처리됨을 가장 강력하게 보장하며 비 FaaS 솔루션에서 사용되는 오프셋 관리 전략과 같다.

#### 함수 처음 시작 시 커밋
이벤트 배치가 함수에 전달된 이후 오프셋을 커밋하는 방식이다. 반복적인 이벤트 처리 실패를 해결하기 위해 프레임워크에 종속적인 재시도 메커니즘과 알림 기능에 의존하는 많은 FaaS 프레임워크에서 사용되는 간단한 방법이다. 이벤트 처리 상황을 추적하기 아주 간단해지므로 코레오그래피 패턴에 따라 다른 함수를 호출하는 함수가 주로 이 방법을 사용한다.

처리가 완료되기 전 오프셋을 커밋하면 다른 문제가 생길 수 있다. 함수가 이벤트를 정상 처리할 수 없게 되어 여러 번 재시도를 한 끝에 실패할 경우 데이터는 손실될 것이다. **이럴 때는 보통 이벤트를 dead-letter queue로 보내거나 그냥 버린다.** 많은 함수 기반 마이크로서비스는 데이터 손실에 민감하지 않지만 민감한 마이크로서비스라면 이 전략은 삼가는게 좋다.

### 적을수록 좋다
FaaS 프레임워크는 단일 함수를 쉽게 작성하고 여러 서비스에 재사용 가능하다는 장점이 자주 부각된다. 하지만 이 방법을 곧이곧대로 따라하면 경계 콘텍스트 안에서 정확히 무슨 일이 벌어지고 있는지 파악하기 곤란한, 매우 파편화된 솔루션이 될 가능성이 높다. 또 함수 소유권이 모호해지며 어느 함수를 변경할 경우 다른 서비스에 어떤 부정적인 영향을 미칠지 불확실해질 수 있다. 이 문제는 함수를 버저닝하면 조금 도움이 되지만 여러 제품에 제각기 다른 버전의 함수를 관리하면 충돌이 일어날 수도 있다.

보통은 FaaS 솔루션은 **잘게 나눈 함수를 여럿 두는 것보다 함수를 적게 두는 편이 낫다.**

## 함수를 마이크로서비스로 개발
어떤 FaaS 프레임워크나 이벤트 브로커 제품을 선택하더라도 함수 기반 솔루션으로 작업할 땐 다음 네 가지 주요 컴포넌트를 반드시 알아둬야 한다.

- 함수
- 입력 이벤트 스트림
- 트리거 로직
- 메타데이터를 이용한 에러 및 확장 정책

FaaS 구현체의 첫 번째 컴포넌트는 바로 함수 자신이다. FaaS 프레임워크에서 지원되는 코드로 다음과 같은 형식이다.

```java
// AWS Lambda도 비슷하다.
public int myFunction(Event[] events, Context context) {
    println ("hello world!");
    return 0;
}
```

처리할 이벤트 배열은 `events` 매개변수에 전달하고 각 이벤트엔 `key`, `value`, `timestamp`, `offset`, `partition_id` 값이 들어 있다. `context` 매개변수엔 함수명, 이벤트 스트림 ID, 함수의 잔여 수명 등 함수 및 그 콘텍스트 정보가 담겨 있다.

다음으로 **함수를 트리거할 로직**을 붙여 넣는다. 트리거 로직은 함수-트리거 맵으로 함수와 연관짓는데, 이런 작업은 FaaS 프레임워크 내부에서 일어난다.

<img width="729" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/404d5428-71b5-4006-9f5f-8bff350c6904">

`myInputStream`에 새 이벤트가 전달될 때마다 `myFunction` 함수가 트리거되도록 설정되어 있다. '정책과 메타데이터' 컬럼엔 다음과 같은 정보들이 들어 있다.

- 컨슈머 그룹
- 컨슈머 프로퍼티
- 재시도 및 에러 처리 정책
- 확장 정책

트리거, 메타데이터, 정책이 정해지면 함수는 이벤트를 처리할 준비를 마친다. FaaS 프레임워크는 새 이벤트가 입력 이벤트 스트림에 도착하면 함수를 트리거해서 이벤트 배치를 넘겨주고 함수는 처리를 개시한다. 작업이 끝나면 함수는 종료되고 더 많은 이벤트가 들어오길 기다린다.

## 콜드 스타트, 웜 스타트
**cold start는 함수가 처음 시작되거나 꽤 오랜 휴지기 이후의 함수 기본 상태다.** 컨테이너를 시작해서 코드를 로드하고, 이벤트 브로커에 연결하고, 필요한 외부 리소스에 클라이언트 접속을 맺는 일련의 작업들을 마치고 처리할 준비가 끝나면 함수는 이벤트 처리를 시작할 수 있는 warm 상태로 바꾼다. **warm 상태의 함수는 이벤트 처리를 시작하고 작업 완료 또는 만료 시 일시 중지되어 동면 상태가 된다.**

대부분의 FaaS 프레임워크는 가능하면 언제나 종료된 함수를 재사용하려고 시도한다. 정상 이벤트 스트림을 처리하는 함수는 타임아웃되어 일시 중지되어 잠깐 멈춰있다가 트리거가 다시 깨우면 일어나게 될 것이다. **그 잠깐 사이에 이벤트 브로커 연결이 끊어지거나 다른 상태 저장소와 접속이 해제되지 않는 한 일시 중지된 인스턴스를 재활용하면 곧바로 처리를 재개할 수 있다.**

## 트리거로 함수 시동
**트리거는 함수에게 처리를 시작하라고 알리는 장본인이다.**

### 새 이벤트에 반응해 트리거: 이벤트-스트림 리스너
**이벤트 스트림에 이벤트가 생성될 때 함수를 트리거한다.** 이벤트 스트림 리스너 트리거는 미리 정의된 컨슈머 배후에서 이벤트 소비를 분리하므로 개발자가 작성해야 할 오버헤드 코드는 많지 않다. **이벤트는 이벤트 스트림에서 순서대로 이벤트 배열 형태로, 또는 큐에서 소비할 경우에는 순서 없는 이벤트의 묶음 형태로 함수에 직접 삽입된다.** 하나의 함수가 여러 스트림에서 이벤트를 소비할 수 있도록 이벤트 스트림과 함수를 다중 매핑할 수도 있다.

<img width="677" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/91bf566a-b876-4a48-9092-e5f142e6071f">

함수 결과는 데이터 출력뿐만 아니라 함수의 성공을 추적하는 용도로 자신의 이벤트 스트림에 출력할 수 있다.  
**동기식으로 트리거하려면 함수가 다음 이벤트를 발행하기 전에 완료되어야 한다.** 처리 순서를 유지하려면 반드시 그렇게 처리해야 하므로 이벤트 스트림을 병렬 처리하는 데 제약이 따른다. 반대로 **비동기 트리거를 사용하면 여러 함수에 여러 이벤트를 전달할 수 있고 각 함수는 작업을 마친 후 다시 결과를 보고한다.** 하지만 이렇게 하면 처리 순서는 유지되지 않기 때문에 비즈니스 로직상 처리 순서가 별로 중요하지 않은 경우에만 사용해야 한다.

배치 크기와 배치 윈도는 스트림 리스너 트리거에게 중요한 속성이다. 배치 크기는 최대 몇 개의 이벤트를 처리하라고 보낼 것인가, 배치 윈도는 함수를 바로 트리거하지 않고 추가 이벤트를 최대 얼마나 오랫동안 기다릴 것인가를 각각 의미한다. 두 매개변수는 함수를 시작하는 오버헤드를 여러 레코드에 분산시켜 비용을 줄이기 위해 사용한다.

```java
public int myEventFunction(Event[] events, Context context) {
    for (Event event : events) {
        try {
            println(event.key + ", " + event.value);
        } catch (Exception e) {
            println("error printing " + event.toString());
        }
    }

    // 배치 처리가 완료됐음을 FaaS 프레임워크에 알림
    context.success();
    return 0;
}
```

### 컨슈머 그룹 랙에 반응해 트리거
컨슈머 그룹의 랙 메트릭도 함수를 트리거하는 또 다른 수단이다. 애플리케이션의 컨슈머 그룹 오프셋을 **주기적으로 폴링**해서 현재 컨슈머 오프셋과 스트림의 헤드 오프셋 간의 차이를 계산하면 랙을 감지할 수 있다. 스트림 리스너 트리거처럼 랙 모니터링 역시 비 FaaS 마이크로서비스를 확장하는 용도로 쓰인다.

랙 메트릭을 계산해서 우리가 선택한 모니터링 프레임워크에 보고하면 모니터링 프레임워크는 FaaS 프레임워크를 호출해서 이벤트 스트림에 등록된 함수를 시작하라고 전달한다. 랙이 크면 부하를 더 빨리 처리해야 하므로 여러 함수 인스턴스를 시작해야 하지만, 반대로 랙이 작 으면 하나의 함수 인스턴스로도 백로그를 처리할 수 있을 것이다. 각 마이크로서비스마다 랙 크기와 함수 시작 간의 관계를 잘 조정해서 SLA를 준수하면 된다.

좀 전의 이벤트 스트림 리스너 트리거와 중요한 차이점은 백으로 트리거할 경우 함수는 자신이 시작될 때까지 이벤트를 소비하지 않는다는 점이다. 랙으로 트리거되어 시작된 함수는 이벤트 브로커와 클라이언트 간 연결, 이벤트 소비, 오프셋 업데이트 커밋 등 알아서 챙겨야 할 일 들이 많다. 수명은 한정되어 있으나 기본 프로듀서/컨슈머 클라이언트에 좀 더 가까운 랙을 사용해 함수를 트리거하는 것이다.

랙 트리거가 함수를 너무 자주 트리거한다면 마지막 실행 이후로 아직 함수가 웜한 상태일 가능성이 높다. 이벤트 브로커 클라이언트에 연결하는 오버헤드는 원인이 아닐 것이다. 물론 클라이언트 및 이벤트 브로커에 설정된 타임아웃에 따라 상황은 달라진다. 함수가 아무 일도 안 하는 시간이 길어질수록 컨슈머 그룹 리밸런스와 클라이언트의 콜드 스타트 때문에 함수 인스턴스가 처리하는 작업량은 조금씩 줄어들 것이다.

### 스케줄에 따라 트리거
일정 주기마다, 지정된 날짜에 함수가 시작되도록 스케줄링할 수도 있다. 스케줄링된 함수는 주기적으로 시작되고 소스 이벤트 스트림을 폴링해서 새 이벤트를 가져오며, 요건에 따라 이벤트를 처리하거나 그대로 종료시킨다. SLA를 유지하려면 폴링 주기는 짧아야 하지만 폴링을 너무 자주하면 FaaS 프레임워크, 이벤트 브로커 모두 과도한 부담이 될 수 있다.

### 웹훅에 반응해 트리거
함수를 직접 호출해서 트리거할 수 있다. 이 경우 모니터링 프레임워크, 스케줄러, 기타 서드파티 애플리케이션과 맞춤 연계가 가능하다.

### 리소스 이벤트에 반응해 트리거
리소스 변경 역시 트리거의 원인이 될 수 있다. 데이터 저장소에서 로우 하나를 생성, 수정, 삭제하는 것처럼 파일 시스템에서 파일 하나를 생성, 수정, 삭제해도 함수를 트리거할 수 있다. 이벤트 기반 마이크로서비스에서 이벤트는 대부분 이벤트 스트림을 거쳐 생성되므로 비즈니스 워크플로에서 특정 리소스에 트리거를 걸어둘 일은 많지 않겠지만, 외부 데이터 소스와 연계할 때 FTP 또는 다른 파일 서비스로 파일을 집어넣어야 할 경우엔 아주 요긴하다.

## 비즈니스 업무를 함수로 처리
**FaaS 접근 방식은 필요한 만큼 유연하게 리소스를 프로비저닝하는 솔루션에 잘 맞는다.** 상태를 저장하지 않고, 여러 이벤트 스트림을 확정적으로 처리할 필요가 없고, 큐 방식으로 처리하는 경우처럼 확장의 폭이 매우 넓은 단순한 토폴로지가 알맞을 가능성이 높다. 뭔가 그 양이 매우 가변적인 경우에는 필요할 때마다 수평 확장이 가능하고 컴퓨팅 리소스를 신속하게 프로비저닝하고 해제할 수 있는 FaaS 솔루션이 여러모로 이점이 많을 것이다.

특히, **FaaS 솔루션은 동시성과 확정성이 관심사가 아닌 경우에 아주 잘 동작한다.** 하지만 어떤 식으로는 확정성이 문제가 된다면 이벤트 스트림 처리의 정확성과 일관성을 고민해야 한다. **기본 컨슈머 솔루션과 마찬가지로 FaaS 솔루션도 일관된 처리 결과를 얻으려면 이벤트 스케줄러를 제공해야 한다.** 코파티션된 데이터는 한 번에 하나의 함수로만 성공적이고 일관되게 처리할 수 있다. 완전한 기능을 갖춘 경량/대용량 프레임워크에서 오직 하나의 스레드만 사용해야 하는 것과 비슷한 원리다.

## 상태 관리
**함수는 수명이 짧아 대부분의 상태 저장 FaaS 기반 솔루션에는 외부 상태 저장 서비스가 필요하다.** 대다수 FaaS 공급사의 목표는 데이터 위치와 상관없이 빠르고 확장성 높은 처리 파워를 제공하는 것이다. 이전 실행의 로컬 상태가 필요한 함수를 사용하면 해당 상태가 위치한 노드에서만 현재 실행을 할 수 있다. 그러면 FaaS 공급사의 유연성이 아주 나빠지기 때문에 일반적으로 no local state 정책을 적용하고 상태 정보는 모두 실행자 외부에 저장하도록 강제한다.

**웜 상태에서 시작된 함수는 이전 로컬 상태를 사용할 수 있지만 반드시 그렇게 된다는 보장은 없다.** 함수는 다른 클라이언트와 마찬가지로 외부 상태 저장소에 접속해 지정된 API로 상태를 사용한다. 어떤 상태든지 상태는 함수가 명시적으로 저장하고 조회해야 한다.

## 함수에서 다른 함수 호출
함수가 다른 함수를 실행하는 것은 흔한 일이며, 코레오그래피, 오케스트레이션 워크플로에서도 마찬가지다. **함수 간에는 이벤트를 주고받는 비동기 통신, 요청-응답 호출, 또는 이 둘을 조합한 방법으로 통신한다.** 구현 방법은 FaaS 프레임워크와 경계 콘텍스트의 문제 공간에 따라 선택하면 된다. **다중 함수 솔루션을 구현할 때에는 흔히 코레오그래피/오케스트레이션 디자인 패턴을 사용한다.**

### 이벤트 기반 통신 패턴
한 함수의 출력을 이벤트 스트림에 넣어 다른 함수가 소비하게 만들 수도 있다. 경계 콘텍스트는 여러 함수와 내부 이벤트 스트림으로 구성되며 함수마다 구현된 트리거와 확장 로직은 다양하다. 각 함수는 자기 페이스에 맞게 이벤트를 받아 처리하고 주어진 작업을 실행하면서 그에 맞는 결과를 출력한다.

<img width="607" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/5c478e9f-ec4e-4bab-9416-d47586e5560f">

이벤트 기반 통신 패턴은 장점이 많다.

- 토폴로지 안에 있는 함수는 각각 작업이 끝나면 오프셋을 커밋해서 자신의 컨슈머 그룹 오프셋을 관리할 수 있다.
- 이벤트 스트림 처리 외에는 함수 간에 별다른 조정이 필요 없고 코레오그래피 패턴은 물론 오케스트레이션 패턴도 적용할 수 있다.
- 이벤트 처리 중 실패해도 이벤트 브로커에 이벤트가 남아있기 때문에 그 다음 함수 인스턴스가 재처리하면 되므로 데이터 손실이 발생할 일도 없다.

### 직접 호출 패턴
함수가 자기 코드에서 직접 다른 함수를 호출하는 패턴이다. fire-and-forget 방식으로 타 함수를 직접 비동기 호출하거나, 동기 호출을 한 다음 반환값을 기다리는 방식으로 작동된다.

#### 코레오그래피와 비동기 함수 호출
비동기 직접 호출은 코레오그래피 기반 FaaS 솔루션으로 넘어간다. 함수는 그냥 비즈니스 로직에 따라 다음 함수를 호출하고 실패, 오류 등 다음 단계를 처리할 책임은 다음 함수와 FaaS 프레임워크에게 맡긴다. 비동기 함수 직접 호출 체계를 구축하면 함수 호출을 간단히 체이닝할 수 있다.

<img width="569" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/029f7331-13dd-4e88-996a-1ee6b6f8dded">

함수 A는 이벤트 배치를 처리하면서 함수 B를 호출하고 작업이 끝나면 자신의 컨슈머 오프셋을 업데이트 한 뒤 종료시킨다. 한편, 함수 B는 처리를 계속하면서 출력 이벤트 스트림에 결과를 생산한다.

비동기 직접 호출의 중요한 단점은, 처리가 성공할 경우에만 컨슈머 오프셋 업데이트가 확실히 보장된다는 점이다. 함수 B는 함수 A에 아무런 피드백을 하지 않으므로 함수 A에서 에러가 발생할 경우에만 컨슈머 그룹 오프셋이 잘못 커밋되는 일을 막을 수 있다. 그러나 이벤트 손실이 그리 대수롭지 않은 워크플로라면 간단히 무시하고 넘어갈 수 있다.

함수 B를 여러 번 호출하면 이벤트 순서가 어긋날 수 있는 이슈도 있다.

```java
public int functionA(Event[] events, Context context) {
    for (Event event : events) {
        // A 함수의 처리 작업 수행
        // 이벤트마다 B 함수를 비동기 호출
        // 반환값을 기다리지 않음
        asyncfunctionB(event);
    }

    context.success();
    return 0;
}
```

함수 B는 함수 A 코드안에서 호출된다. 이렇게 하면 FaaS 프레임워크에 따라 각각 독립적으로 실행되는 함수 B 인스턴스가 여러 개 생성될 수 있고 그중 한 인스턴스는 다른 인스턴스보다 먼저 실행이 끝나 이벤트 순서가 꼬여버리는 경합 조건이 발생할 수 있다.

순서에 맞게 처리하려면 각 이벤트마다 그 다음 이벤트를 처리하기 전에 무조건 함수 A를 함수 B보다 먼저 실행해야 한다. 모든 이벤트가 한 함수에서 처리 완료된 이후에만 그 다음 이벤트를 시작하도록 강제하지 않으면 결국 비확정적인 결과가 초래될 것이다. 특히, 함수 A가 쓴 데이터에 함수 B가 의존하고 두 함수 모두 동일한 외부 데이터 저장소에서 작동된다면 더더욱 그렇다.

비동기 호출은 경계 콘텍스트의 요건을 충족하지 못하는 경우가 많기 때문에 동기 호출을 오케스트레이션 방식으로 사용하는 방안도 함께 고려해보자.

#### 오케스트레이션과 동기 함수 호출
함수를 동기 호출하면 다른 함수를 호출하고 그 결과를 기다린 뒤 나머지 비즈니스 로직을 수행할 수 있다.

#### 이벤트 스트림 - 트리거를 걸어 처리
파티셔닝된 이벤트 스트림에 새 이벤트가 도착하면 하나의 오케스트레이션 함수가 트리거된다고 하자. 함수가 시작되면 입력 이벤트 배치를 처리하기 시작하고 각 함수에 맞는 이벤트를 차례로 발송한다. 아래 그림은 단일 경계 콘텍스트 내부에 구축한 함수 기반의 오케스트레이션 예시다.

<img width="553" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/74395530-5d52-4e96-bda9-17adaf83e21b">

```java
public int orchestrationFunction(Event[] events, Context context) {
    for (Event event : events) {
        // 동기식 함수 호출
        Result resultFromA = invokeFunctionA(event);
        Result resultFromB = invokeFunctionB(event, resultFromA);
        Output output = composeOutputEvent(resultFromA, resultFromB);

        // 출력 스트림에 쓰기
        producer.produce("Output Stream", output);
    }
    // 컨슈머 오프셋을 업데이트하라고 FaaS 프레임워크에 알림
    context.success();
    return 0;
}
```

오케스트레이션 함수는 함수 A, B를 차례로 호출하고 각 함수의 결과를 기다린다. 필요시 함수 A의 출력을 함수 B의 입력으로 보낼 수도 있다. 각각의 이벤트는 다음 이벤트가 시작되기 전에 처리가 완료되므로 오프셋 순서는 확실히 보장된다. 컨슈머 함수는 이벤트 배치를 전부 다 처리한 후 FaaS 프레임워크에 오프셋을 업데이트하라고 알린 다음 성공 메시지를 반환한다.

#### 큐로 트리거를 걸어 이벤트 처리
개별 커밋 기능을 지닌 큐에선 트리거 메커니즘을 이용해 각 이벤트마다 고유한 오케스트레이션 함수를 트리거할 수 있다. 오케스트레이터는 작업 완료 후 처리 확인 사실을 다시 큐에 커밋한다. 작업 도중 실행하면 그 다음 오케스트레이터 인스턴스가 생성돼서 작업을 픽업할 것이다.

## 종료 및 중단
함수는 작업을 마치거나 자신에게 할당된 일반적으로 5~10분 정도의 수명이 끝나면 종료된다. 함수 인스턴스는 일시 중지 후 동면 상태에 빠지고 다시 곧바로 되살아나 활동하기도 한다. 일시 중지된 함수 중에는 리소스나 시간 제약 때문에 결국 동면 상태에서 추방되는 것
들도 있다.

함수가 종료되기 전에 함수에 할당된 리소스와 오픈된 커넥션은 어떻게 처리할지 결정해야 한다. 컨슈머 클라이언트라면 함수 인스턴스에 특정 이벤트 스트림 파티션이 할당될 것이다.

그런데 이런 리소스를 회수하지 않고 함수 인스턴스를 끝내버리면 타임아웃될 때까지 컨슈머 그룹 소유권이 재할당되지 않아 처리가 지연될 수도 있다. 이런 파티션에 들어있는 이벤 트는 컨슈머 그룹 리밸런스가 일어나거나, 종료된 함수 인스턴스가 다시 온라인 상태로 돌아와 처리를 재개할 때까지 하나도 처리가 안 된다.

함수가 거의 항상 온라인 상태에서 이벤트를 처리한다면 굳이 연결을 끊고 컨슈머 그룹을 리밸런스할 필요는 없다. 함수는 수명이 끝나면 일시 중지되어 잠시 겨울잠을 자고 있다가 즉시 런타임에 복귀할 가능성이 높다. 반대로 가끔씩 실행되는 컨슈머 함수라면 모든 연결을 끊고 이벤트 스트림 파티션을 할당하지 않는 게 최선이다. 다음 함수 인스턴스는 콜드/웜 스타트 상관없이 다시 연결을 해야 한다. 뭔가 의심스럽다면 연결을 깔끔히 정리하는 게 좋다. 그래야 외부 데이터 저장소와 이벤트 브로커의 부하를 덜어주고 일시 중지된 함수가 파티션 소유권을 주장할 가능성을 낮출 수 있다.

## 함수 튜닝
### 넉넉한 리소스 할당
**함수마다 CPU, 메모리를 따로 할당할 수 있으므로 함수 요건에 맞게 매개변수를 튜닝하는 작업이 중요하다.** 경계 콘텍스트 내부에 속하는 상태 저장소의 외부 I/O도 고려해야 한다.

### 배치 이벤트 처리 매개변수
함수에 할당된 이벤트 배치를 다 처리할 수 없을 때에는 함수 실행이 실패한 것으로 간주해서 해당 배치를 재처리해야 한다. 하지만 함수에 할당된 실행 시간이나 입력 이벤트 배치의 크기를 바꾸지 않으면 또 다시 실패할 확률이 높기 때문에 다음 두 가지 중 하나는 조치해야 한다.

- 함수의 최대 실행 시간을 늘린다.
- 함수가 처리할 이벤트의 최대 배치 크기를 줄인다.

AWS에서 제공하는 이벤트 리스너 트리거 시스템을 활용해 실패 시 배치 크기를 자동으로 둘로 나누어 실패한 함수를 재실행하는 방법도 있다. 에러가 나면 입력 배치를 이등분해서 함수가 제시간에 처리를 마칠 수 있을 때까지 계속 재실행하는 것이다.