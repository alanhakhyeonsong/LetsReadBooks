# Chapter 3. 통신 및 데이터 규약
이벤트 기반 시스템에서 이벤트는 무슨 일이 일어났고 그 이유는 무엇인지 정확하게 기술하는 메시지이자, 통신의 기본 단위다. 이벤트는 사실 진술서로서 시스템에서 발생한 다른 이벤트와 조합하여 발생한 사건에 관한 완전한 이력이 된다.

## 이벤트 기반 데이터 규약
**데이터 규약은 주고받을 데이터의 포맷과 그 생성 로직을 정의한다.** 이벤트 데이터를 생상하는 프로듀서와 이를 소비하는 컨슈머가 모두 준수하는 일종의 계약서인 셈이다. 이를 이용하면 이벤트가 생산되는 콘텍스트 이상의 의미를 부여할 수 있고 컨슈머 애플리케이션의 데이터 사용성을 넓힐 수 있다.

잘 정의된 데이터 규약에는 데이터 정의와 트리거 로직이 포함된다.

데이터 정의를 변경할 때는 다운스트림 컨슈머가 사용 중인 필드를 삭제/변경하지 않도록 주의해야 한다. 트리거 로직도 마찬가지다. 트리거 로직을 바꾸면 원래 이벤트 정의에 담긴 의미가 깨지는 경우가 많기 때문에 데이터 정의를 변경하는 게 더 일반적이다.

### 명시적인 스키마를 규약으로 활용
**데이터 규약을 강제하여 일관성을 유지하는 가장 좋은 방법은 이벤트마다 스키마를 정의하는 것이다.**

- 프로듀서는 데이터의 정의와 트리거 로직이 상술된 스키마를 명시적으로 정의하여 동일한 타입의 이벤트는 모두 해당 포맷을 따르게 한다.
- 컨슈머가 비즈니스 처리를 하려면 먼저 필요한 데이터를 추출해야 한다. 어떤 데이터가 있어야 할지 미리 스펙을 정리해놓지 않으면 부족 지식과 팀 간 소통만으로 데이터 문제를 해결해야 하는데, 이벤트 스트림이 늘어나고 팀이 많아지면 이런 식으로는 감당하기 어렵다.

명시적인 스키마는 프로듀서/컨슈머 모두에게 보안과 안정성을 선사한다.

### 스키마 정의 주석
스키마 정의에서 통합된 주석과 메타데이터는 이벤트 의미를 제대로 전달하기 위해 꼭 필요하다. 이벤트 생산/소비에 관한 지식은 가능한 한 이벤트 정의와 가깝게 붙어 있는게 좋다. 스키마 주석은 데이터 의미를 분명히 밝히고 혹시 모를 컨슈머의 오해를 불식시킬 때 유용하다.

- 이벤트의 트리거 논리를 명시: 보통 스키마 정의 맨 앞의 블록 헤더에 이벤트가 생성된 이유를 명확하게 밝힌다.
- 구조화된 스키마의 특정 필드에 대해 콘텍스트를 부여해서 밝힘: 예를 들어 `datetime` 필드의 날짜/시간 포맷이 UTC, ISO, 유닉스 타임 중 어느 것인지 주석에 명시한다.

### 완전한 스키마 진화
스키마 포맷은 반드시 스키마 진화 규칙의 전체 범위를 지원해야 한다. 스키마 진화를 잘 활용하면 컨슈머는 중단 없이 이벤트를 계속 소비하면서 프로듀서가 서비스의 출력 포맷을 업데이트할 수 있다.

스키마 진화 규칙을 명확하게 정해두면 프로듀서/컨슈머 모두 자기 일정에 따라 애플리케이션을 업데이트 할 수 있다. 스키마 진화 규칙은 호환성 종류에 따라 세 가지로 분류된다.

- 정방향 호환성
- 역방향 호환성
- 양방향 호환성

### 코드 생성기 지원
코드 생성기는 이벤트 스키마를 클래스 정의 또는 주어진 프로그래밍 언어에서 그와 동등한 구조로 변환한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/0cc05e94-8f1b-4087-8925-ab72672fc3e0)

이벤트 데이터를 소비하는 컨슈머는 스키마 버전을 직접 관리하며 대부분 프로듀서와 동일한 버전이지만 스키마 진화 용도에 따라 버전이 더 낮거나 높을 수 있다. 양방향 호환성을 준수할 경우 서비스는 어떤 스키마 버전이라도 그에 따라 이벤트 정의를 생성할 수 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/873c2ac5-3e5a-472d-8bf8-370f0dddee85)

### 중대한 스키마 변경
중대한 스키마 변경이 불가피한 경우도 있다. 원래 도메인 모델을 통째로 바꿔야 하는 비즈니스 요건의 큰 변화 등 다양한 사유가 있을 것이다. 프로듀서/컨슈머 사이에 긴밀한 협의가 필요하다. 관련자 모두가 반드시 공감대를 형성해야 한다. 스키마 재협의 외에도 새 스키마와 그 스키마로부터 생성한 새 이벤트 스트림을 정착시키려면 몇 가지 추가 단계를 거쳐야 한다.

#### 엔티티의 중대한 스키마 변경 적용
데이터 정의를 두 갈래로 분기하는 방법은 두 가지가 있다.

- 옛 스키마와 새 스키마를 함께 둔다.
- 모든 엔티티를 마이그레이션을 하거나 소스에서 다시 생성하는 식으로 새 스키마 포맷으로 재생성한다.

프로듀서 입장에선 첫 번째 방법이 가장 쉽지만 결국 상이한 엔티티 정의를 컨슈머가 알아서 해석하도록 방치하는 셈이다. 두 번째 방법은 프로듀서에겐 더 어렵지만 옛 엔티티, 새 엔티티 모두 일관성 있게 재정의할 수 있다. 프로듀서는 옛 엔티티의 출처인 소스 데이터를 재처리 후 새 비즈니스 로직을 적용해서 새 포맷에 맞게 엔티티를 재생성한다. 단, 엔티티가 무슨 의미인지, 프로듀서/컨슈머는 엔티티를 어떻게 똑같이 이해하고 사용할지는 조직 전체적으로 강제하지 않을 경우 아무 소용이 없다.

#### 이벤트에 관한 중대한 스키마 변경 적용
비엔티티 이벤트는 중대한 스키마 변경을 통합해서 더 간단하게 처리할 수 있다. 가장 간단하게는, 새 이벤트 스트림을 만들어 새 이벤트를 이 스트림에 생산하는 것이다.

## 이벤트 포맷 선택
이벤트 데이터는 여러 가지 방법으로 포맷팅/직렬화 할 수 있지만 데이터 규약은 Avro, Thrift, 프로토콜 버퍼처럼 엄격하게 정의된 포맷을 사용하는 편이 좋다. 잘 알려진 이벤트 브로커 프레임워크는 대부분 이런 포맷으로 인코딩된 이벤트의 직렬화를 지원한다. 가령 Apache Kafka는 JSON, 프로토콜 버퍼, Avro 포맷을 모두 지원한다.

이벤트를 그냥 단순히 키/값 구조의 평범한 텍스트로 나타내면 명시적인 스키마나 스키마 진화 프레임워크는 전혀 없기 때문에 팀 간에 더 많은 소통이 필요하고 강력한 데이터 규약을 통해 서로 격리된 상태를 유지하는 마이크로서비스 본연의 가치가 훼손될 수 있다.

## 이벤트 설계
이벤트 정의를 생성할 때에는 반드시 따라야 할 모범 사례도 있는 반면 반드시 피해야 할 안티 패턴도 있다. 우선 이벤트 기반 마이크로서비스로 작동되는 아키텍처 수가 늘어날수록 이벤트 정의도 많아진다는 사실을 기어갛자. 이벤트를 잘 설계해야만 프로듀서/컨슈머 모두에게 고통스러운 일을 최대한 덜 수 있다.

### 오직 진실만을 말할지어다
잘 정의된 이벤트는 단순히 뭔가가 일어났음을 전하는 메시지가 아니라 그 이벤트가 발생한 동안의 모든 일들을 빠짐없이 기술한다. 비즈니스 용어로는, 입력 데이터를 받아 비즈니스 로직을 적용해 만들어낸 결과 데이터다. 이 출력 이벤트를 단일 진실 공급원으로 간주해서 다운스트림 컨슈머가 소비할 불변의 팩트로 기록해야 한다.

### 스트림당 이벤트 정의는 하나만 사용
이벤트 스트림에는 하나의 논리적 이벤트를 나타내는 이벤트가 포함돼야 한다. 종류가 다른 이벤트들을 이벤트 스트림에 섞어 넣으면 이벤트 실체와 스트림 정체성에 혼란을 줄 수 있으므로 바람직하지 않다. 또 생상되는 스키마의 유효성을 검증하기 어렵다.

### 가장 좁은 범위의 데이터 타입 사용
**이벤트 데이터 타입은 가장 범위가 좁은 것을 사용하자.** 그래야 코드 생성기, 프로그래밍 언어의 타입 체크 기능, 직렬화 단위 테스트를 이용해 데이터 경계를 체크할 수 있다.

다음 사항들은 피해야 한다.

- 문자열을 이용해 숫자 값을 저장
- 정수를 불리언으로 사용
- 문자열을 enum으로 사용

### 이벤트는 하나의 목적만 갖도록
**이벤트 정의에 타입 필드를 추가해서 하위 속성을 따로 두려고 하는 것은 흔한 안티패턴 중 하나다.**

먼저, 각 타입 매개변숫값은 기술적 표현형은 거의 동일하지만 비즈니스 의미는 근본적으로 다르다. 또 그 의미도 시간이 지나면서 계속 바뀌고 이벤트가 커버하는 영역도 조금씩 달라진다. 타입에 종속된 정보를 추적하고자 새 매개변수를 추가하는 경우도 있고 아예 별도의 매개변수가 필요한 타입도 있을 것이다. 결국, 이벤트 스키마만 같을 뿐 전혀 다른 이벤트가 공존하기 때문에 나중에는 이벤트가 무슨 의미인지 짐작조차 어려워질 수 있다.

이런 복잡성은 이벤트를 개발/관리하는 개발자를 비롯해 어떤 데이터가 어떤 사유로 발행됐는지 일관되게 이해해야 할 데이터 컨슈머에게도 영향을 미친다. 따라서 컨슈머는 자기와 상관없는 이벤트를 제거하는 부가적인 처리 로직을 반드시 수행해야 한다.

### 이벤트 크기 최소화
이벤트는 크기가 작고, 잘 정의되어 있고, 쉽게 처리할 수 있어야 좋지만, 때로는 많은 콘텍스트 정보가 담긴 덩치 큰 이벤트도 발생할 수 있다.

몸집이 큰 이벤트를 설계할 때는 몇 가지 고려할 부분이 있다.

- 데이터가 해당 이벤트와 직접 관련이 있는지 확인하자.
- 모든 이벤트 데이터가 정말 다 직접 연관되어 있다면 한 걸음 뒤로 물러나 자신의 문제 공간을 살펴보자.
- 경계 콘텍스트를 검토해야 할 수도 있다.
- 부가적인 기능을 별도의 서비스로 나누어 서비스 범위를 축소하는 것도 방법이다.

### 미래의 컨슈머도 이벤트 설계에 반영
새 이벤트를 설계할 때에는 그 데이터를 소비할 것으로 예상되는 컨슈머 부서와도 협의가 필요하다. 이를 통해 이슈를 어느 정도 예방할 수 있을 것이다.

### 이벤트를 세마포어나 시그널로 사용하지 않는다
이벤트를 세마포어나 시그널로 사용하면 안된다. 이런 이벤트는 어떤 결과의 단일 진실 공급원이 아닌, 그냥 뭔가가 일어났음을 알릴 뿐이다.