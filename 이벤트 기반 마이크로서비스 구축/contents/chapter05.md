# Chapter 5. 이벤트 기반 처리 기본
대부분의 이벤트 기반 마이크로서비스는 적어도 다음 세 단계를 거쳐 실행된다.

1. 입력 이벤트 스트림에서 이벤트를 소비한다.
2. 이벤트를 처리한다.
3. 필요한 출력 이벤트를 생산한다.

이 장에서는 이벤트 스트림에서 이벤트를 소싱하는 마이크로서비스에 대해서만 살펴본다.

스트림에서 이벤트를 소싱하는 이벤트 기반 마이크로서비스의 인스턴스는 프로듀서/컨슈머 클라이언트를 생성하거나 필요시 컨슈머 그룹에 조인한다. 그리고 컨슈머 클라이언트는 새 이벤트를 폴링해서 처리하고 필요한 출력 이벤트를 내보내는 작업을 무한 반복한다.

다음은 해당 워크플로를 나타낸 슈도코드다.

```java
Consumer consumerClient = new ConsumerClient(consumerGroupName, ...);
Producer producerClient = new ProducerClient(...);

while (true) {
    InputEvent event = comsumerClient.pollOneEvent(inputEventStream);
    OutputEvent output = processEvent(event);
    producerClient.produceEventToStream(outputEventStream, output);

    // 적어도 한 번 이상 처리
    consumerClient.commitOffsets();
}
```

위 코드에서 `processEvent()`가 주요하다. 실제로 입력 이벤트에 비즈니스 로직을 적용해서 필요시 출력 이벤트를 내보내는 모든 이벤트 처리 로직은 이 함수에 구현한다. 이 함수가 바로 마이크로서비스 처리 토폴로지의 진입점에 해당한다. 여기서부터 데이터 주도 패턴에 따라 경계 콘텍스트의 비즈니스 요건에 알맞게 데이터를 변환/처리한다.

## 상태 비저장 토폴로지 구성
마이크로서비스 토폴로지를 설계하려면 사고 방식을 이벤트 기반으로 바꿔야 한다. **컨슈머의 입력값으로 이벤트가 들어오면 그에 반응하여 코드가 실행하는 구조이기 때문이다.** 마이크로서비스 토폴로지는 본질적으로 이벤트에 수행하는 일련의 작업들이고 비즈니스 로직 수행에 필요한 필터, 라우터, 변환, 구체화, 취합 같은 기능을 선택해야 한다.

아래와 같은 토폴로지가 있다. 이벤트는 한 번에 하나씩 소비되며 두 단계 변환을 거쳐 처리된다.

<img width="639" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/af34a479-0923-41ae-a631-9c56e7fb3cff">

### 변환
변환은 하나의 이벤트를 처리해서 하나 이상의 출력 이벤트를 내는 과정이다. 변환이 필요한 비즈니스 로직은 대부분 이런 과정을 거치며 작업에 따라 이벤트를 리파티션해야 할 수도 있다.

- 필터
- 맵
- 맵밸류
- 맞춤 변환

### 스트림 분기 및 병합
컨슈머 애플리케이션에서 이벤트 스트림을 분기처리해야 할 수도 있다. 즉, 이벤트에 논리적 연산을 적용한 결과에 따라 새로운 스트림으로 출력하는 것이다. 보통 이벤트를 소비해서 특정한 속성에 따라 어디로 보낼지 결정하는 경우가 많다. 그 다음으론, 다른 출력 이벤트 스트림에 결과를 내보내는 경우도 많다. 가령, 처리 중 에러가 발생하면 이벤트를 완전히 삭제하는 게 아니라 dead-letter stream에 출력하는 식이다.

컨슈머 애플리케이션에 스트림을 병합해야 할 수도 있다. 여러 입력 스트림에서 들어온 이벤트를 소비해서 유의미한 방법으로 처리한 다음 하나의 출력 스트림으로 내보내는 것이다. 이런 시나리오는 그리 많진 않다.

## 이벤트 스트림 리파티션
이벤트 스트림은 이벤트 키와 이벤트 파티셔너 로직에 의해 리파티셔닝된다. 이벤트마다 이벤트 파티셔너를 적용하면 이벤트를 기록할 파티션이 결정된다. 리파티션이란 다음 중 하나 이상의 속성을 이용해 새 이벤트 스트림을 생산하는 행위를 말한다.

- 상이한 파티션 수: 다운스트림의 병렬도를 높이고자 이벤트 스트림의 파티션 수를 늘리거나 코파티션을 위해 다른 스트림과 파티션 수를 똑같이 맞춘다.
- 상이한 이벤트 키: 키가 같은 이벤트는 동일한 파티션으로 배치되도록 이벤트 키를 변경한다.
- 상이한 이벤트 파티셔너: 이벤트를 쓸 파티션 선택 로직을 변경한다.

<img width="639" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/284033c0-4620-4c5f-95d5-38d1fd5065d2">

## 이벤트 스트림 코파티션
**코파티션은 어떤 이벤트 스트림을 파티션 수와 파티션 할당기 로직이 동일한 새로운 스트림으로 리파티션하는 것이다.** 한 이벤트 스트림의 키 있는 이벤트를 데이터 지역성을 추구하고자 다른 스트림의 이벤트와 같은 장소에 배치할 때 필요한 작업이다. 갖가지 상태 저장 작업을 처리할 때에는 출처가 어느 스트림이든 상관없이 키가 동일한 이벤트를 모두 동일한 노드에서 처리해야 하므로 코파티션은 상태 저장 스트림 처리에서 아주 중요한 개념이다.

<img width="622" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/b06dc233-a424-4723-8560-2c5b23534cc8">

## 컨슈머 인스턴스에 파티션 할당
마이크로서비스는 각자 고유한 컨슈머 그룹을 유지해서 자신이 소비하는 입력 이벤트 스트림의 오프셋을 집합적으로 나타낸다. 첫 번째 컨슈머 인스턴스는 해당 컨슈머 그룹명으로 이벤트 브로커에 등록하며 이벤트 브로커는 등록이 끝나면 컨슈머 인스턴스당 하나씩 파티션을 할당한다.

Apache Kafka 같은 이벤트 브로커는 컨슈머 그룹마다 가장 첫 번째로 등록된 클라이언트에 파티션 할당의 임무를 맡긴다. 이 컨슈머 인스턴스는 컨슈머 그룹 리더로서 파티션 어사이너 역할을 맡아 새 인스턴스가 컨슈머 그룹에 조인할 때마다 입력 스트림의 파티션을 정확하게 할당한다.

파티션을 다시 할당할 땐 경합 조건을 방지하기 위해 모든 작업을 잠시 멈춘다. 이렇게 해야 파티션을 회수해도 새 인스턴스에 할당하기 직전에 다른 인스턴스가 처리하지 못하게 막을 수 있고 중복 출력이 발생하지 않는다.

### 파티션 어사이너로 파티션 배정
전용 스트림 처리 프레임워크를 사용하든, 기본 프로듀서/컨슈머를 구현하든, 대량 데이터를 처리하려면 컨슈머 마이크로서비스를 여러 인스턴스로 실행하여 병렬 처리해야 한다. 파티션 어사이너는 공평하고 안정된 방법으로 파티션을 여러 컨슈머 인스턴스에게 골고루 분배한다.

파티션 어사이너는 컨슈머 그룹에서 컨슈머 인스턴스를 추가/삭제할 때마다 파티션을 재할당하는 일도 한다. 어사이너 컴포넌트는 이벤트 브로커 종류에 따라 컨슈머 클라이언트에 탑재하거나 이벤트 브로커 내부에서 관리한다.

### 코파티션된 파티션 할당
파티션 어사이너는 코파티션 요건을 모두 충족시키는 역할도 한다. 코파티션된 것으로 표시 된 모든 파티션은 동일한 하나의 컨슈머 인스턴스에 할당되어야 한다. 이렇게 해야 마이크로 서비스 인스턴스가 어떤 비즈니스 로직을 수행하는 데 필요한 이벤트 데이터의 하위 집합이 정확하게 할당될 것이다. 여러 이벤트 스트림의 파티션 수가 모두 똑같은지 체크해서 그렇지 않을 경우 예외를 던지는 로직은 파티션 어사이너 코드에 두는 게 좋다.

### 파티션 할당 전략
파티션 할당 알고리즘의 목표는 컨슈머 인스턴스의 처리 능력이 동등하다는 전제 하에 파티션을 컨슈머 인스턴스 전체에 고루 분배하는 것이다. 두 번째 목표는 리밸런스가 일어나는 도중 재할당된 파티션 수를 줄이는 것인데, 특히 여러 데이터 저장소 인스턴스에 샤딩된 구체화 상태를 다루는 경우에는 파티션 재할당 때문에 이후 업데이트 시 엉뚱한 샤드로 향할 수 있기 때문에 중요하다.

파티션을 할당하는 전략은 매우 다양하며 사용 중인 프레임워크나 구현체마다 조금씩 다르지만 일반적으로 다음 세 가지 기본 전략을 사용한다.

#### 라운드-로빈 할당
전체 파티션 리스트를 만들어 컨슈머 인스턴스마다 하나씩 라운드 로빈 방식으로 할당한다. 코파티션된 스트림은 따로 리스트를 관리해서 적절하게 할당한다.

<img width="387" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/2f98b812-a51f-4e03-9977-3bc921a72450">

이 컨슈머 그룹에 컨슈머 인스턴스가 추가되면 리소스 간 부하를 분산하기 위해 파티션 할당을 다시 조정하는 리밸런스가 일어난다.

<img width="394" alt="image" src="https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/e01b1831-28ef-49c8-8aa0-ecab10f0cd88">

#### 정적 할당
정적 할당은 특정 파티션을 특정 컨슈머에게 할당하는 것이다. 주로 내부 상태 저장소에서 대용량 상태 저장 데이털르 주어진 인스턴스에서 구체화할 때 아주 유용하다. 컨슈머 인스턴스가 컨슈머 그룹을 떠나도 정적 어사이너는 파티션을 재할당하지 않은 상태로 해당 인스턴스가 복귀할 때까지 기다린다. 주어진 시간 내에 컨슈머 그룹으로 복귀하지 못하면 파티션을 동적으로 재할당하도록 설정할 수도 있다.

#### 맞춤 할당
외부에서 신호를 받거나 다른 도구를 이용해 클라이언트 요건에 최적화된 할당 로직을 직접 작성할 수도 있다. 입력 이벤트 스트림의 현재 랙 상태에 따라 파티션을 할당해서 작업 부하를 모든 컨슈머 인스턴스에 고루 분산시킬 수 있다.

## 상태 비저장 처리 인스턴스 실패 복구
상태 비저장 처리 실패를 복구하는 것은 그냥 컨슈머 그룹에 새 인스턴스를 추가하는 것과 다를 바 없다. 상태 비저장 처리기는 상태를 복구할 필요가 없으므로 파티션을 할당하고 오프셋을 확보하는 즉시 곧바로 이벤트를 처리할 수 있다.