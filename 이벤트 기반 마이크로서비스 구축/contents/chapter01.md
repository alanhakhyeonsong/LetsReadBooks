# Chapter 1. 왜 이벤트 기반 마이크로서비스인가?
비동기 방식으로 생산/소비되는 이벤트라는 미디어는 현대 기술에 의해 근본부터 달라졌다. 이벤트는 이제 엄청나게 큰 규모로 무기한 저장할 수 있고 모든 서비스가 필요할 때마다 몇 번이라도 소비할 수 있게 됐다. 컴퓨팅 리소르를 획득하여 그때그때 릴리스하는 작업이 간편해져 마이크로서비스도 쉽게 생성/관리할 수 있다. 과거에 마이크로서비스는 배치 기반의 빅데이터 솔루션에 불과했지만, 이젠 그런 제약에서 벗어나 필요에 따라 얼마든지 데이터를 저장/관리할 수 있다.

## 이벤트 기반 마이크로서비스란?
서비스 지향 아키텍처(SOA)는 서로 직접 비동기 통신하는 여러 마이크로서비스로 구성되며, 메시지 전달 아키텍처도 소비 가능한 이벤트를 주고받으며 서로 비동기 통신을 한다. 이처럼 이벤트에 기반을 둔 통신 자체는 새로운 기술이 아니지만, 대용량 데이터를 대규모로 확장하고 실시간 처리를 전제로 하는 요건은 전에 없던 기술이라 기존 아키텍처 스타일은 어떤 식으로든 달라질 수 밖에 없다.

**현대 이벤트 기반 마이크로서비스 아키텍처에선 시스템이 이벤트를 생산/소비하는 식으로 서로 통신한다.** 이벤트를 소비해도 메시지를 전달한 시스템에서 바로 사라지는 건 아니고 같은 메시지를 필요로 하는 다른 컨슈머도 가져갈 수 있게 보존된다.

서비스는 입력 이벤트 스트림에서 이벤트를 받아 특정한 비즈니스 로직을 적용한 다음, 출력 이벤트를 내보내서 요청-응답 접근에 필요한 데이터를 제공하거나 서드파티 API와의 통신, 또는 다른 필요한 일을 수행한다. 서비스는 stateful 서비스, stateless 서비스로 분류되며 실행 시간이 standalone 애플리케이션으로 구현할 수도 있고, 서비스로서의 함수(FaaS) 함수 형태로 실행할 수도 있다.

## 도메인 주도 설계와 경계 콘텍스트
도메인 주도 설계(DDD)를 주창한 에릭 에반스는 동명의 저서에서 이벤트 기반 마이크로서비스를 구축하는 데 필요한 몇 가지 주요 개념을 소개했다.

- domain: 비즈니스가 차지하고 솔루션을 제공하는 문제 공간. 규칙, 프로세스, 아이디어, 비즈니스 전문 용어, 그밖에 비즈니스 관심사든 아니든 상관없이 문제 공간과 조금이라도 관련된 것들은 모두 다 포함된다. 도메인은 비즈니스 존재 여부와 무관하게 존재한다.
- subdomain: 메인 도메인을 이루는 컴포넌트. 하위 도메인은 특정한 하위 업무에 집중하며, 일반적으로 비즈니스 조직 구조를 반영한다.
- 도메인(및 하위도 메인) 모델: 비즈니스 용도에 맞게 실제 도메인을 추상화한 비즈니스에서 가장 중요한 도메인 조각 및 속성들로 모델을 생성한다. 비즈니스의 메인 도메인 모델은 비즈니스가 고객에게 제공하는 제품, 고객과 제품이 상호작용하는 인터페이스, 그밖에 해당 비즈니스로 명확한 목표를 달성하는 데 필요한 갖가지 프로세스와 기능에 따라 달라진다. 도메인과 비즈니스 우선순위는 계속 달라지므로 모델을 정교하게 잘 다듬어야 한다. 도메인 모델은 솔루션 공간의 일부로 비즈니스가 문제를 해결하기 위해 사용하는 구성체다.
- bounded context: 입력, 출력, 이벤트, 요건, 프로세스, 데이터 모델 등 하위 도메인과 연관된 논리적 경계. 경계 콘텍스트와 하위 도메인이 완벽히 일치하면 이상적이겠지만, 레거시 시스템, 기술 부채, 서드파티 시스템 연계 탓에 예외적인 경우가 많다. 이는 솔루션 공간의 속성으로 마이크로서비스가 상호작용하는 방식에 상당한 영향을 미친다.

**경계 콘텍스트는 응집력이 강해야 한다. 콘텍스트의 내부 기능은 집약적이고 깊이 연관되어 있고, 대부분의 통신이 경계를 넘나들지 않고 내부에서만 일어나야 한다.** 할 일이 고도로 응집되어 있으면 그만큼 설계 범위가 좁혀지고 구현하기도 간단해진다. **경계 콘텍스트끼리는 느슨하게 결합해야 한다.** 어떤 경계 콘텍스트에서 일어난 변경이 인접한 콘텍스트에 미치는 영향을 최소화하거나 아예 없애야 한다. 느슨하게 결합하면 이웃 콘텍스트가 변화의 영향을 받지 않고 독립적으로 움직일 수 있다.

### 도메인 모델과 경계 콘텍스트 활용
모든 조직은 그 자신과 외부 사이에 하나의 도메인을 형성한다. 조직 구성원은 각자 맡은 도메인의 니즈를 지원한다. 도메인은 다시 하위 도메인으로 나뉜다. 하위 도메인 모델은 개발팀이 작고 독립적인 서비스로 옮길 수 있을 정도가 될 때까지 계속 분할된다. 경계 콘텍스트는 이런 하위 도메인을 중심으로 형성되어 마이크로서비스가 탄생하는 기초가 된다.

### 비즈니스 요건에 따라 경계 콘텍스트 조정
어떤 제품에 대한 비즈니스 요건은 조직의 변화 또는 새로운 기능 수요로 인해 그 제품이 존재하는 한 계속 달라지기 마련이다. 하지만 반대로 비즈니스 요건 변경 없이 제품의 근본적인 구현체를 뜯어고치는 경우는 거의 없다. **경계 콘텍스트를 기술 요건이 아니라 비즈니스 요건 중심으로 정해야 하는 이유가 바로 이 때문이다.**

**경계 콘텍스트를 비즈니스 요건으로 맞추면 팀별로 느슨하게 결합하며 고도로 응집된 마이크로서비스 구현체를 바꿀 수 있다.** 덕분에 비즈니스에서 필요한 솔루션을 자율적으로 설계/구현할 수 있고 팀 간의 복잡한 의존 관계도 엄청나게 줄어들어 팀별로 맡은 요건에만 전념할 수 있다.

반대로, 마이크로서비스를 기술 요건에 맞추면 문제가 생긴다. 이런 패턴은 잘못 설계한 동기식 점대점 마이크로서비스, 그리고 팀마다 애플리케이션의 특정 레이어를 담당했던 과거 모놀리식 컴퓨팅 시스템에서 흔히 찾아볼 수 있다. 기술 요건에 맞추면 생기는 가장 큰 문제점은 **여러 경계 콘텍스트에 걸쳐 비즈니스 기능을 수행할 책임이 여러 팀으로 분산돼서 제각기 다른 스케줄로 다른 업무를 진행하게 된다는 점이다.** 어느 한 팀이 100% 책임지고 솔루션을 구현하는 게 아니다 보니 여러 서비스가 서로 팀, API 경계를 넘나들며 결합되어 뭐 하나 고치려면 아주 어렵고 비용이 많이 필요하다. 언뜻 보깅 별것 아닌 변경, 버그, 서비스 장애가 그 기술을 사용하는 모든 비즈니스 서비스 기능에 심각한 후폭풍을 가져올 수 있다.

따라서 이벤트 기반 마이크로서비스 아키텍처에선 기술에 맞출 일은 드물고 가급적이면 아예 삼가는 것이 좋다. 전체를 아우르는 기술, 팀 간의 의존성을 타파해야 시스템의 변경 민감도를 낮출 수 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/05525407-de35-478a-b672-5725bdf83840)

이벤트 기반 마이크로서비스는 **비즈니스 요건에 따라 아키텍처를 모델링하는 것이 바람직하다.** 물론 코드가 여러 번 복제되거나 비슷한 패턴으로 데이터에 접근하는 서비스가 증가하는 트레이드오프는 있다. 개발자는 다른 제품과 데이터 소스를 공유하거나 경계를 연결하려는 식으로 이런 반복을 줄이려고 애쓰겠지만, 장기적인 관점에선 이렇게 단단히 결합될 경우 로직을 반복하고 비슷한 데이터를 저장하는 것보다 훨씬 값비싼 대가를 치르게 될 것이다.

## 통신 구조
비즈니스를 영위하는 방식에 영향을 주는 세 가지 주요 통신 구조를 살펴보자.

### 비즈니스 통신 구조
팀과 부서 간의 통신을 결정하며, 각 팀에 할당된 주된 요건 및 책임에 따라 달라진다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/76c0511d-a158-4030-9817-25c1476ef366)

비즈니스 요건, 팀별 요건 배정, 팀 구성은 시간이 지나면 모두 바뀌기 마련이므로 비즈니스 통신 구조와 구현 통신 구조 사이의 관계에 상당한 영향을 미칠 수 있다.

### 구현 통신 구조
구현 통신 구조는 하위 도메인 모델에 대해 조직에서 규정한 데이터와 로직을 이용해 신속하고 효율적인 업무 수행을 위해 비즈니스 프로세스, 데이터 구조, 시스템 설계를 정규화한 것이다. 구현체가 만족시켜야 할 비즈니스 요건을 다시 정의하려면 로직을 다시 작성해야 하므로 비즈니스 통신 구조의 유연성과는 트레이드오프가 있다. 여기서 말하는 재작성은 대부분 하위 도메인 모델 및 그에 관한 코드를 반복적으로 고치는 작업을 말하며 시간이 지날수록 구현체는 새로운 비즈니스 요건을 충족하기 위해 진화한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/031a2765-1f40-4bcc-8cc2-eabd2b8f9e26)

소프트웨어 공학에서 구현 통신 구조의 전형적인 사례는 모놀리식 DB 애플리케이션이다. 비즈니스 로직이 기능을 호출하거나 상태를 공유함으로써 내부적으로 통신하는 모놀리식 애플리케이션은 결국 비즈니스 통신 구조에 따른 비즈니스 요건을 만족시키는 역할을 한다.

### 데이터 통신 구조
데이터 통신 구조는 비즈니스 전반에 걸쳐, 특히 구현체 간에 데이터를 주고받는 프로세스를 말한다. 이메일, 인스턴스 메시징, 회의 등을 통한 데이터 통신 구조는 비즈니스 변화를 소통하는 수단으로 자주 쓰이지만 소프트웨어 구현에선 대체로 무시되어온 편이었다. 데이터 통신 구조는 일반적으로 한 시스템에서 다른 시스템으로 애드혹 통신을 하는 역할에 충실했고, 구현 통신 구조는 본연의 임무 외에도 데이터 통신 기능까지 1인 2역을 소화하는 경우가 많았다. 이 때문에 기업이 계속 성장하고 변화하는 과정에서 많은 문제가 불거졌다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/ff1da7fb-2eff-4b06-b240-053dcf301cf8)

### 콘웨이의 법칙과 통신 구조
> 시스템 구조는 그 시스템을 설계하는 조직의 통신 구조를 그대로 따라갈 수 밖에 없다. - 멜빈 콘웨이

콘웨이의 법칙은 팀이 조직의 통신 구조에 따라 제품을 만든다는 의미다. 비즈니스 통신 구조는 사람들을 여러 팀으로 조직하고 이 팀들은 팀 경계에 의해 구분된 제품을 생산한다. 구현 통신 구조는 주어진 제품의 하위 도메인 데이터 모델로 접근하는 통로를 제공하지만 데이터 통신 기능이 약하기 때문에 다른 제품으로의 접근은 제한적이다.

도메인은 비즈니스를 포괄하는 개념이므로 도메인 데이터는 대부분 조직의 다른 경계 콘텍스트에서도 필요한 경우가 많다. 구현 통신 구조는 그런 통신 메커니즘으로는 적당하지 않지만, 자신의 경계 콘텍스트의 니즈를 충족하는 일에는 탁월하고 제품 설계에 있어서 두 가지 방향으로 영향을 미친다.

- 조직 전체에 필요한 데이터를 통신하는 방식이 비효율적이므로 논리적으로 전혀 다른 신제품을 만드는 데 지장을 초래한다.
- 기존 도메인 데이터에 쉽게 접근할 수 있지만 새로운 비즈니스 요건을 수용하기 위해 지속적으로 도메인을 확장하는 위험을 무릅써야 한다.

이것이 모놀리식 설계에 내재된 패턴이다.

데이터 통신 구조는 제품을 설계/개발하는 방법에 핵심적인 비중을 차지하지만, 오랫동안 이런 구조로 방치된 조직도 많다. 다른 구현체의 도메인 데이터에 접근할 수 없는 문제를 해결하려고 노력한 회사도 있지만 저마다 각기 다른 뚜렷한 단점들이 있다. **가령, 아직도 많이 사용하는 공유 DB는 안티 패턴이 발생하기 쉽고 확장을 해도 모든 성능 요건을 충족하지 못하는 경우가 태반이다.** 읽기 전용 레플리카를 제공하는 DB도 있지만 내부 데이터 모델을 불필요하게 노출시킬 필요는 없다. 배치 프로세스가 데이터를 파일 저장소에 덤프하면 다른 프로세스가 파일을 읽어가는 방법은 sources of truth가 다수 생성되어 데이터 일관성이 떨어지게 될 것이다. **무엇보다도 이런 방법은 전부 구현체를 단단히 결합시키고 직접 점대점으로 통신하게 만드는 경직된 아키텍처의 산물이다.**

## 기존 컴퓨팅의 통신 구조
단일 데이터 저장소에 기반한 단일 서비스를 담당하는 팀이 있다고 해보자. 신규 비즈니스 요건이 접수됐을 때, 새로운 서비스에 구현할 것인가, 아니면 그냥 있던 서비스에 추가할 것인가?

### 옵션 1: 서비스를 새로 만듦
비즈니스 요건이 많이 차이나면 서비스를 새로 만들어 구현하는 게 더 나을수도 있다. 하지만 데이터는 어떻게 할까? 새로운 비즈니스 기능은 옛 데이터도 참조해야 하는데 그 데이터는 아직 기존 서비스에 묶여 있고 완전히 독립적인 신규 서비스를 개시하는 프로세스도 없는 상황이다. 반면 팀 규모는 점점 더 커지고 회사는 빠르게 성장을 거듭하고 있다. 나중에 팀을 나누어야 할 수도 있으니 모듈화한 독립적인 시스템을 각각 두는 편이 소유권을 분할하기 쉽다.

이 방법도 물론 몇 가지 위험이 따른다.

- 원래 데이터 저장소에 있는 데이터를 가져와 새 데이터 저장소로 복사할 방법을 강구해야 한다.
- 데이터 구조를 바꾸어도 그 데이터를 가져가는 다른 팀에 영향이 없도록, 내부 로직이 노출되지 않도록 신경 써야 한다.
- 복사한 데이터는 30분마다 실시간으로 프로덕션 데이터를 복사할 정도의 능력을 갖춰야 한다.
- 데이터 복사 과정에서 정확하게 실행되도록 연결을 주의 깊게 모니터링해야 한다.

새로운 서비스를 만들어 운영하는 작업 역시 리스크가 따른다. 데이터 저장소 2개, 서비스 2개를 관리하면서 로깅, 모니터링, 테스트, 배포, 롤백 프로세스를 마련해야 하며, 데이터 구조가 조금이라도 바뀔 경우 의존 관계가 있는 타 시스템에 영향이 없도록 동기화에 만전을 기해야 한다.

### 옵션 2: 기존 서비스에 추가
이 방법 역시 리스크는 따르지만 조금 더 복잡하고 미묘하다. **특히, 여러 모듈이 동일한 코드 베이스에 함께 엮이는 경우가 많아 변경할 일이 생기면 구현체 내부에서 경계가 모호해질 가능성이 있다.** 경계를 자유롭게 넘나들면서 모듈을 직접 결합시키면 쉽고 빠르게 기능을 추가할 수 있어 유리하지만, 결합도는 올라가고 응집도와 모듈성은 떨어지기 마련이다.

### 옵션별 장단점
많은 팀이 기존 시스템에 기능을 덧붙이는 두 번째 옵션을 선택할 것이다. 모놀리식 아키텍처는 아직도 강려갛고 건재하며 비즈니스에 탁월한 가치를 제공하므로 잘못된 선택은 아니다. 첫 번째 옵션은 기존 컴퓨팅에 관한 다음 두 가지 경우에 우선 적용된다.

- 다른 시스템의 데이터에 안정적으로 접근하기 어렵다. 특히, 대규모 데이터를 실시간 접근하기 곤란하다.
- 서비스를 새로 만들어 관리하는 오버헤드와 리스크를 무시할 수 없다. 특히, 신규 서비스를 관리하는 체계가 조직 내에 아직 확립되어 있지 않다.

로컬 데이터는 당연히 다른 데이터 저장소의 데이터보다 접근하기 쉽다. 다른 팀의 데이터 저장소에 캡슐화된 데이터를 손에 넣으려면 구현체와 비즈니스 통신 경계를 오가야 하니 어렵다. 또 데이터, 연결 수가 많아지고 성능 요건이 까다로울수록 관리/확장이 점점 더 어려워진다.

- 필요한 데이터를 복사하는 방식은 그만한 가치가 있지만 결코 수월하지 않고 직접적인 점대점 결합이 발생할 수밖에 없다.
- 데이터를 저장하는 팀과 그것을 복사하는 팀 모두 기술적으로 구현 통신 구조상 끈끈한 의존 관계가 발생하고, 데이터가 변경될 때마다 팀원들은 그에 따른 동기화 작업을 수행해야 한다.
- 구현한 내부 데이터 모델이 지나치게 노출되지 않도록, 다른 시스템이 이 데이터 모델에 의존하지 않게끔 각별히 신경 써야 한다.
- 데이터 복제 쿼리가 소스 시스템에 과도한 부하를 유발하기 때문에 두 시스템에서 확장성, 성능, 시스템 가용성이 문제가 될 때도 많고 동기화 프로세스가 실패해도 긴급 상황이 발생하기 전에는 알 수 없는 경우도 있다.
- 데이터 양이 많고 소싱이 복잡할수록 원본과 더 많이 어긋나게 된다.

두 번째 옵션을 선택하고 시간이 흘렀을 때, 팀별 비즈니스 요건을 이행하기 위해 다음과 같은 사항들을 고려하게 될 것이다.

- 어느 팀이 어떤 데이터를 소유해야 하나?
- 데이터는 어디에 두어야 하나?
- 두 팀 모두 값을 변경하는 데이터는 어떻게 처리할까?

모든 데이터를 한 서비스의 로컬에 두고 새 비즈니스 기능을 신속 용이하게 추가하고 싶지만 구현 통신 구조를 확장해야 하는 비용을 부담해야 한다. 팀 규모가 커지면 언젠가는 비즈니스 요건을 새 팀에 재배정하고 비즈니스 통신 구조를 분할할 수 밖에 없겠지만, 구현 통신 구조는 현재 모습에서 도저히 재배정할 수 없으니 여러 컴포넌트로 적절히 세분화해야 할 것이다. 어느 쪽을 택하든 확장은 안 되니 각각 다른 식으로 처리해야 한다. 이 모든 문제의 근원은 바로 **구현 통신 구조 간의 데이터 통신 수단이 취약하고 제대로 정의되지 않은 탓이다.**

## 이벤트 기반 통신 구조
**이벤트 기반 통신은 기존 구현/데이터 통신 구조의 대안이다.** 요청-응답 기반 통신을 한꺼번에 대체할 수는 없지만 완전히 다른 서비스 간 통신 수단을 제시한다. **이벤트 스트리밍 방식의 데이터 통신 구조에서는 데이터를 생산/소유하는 것과 데이터에 접근하는 행위가 철저히 분리되기 때문에 서비스는 더 이상 직접 요청-응답 API에 얽매이는 일 없이 이벤트 스트림 내부에 정의된 이벤트 데이터를 매개로 소통한다.** 프로듀서는 그저 자신이 맡은 이벤트 스트림에 잘 정의된 데이터를 생산하는 일만 책임지면 된다.

### 이벤트는 통신의 근간이다
공유 데이터는 모조리 이벤트 스트림 세트에 발행함으로써 조직에서 일어난 모든 일은 지속적으로 정규화한 형태로 서술된다. 이것이 바로 여러 시스템이 서로 통신하는 채널이다. 단순한 작업부터 복잡하고 상태가 저장되는 레코드까지 거의 모든 것을 이벤트로 주고받는 것이다. **이벤트가 곧 데이터다.** 단지 데이터가 어딘가 준비되어 있다는 신호나 데이터를 한 구현체에서 다른 구현체로 실어 나르는 수단이 아니다. **이벤트는 데이터 스토리지뿐만 아니라 서비스 간의 비동기 통신 수단 역할도 한다.**

### 이벤트 스트림은 단일 진실 공급원이다
스트림 안에 있는 각 이벤트는 사실 진술서다. 이것들을 취합하면 조직 내 모든 시스템이 통신하는 근간인 단일 진실 공급원이 된다. 통신 구조는 정보가 정확할 때만 유효하기 때문에 이벤트 스트림을 단일 진실 공급원으로 채택하는 것은 큰 의미가 있다. 팀마다 상충되는 데이터를 각기 다른 곳에 두면 이벤트 스트림은 조직 데이터의 통신 백본으로서의 기능을 제대로 발휘하지 못할 것이다.

### 컨슈머가 스스로 모델링과 쿼리를 수행한다
**모든 비즈니스 및 애플리케이션 로직은 반드시 이벤트 프로듀서/컨슈머 안에 캡슐화돼야 한다.**

데이터 접근과 모델링 요건은 완전히 컨슈머로 이동해서, 컨슈머는 소스 이벤트 스트림에서 받은 이벤트 사본을 가져온다. 쿼리 복잡도 역시 데이터 소유자의 구현 통신 구조에서 컨슈머의 구현 통신 구조로 옮아간다. **컨슈머는 여러 이벤트 스트림에서 들어온 데이터를 혼합하거나, 특별한 쿼리를 하거나, 특정한 비즈니스 로직을 적용하는 일을 전담한다.**

예전 구조라면 프로듀서/컨슈머 모두 쿼리 메커니즘, 데이터 전송 메커니즘, API, 전체 팀 서비스를 상대로 데이터 통신 수단을 제공해야 했지만, 이제는 각자 맡은 경계 콘텍스트의 니즈를 해결하는 일만 책임지면 된다.

### 조직 전반적으로 데이터 통신이 원활해진다
데이터 통신 구조를 사용하면 모든 공유 데이터가 구현 통신 구조 밖에 노출된다. 모든 데이터를 공유해야 하는 건 아니므로 전부 다 이벤트 스트림으로 발행할 필요는 없다. **다른 팀/서비스에서 관심 있는 데이터는 공용 이벤트 스트림 세트에 발행함으로써 데이터의 생산과 소유권을 완전히 분리할 수 있다.** 덕분에 시스템 아키텍처에서 오랫동안 부실했던 데이터 통신 구조를 정규화하고 느슨한 결합과 높은 응집도라는 경계 콘텍스트 원칙을 더 확실히 준수할 수 있게 됐다.

애플리케이션을 이벤트 기반으로 개발하면 과거에 점대점 커넥션을 통해 힘들게 가져왔던 데이터에 쉽게 접근할 수 있다. 서비스는 필요한 데이터를 그냥 표준 이벤트 스트림에서 가져와 자신의 모델과 상태를 생서하고, 다른 서비스에 직접 점대점 커넥션을 맺거나 API를 바라보지 않아도 직접 필요한 비즈니스 기능을 수행할 수 있다.

### 접근 가능한 데이터 덕분에 비즈니스 통신 변경이 가능하다
이벤트 스트림에는 비즈니스 운영에 중심적인 핵심 도메인 이벤트가 있다. 팀 구조는 계속 바뀌고 프로젝트는 시작하고 끝나지만 이런 핵심 데이터는 구현 통신 구조와 상관없이 모든 신제품에서 언제든지 활용할 수 있다. 이제 더 이상 핵심 도메인 이벤트가 특정 구현체에 의존하지 않기 때문에 전반적으로 비즈니스가 아주 유연해진다.

## 비동기식 이벤트 기반 마이크로서비스
이벤트 기반 마이크로서비스를 구축하면 경계 콘텍스트 요건에 맞게 필요한 비즈니스 로직 변환을 수행할 수 있다. 애플리케이션은 이런 작업을 수행하면서 다른 다운 스트림 컨슈머도 필요한 자신의 이벤트를 내보내는 역할을 한다.

- 세분성(granularity): 서비스가 경계 콘텍스트에 알맞게 매핑되고 비즈니스 요건이 바뀌어도 쉽게 재작성할 수 있다.
- 확장성(scalability): 개별 서비스는 필요 시 규모를 늘리거나 줄일 수 있다.
- 기술 유연성(technological flexibility): 서비스마다 가장 적합한 언어와 기술로 구현할 수 있고 첨단 기술을 적용해서 쉽게 프로토타이핑 할 수 있다.
- 비즈니스 요건 유연성(business requirement flexibility): 단위가 작은 마이크로서비스는 소유권을 재조정하기 쉽다. 대규모 서비스보다 다른 팀에 덜 의존하기에 데이터 접근 시 장애 요소가 적고 조직은 비즈니스 요건 변화에 신속하게 대응할 수 있다.
- 느슨한 결합(loosely coupling): 이벤트 기반 마이크로서비스는 도메인 데이터와 결합할 뿐, 어떤 특정한 구현 API에 구애받지 않는다. 데이터 스키마를 이용하면 보다 효율적으로 데이터 변경 관리를 할 수 있다.
- 지속적 전달 지원(continuous delivery support): 작은 모듈로 나눈 마이크로서비스는 옮기기 쉽고 필요시 간편하게 롤백할 수 있다.
- 우수한 테스트성(high testability): 마이크로서비스는 덩치 큰 모놀리스보다 디펜던시가 적어 필요한 테스트 엔드포인트를 모킹하고 코드 커버리지를 적절히 유지하기 쉽다.

### 이벤트 기반 마이크로서비스 예제
앞서 예시로 든 팀을 이번엔 이벤트 기반 데이터 통신 구조로 바꿔보자.

예전에 고민했던 기술 이슈, 이를테면 데이터를 어디서 소싱하고 어떻게 싱크할지, 배치 동기화 이슈는 어떻게 처리하고 동기 API는 어떻게 구현할지 등의 문제는 이제 거의 사라졌다. **마이크로서비스를 새로 개발하여 필요한 데이터를 이벤트 스트림에서 받아올 수 있고 필요시 초기 데이터부터 가져올 수도 있다.** 데이터를 오롯이 새로운 경계 콘텍스트의 니즈를 충족시키는 데에만 활용하는 한, 팀은 어떻게든 가져온 공통 데이터를 자신들의 서비스에 맞게 버무려 쓸 수 있다.

서비스를 잘게 나누면 팀마다 소유권을 갖게 되고 나중에 팀을 확장하거나 재구성할 때도 비즈니스 리스크가 줄어든다. 관리자 한 사람이 감당하기 어려울 정도로 팀 규모가 커지면 필요한 만큼 쪼개어 마이크로서비스 소유권을 다시 배정하면 된다. 이벤트 데이터 소유권은 데이터를 생성하는 서비스 쪽으로 이동하며 향후 업무 수행에 필요한 팀 간 의사소통을 줄이기 위해 조직이 결정을 내릴 수도 있다.

신규 서비스를 개발하고 필요한 데이터를 얻는 오버헤드가 최소화되면 마이크로서비스의 속성 상 스파게티 코드를 예방하고 모놀리스가 더 커지지 않게 막을 수 있다. **확장은 이제 개별 이벤트 처리 서비스에만 집중하면 되고 각자 필요한 만큼 CPU, 메모리, 디스크, 인스턴스 개수를 늘리면 된다.** 나머지 확장 요건은 데이터 통신 구조로 넘겨 이벤트 스트림에서 이벤트를 생산/소비하는 다양한 서비스 부하를 처리할 수 있도록 보장해야 한다.

## 동기식 마이크로서비스
동기식 마이크로서비스는 요청-응답 방식으로 직접 API를 통해 소통함으로써 비즈니스 요건을 처리한다.

### 동기식 마이크로서비스의 단점
동기식 마이크로서비스는 대규모 환경에선 문제가 많아 사용하기 곤란하다. Netflix, Lyft, Uber, Facebook 같은 회사의 사례도 있듯 동기식 방식이 곧 실패로 향하는 것은 아니지만, 요청-응답 마이크로서비스의 가장 고질적인 문제점을 짚어보자.

- 점대점 결합: 결국 자신이 할 일을 다른 서비스에 의존해서 할 수밖에 없다. 의존 관계가 꼬리에 꼬리를 물고 여러 서비스에 걸쳐 너무 넓게 펴지면 나중에 어느 서비스가 어떤 비즈니스 로직을 담당하는지 파악하기 매우 어려워진다. 서비스 간 연결 수도 너무 증가해 기존 통신 구조는 고착화되고 뭐 하나 고치려면 아주 힘이 든다.
- 의존적 확장: 한 서비스의 확장 가능 여부는 그 서비스가 의존하는 다른 모든 서비스가 확장 가능한지, 또 통신의 팬 아웃 정도와 직접 연관된다. 구현 기술 역시 확장의 병목이 될 가능성이 크다. 이 문제는 부하가 매우 가변적이고 요청이 일시에 몰리는 패턴 때문에 더욱 복잡해지므로 아키텍처 전반에 걸쳐 동기화 처리를 해야 한다.
- 서비스 실패 처리: 의존하는 서비스가 내려가는 예외 상황 발생 시 처리 방법을 정해야 한다. 데이터 정합성을 보장하기 위한 처리방법, 재시도 타이밍, 실패 시 어떻게 복구할지 절차를 마련해야 한다. 그런데 이미 운영 중인 서비스가 더 많을수록 이런 결정을 내리기 어렵다.
- API 버저닝과 디펜던시 관리: 여러 API 정의와 서비스 버전이 동시에 혼재하기 쉽다. 하지만 클라이언트가 최신 API로 항상 업그레이드하도록 강제하긴 어렵고 또 그렇게 하는 것이 바람직하지 않다.
- 데이터 접근이 구현체에 종속된다: 외부 데이터 접근 시 기존 서비스와 동일한 문제가 발생한다. 결국 데이터 접근과 확장성이라는 무거운 짐을 구현 통신 구조에 다시 지우는 셈이다.
- 분산 모놀리스: 서비스가 분산 모놀리스처럼 동작하도록 조합돼서 서비스 간 호출이 얽히고설켜 버린다. 점대점 서비스에서 원격 시스템의 기능을 호출하면 결국 기존 모놀리스 코드와 라인 단위로 맞물리게 되어 경계 콘텍스트 간 경계선이 흐려지게 된다.
- 테스트: 각 테스트를 가동하려면 자신이 의존하는 서비스 역시 가동 중이어야 하고, 그런 서비스들도 또 다른 서비스가 가동 중이어야 돌아가기 때문에 통합 테스트를 수행하기 정말 어렵다. 단위 테스트는 stub으로 가능하지만 더 포괄적인 테스트 요건을 충분히 만족시키기는 어렵다.

### 동기식 마이크로서비스의 장점
물론 부인할 수 없는 장점들이 있다. 사용자 인증, A/B 테스트 같은 데이터 접근 패턴은 직접 요청-응답을 주고받는 방식이 더 유리하다. 외부 서드파티 솔루션은 거의 항상 동기식 메커니즘으로 연계되며 일반적으로 언어에 구애받지 않도록 HTTP로 유연하게 통신한다.

여러 시스템에 걸쳐 작업을 추적하기도 동기식 환경이 더 용이하다. 어느 함수가 허느 시스템에서 호출됐는지 로그를 보면 알 수 있어 디버깅 능력이 뛰어나고 가시성이 좋다.

웹, 모바일 호스팅 서비스는 동기, 비동기 여부와 상관 없이 거의 다 요청-응답 기반으로 이뤄지며 클라이언트는 오로지 자신의 니즈에만 해당되는 응답을 제시간에 수신한다.

아직도 동기식, 모놀리스 스타일 코딩이 훨씬 더 익숙한 개발자가 더 많아 비동기 이벤트 기반 개발이 가능한 사람보다 동기식 시스템 기술을 보유한 사람을 찾기가 더 쉽다.