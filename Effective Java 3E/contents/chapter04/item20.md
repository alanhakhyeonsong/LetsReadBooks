# 아이템 20. 추상 클래스보다는 인터페이스를 우선하라

## 다중 구현 메커니즘

자바가 제공하는 다중 구현 메커니즘은 **인터페이스**와 **추상 클래스**이다. Java 8부터 인터페이스도 디폴트 메서드(default method)를 제공할 수 있어 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다.

## 인터페이스와 추상 클래스의 차이점

- 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다.
- 자바는 단일 상속만 지원하므로, 추상 클래스 방식은 새로운 타입을 정의하는 데 큰 제약이 있다.
- 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.
- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.
  - 요구하는 메서드를 추가하고, 클래스 선언에 `implements`만 추가하면 된다.
  - 자바 플랫폼 내의 `Comparable`, `Iterable`, `AutoCloseable`가 예시이다.
- 기존 클래스 위에 새로운 추상 클래스를 끼워넣기는 어려운게 일반적이다.

두 클래스가 같은 추상 클래스를 확장하길 원한다면, 그 추상 클래스는 계층구조상 두 클래스의 공통 조상이어야 한다. 하지만, 이 방식은 클래스 계층구조에 커다란 혼란을 일으킨다.

## 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.

믹스인이란, 클래스가 구현할 수 있는 타입으로 믹스인을 구현한 클래스에 원래의 '주된 타입' 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.

`Comparable`은 자신을 구현한 클래스의 인스턴스들 끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스의 대표적인 사례이다.

**대상 타입의 주된 기능에 선택적 기능을 '혼합(mixed in)'한다고 해서 믹스인이라 부른다.**

추상 클래스로는 믹스인을 정의할 수 없다.  
기존 클래스에 덧씌울수 없기 때문이고, 클래스는 두 부모를 섬길 수 없는 특성상 계층 구조에는 믹스인을 삽입하기에 합리적인 위치가 없다.

## 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.

타입을 계층적으로 정의하면 수많은 개념을 구조적으로 잘 표현할 수 있지만, 현실에서는 계층을 엄격히 구분하기 어려운 경우도 있다.

```java
public interface Singer {
    AudioClip sing(Song s);
}

public interface Songwriter {
    Song compose(int chartPosition);
}
```

이런 예제가 있다고 가정하자. 타입을 인터페이스로 정의하면 가수 클래스가 Singer, Songwriter 모두를 구현해도 문제가 전혀 없다. 게다가 이 모두를 확장하고 새로운 메서드까지 추가한 제3의 인터페이스를 정의할 수도 있다.

```java
public interface SingerSongwirter extends Singer, Songwriter {
    AudioClip strum();
    void actSensitive();
}
```

이 정도의 유연성이 항상 필요하진 않지만, 이렇게 만들어둔 인터페이스가 결정적인 도움을 줄 수도 있다.  
같은 구조를 클래스로 만드려면 조합 폭발이라는 현상이 발생할 수 있다.

래퍼 클래스 관용구(item 18)와 함께 사용하면 **인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.** 타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 상속뿐이다. 상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기는 더 쉽다.

인터페이스의 메서드 중 구현 방법이 명백한 것이 있다면, 그 구현을 디폴트 메서드로 제공해 프로그래머들의 일감을 덜어줄 수 있다. 이 때는 상속하려는 사람을 위한 설명을 `@ImplSpec` javadoc 태그를 붙여 문서화해야 한다.(item 19)

## 템플릿 메서드 패턴

인터페이스와 추상 골격 구현(skeletal implementation) 클래스를 함께 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 있다.

1. 인터페이스로는 타입을 정의하고, 필요하면 디폴트 메서드 몇 개도 함께 제공한다. : 골격
2. 골격 구현 클래스는 나머지 메서드를 모두 구현한다. : 골격을 기반으로 확장

![](https://images.velog.io/images/songs4805/post/4b6a8e1b-44c0-4da9-a3f8-af6422127a6a/image.png)

`AbstractList`를 예시로 볼 수 있다.

> 📌 추상 골격 구현 클래스 예제는 다음을 참고하자.  
> [Favor Skeletal Implementation in Java](https://dzone.com/articles/favour-skeletal-interface-in-java)

책에서는 다음 코드를 예시로 보여주고 있다.

```java
static List<Integer> intArrayAsList(int[] a) {
    Objects.requireNonNull(a);

    // 다이아몬드 연산자를 이렇게 사용하는 것은 Java 9 부터 가능하다.
    // 더 낮은 버전을 사용한다면 <Integer>로 수정하자.
    return new AbstractList<>() {
        @Override public Integer get(int i) {
            return a[i]; // 오토박싱(item 6)
        }

        @Override public Integer set(int i, Integer val) {
            int oldVal = a[i];
            a[i] = val;  // 오토언박싱
            return oldVal; // 오토박싱
        }

        @Override public int size() {
            return a.length;
        }
    };
}
```

List 구현체가 제공하는 기능들을 생각하면, 이 코드는 골격 구현의 힘을 잘 보여주는 예시라고 한다.  
// 이 예시는 `int` 배열을 받아 `Integer` 인스턴스의 리스트 형태로 보여주는 어댑터(Adapter)이기도 하다.

골격 구현은 기본적으로 상속해서 사용하는 걸 가정하므로 item 19에서 언급한 설계 및 문서화 지침을 모두 따라야 한다.

## 핵심 정리

- 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다.
- 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 꼭 고려해보자.
- 골격 구현은 '가능한 한' 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하는 것이 좋다.
- 인터페이스에 걸려있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하다.
