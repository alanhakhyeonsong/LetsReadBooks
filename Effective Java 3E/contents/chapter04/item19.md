# 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

## 상속을 고려한 설계와 문서화란?

### 1. 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.

클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있다. 이 때 호출되는 메서드가 하위 클래스에서 재정의 가능한 메서드라면 호출할 수 있는 모든 상황을 문서로 남겨두어야 한다.

이를 도와주는 용도로 `@implSpec` 태그가 있는데 javadoc으로 api 생성시 "Implementation Requirements:"로 대체되고 그 메서드의 내부 동작 방식을 설명하는 곳이다. 이 태그를 활성화 하려면 `javadoc -tag "implSpec:a:Implementation Requirements:"`를 이용한다.

### 2. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.

다음은 `java.util.AbstractList`의 `removeRange()` 메서드이다.

![](https://images.velog.io/images/songs4805/post/7d2ac528-be6e-47c3-a2a4-19f892ec6d9b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-02-10%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201.12.19.png)

문서 중간에 보면, `removeRange()` 메서드는 이 리스트 또는 부분리스트에 정의된 clear 연산이 이 메서드를 호출하는데, 리스트 구현의 내부 구조를 활용하도록 이 메서드를 재정의하면 이 리스트와 부분리스트의 clear 연산 성능을 크게 개선할 수 있다고 한다.

List 구현체의 최종 사용자는 이 메서드에 관심이 없다. 그럼에도 이 메서드를 제공한 이유는 단지 하위 클래스에서 부분리스트의 clear 메서드를 고성능으로 만들기 쉽게 하기 위해서이다.

상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출해야 할지를 결정하는 것은 정해진 방법이 없다.  
그저 심사숙고해서 잘 예측해본 뒤, 실제 하위 클래스를 만들어 시험해보는 것이 최선이다. 또한 protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 한 적어야 한다. 또한 너무 적게 노출해서 상속으로 얻는 이점마저 없애면 안된다.

### 3. 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'하다. 또한 상속용 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.

하위 클래스를 만들며 상속용 클래스를 검증한다. 꼭 필요한 protected 멤버를 놓쳤다면, 하위 클래스를 작성할 때 그 빈자리가 확연히 드러난다. 반대로 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private 이었어야 할 가능성이 크다.

### 4. 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.

이 규칙을 어기면 프로그램이 오동작 할 것이다.

```java
public class Super {
    public Super() {
        overrideMe();
    }

    public void overrideMe() { }
}

public final class Sub extends Super {
    private final LocalDateTime instant;
    public Sub() {
        instant = LocalDateTime.now();
    }

    @Override
    public void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

![](https://images.velog.io/images/songs4805/post/45ac5b94-8ea1-45c6-a3a0-301fa4f9096f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-02-10%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201.56.57.png)

상속 관계에선, **하위 클래스의 생성자 보다 상위 클래스의 생성자가 먼저 호출**되는데, main 메서드에서 sub 객체를 생성하는 지점에선, 상위 클래스의 생성자에서 하위 클래스의 재정의 된 메서드 `overrideMe()`를 instant가 초기화되기도 전에 호출하여 null 값이 출력된다.

이 후 `sub.overrideMe()`를 호출하면 정상적으로 현재 타임이 출력된다.

**final 필드의 상태가 위 프로그램에선 두 가지임에 주목하자.** 정상이라면 단 하나뿐이어야 한다.  
overrideMe에서 instant 객체의 메서드를 호출하려 한다면, 상위 클래스의 생성자가 overrideMe를 호출할 때 `NullPointerException`을 던지게 된다. 다만, 이 프로그램에선 println이 null 입력도 받아들이기 때문에 예외를 던지지 않았다.

이와 같은 현상은 Cloneable의 clone과 Serializable의 readObject에서도 발생한다. 이는 두 메서드가 생성자와 비슷한 새로운 객체를 생성하는 효과를 가지기 때문이다.

### 5. 상속용으로 설계하지 않은 클래스는 상속을 금지한다.

상속을 금지하는 방법은 두 가지이다.

1. 클래스를 final로 선언한다.
2. 모든 생성자를 private이나 package-private로 선언하고 public 정적 팩토리를 만들어준다.

정적 팩토리 방법은 내부에서 다양한 하위 클래스를 만들어 쓸 수 있는 유연성을 제공해주는 장점이 있다.

구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해진다. 상속을 허용해야 한다면, 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남겨두어야 한다. 재정의 가능 메서드를 호출하는 자기 사용 코드를 완벽히 제거하라는 의미이다.

클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 방법은 private '도우미 메서드'를 만들어 재정의 가능 메서드의 기능을 옮기고 도우미 메서드를 호출하도록 수정하는 것이다.

## 핵심 정리

- 상속용 클래스를 설계하는 것은 만만치 않다.
- 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다.
- 그렇지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있다.
- 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다.
- 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 낫다.
- 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.
