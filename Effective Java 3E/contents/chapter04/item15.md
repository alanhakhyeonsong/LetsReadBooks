# 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

> 잘 설계된 컴포넌트는 클래스 내부 데이터와 내부 구현을 외부 컴포넌트로부터 잘 숨겨 캡슐화 한다.

## 잘 설계된 컴포넌트란?

- 캡슐화가 얼마나 잘 되어있는지?
- 노출되는 API와 실제 구현이 얼마나 잘 분리되어 있는지?
- 메시지를 주고받는 두 컴포넌트가 서로의 내부 동작을 신경쓰지 않는지?

## 정보 은닉(캡슐화)의 장점

- 여러 컴포넌트를 병렬로 개발할 수 있기 때문에 시스템 개발 속도를 높인다.
- 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문에 시스템 관리 비용을 낮춘다.
- 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음, 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문에 성능 최적화에 도움을 준다.
- 소프트웨어 재사용성을 높인다.
- 큰 시스템을 제작하는 난이도를 낮춰준다. 전체 시스템이 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문이다.

## 캡슐화의 핵심은 **접근 제어자**

기본원칙은 간단하다. **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.**

- `private`: 멤버를 선언한 톱레벨 클래스에서만 접근 가능
- `package-private`: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능
- `protected`: `package-private` + 하위클래스에서 접근 가능
- `public`: 모든 곳에서 접근 가능

## 캡슐화 방법

공개 API를 설계하고 그것만 public으로 지정한다. 나머지는 private로 만든다. 구현 중 같은 패키지의 다른 클래스가 접근해야 한다면 package-private로 플어준다.

이 과정에서 권한을 풀어주는 일을 자주하게 된다면, 컴포넌트를 더 분해해야 하는 것은 아닌지 고려해보자.

추가로 고려할 사항은 다음과 같다.

- 한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 private 정적 클래스로 중첩시켜본다. 이 중첩 클래스는 포함된 톱레벨 클래스에서만 접근할 수 있다.
- public 일 필요가 없는 클래스는 package-private 클래스로 바꾸자. (테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API로 만들어선 안된다.)

## public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.

필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다. 그 필드와 관련된 모든 것은 불변식을 보장할 수 없게 된다는 뜻이다.

**public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.** 필드가 수정될 때 (락 획득 같은) 다른 작업을 할 수 없게 되기 때문이다.

필드가 final이면서 불변 객체를 참조하더라도 문제는 여전히 남게된다. 내부 구현을 바꾸고 싶어도 그 public 필드를 없애는 방식으로는 리팩터링할 수 없게 된다.

> 예외) 해당 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 좋다. 이런 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야 한다.

길이가 0이 아닌 배열은 모두 변경 가능하니 주의하자.  
**따라서 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.**

## 핵심 정리

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라.
- 꼭 필요한 것만 골라 최소한의 public API를 설계하자.
- 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다.
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다.
- public static final 필드가 참조하는 객체가 불변인지 확인하라.
