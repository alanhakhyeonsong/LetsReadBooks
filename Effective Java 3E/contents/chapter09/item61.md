# 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라
Java의 데이터 타입은 크게 두 가지로 나눌 수 있다.
- 기본 타입: `int`, `double`, `boolean` 등
- 참조 타입: `String`, `List` 등

각각의 기본 타입에는 대응하는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다. 예를 들어, `int`, `double`, `boolean`에 대응하는 박싱된 기본 타입은 `Integer`, `Double`, `Boolean`이다.

오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수는 있지만, 그렇다고 차이가 사라지는 것은 아니다. **둘 사이에는 분명한 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다.**

## 기본 타입과 박싱된 기본 타입의 주된 차이
1. **기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다.**  
박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 `null`을 가질 수 있다.
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

이 세 가지 차이를 주의하지 않고 사용하면 문제가 발생할 수 있다.

## Integer 비교자 예시
```java
// 잘못 구현된 비교자
Comparator<Integer> naturalOrder = 
    (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```
겉보기엔 별 문제 없지만 심각한 결함이 숨어있다.  
`naturalOrder.compare(new Integer(42), new Integer(42))`의 값을 출력해보면 0을 출력해야 하지만, 실제로는 1을 출력한다. 첫 번째 Integer가 두 번째보다 크다고 주장하는 것이다.

`naturalOrder`의 첫 번째 검사(`i < j`)는 잘 동작한다. 이 때, i와 j가 참조하는 오토박싱된 Integer 인스턴스는 기본 타입 값으로 변환된다. 이 후 크기 비교가 이뤄지고 만약 i가 j보다 작지 않다면 두 번째 검사(`i == j`)가 이뤄진다. 하지만 이 두 번째 검사에선 **두 '객체 참조'의 식별성을 검사**하게 된다.  
i와 j가 서로 다른 Integer 인스턴스라면 (비록 값은 같더라도) 이 비교의 결과는 false가 되고, 비교자는 (잘못된 결과인) 1을 반환한다.

이처럼 같은 객체를 비교하는 게 아니라면 **박싱된 기본 타입에 `==` 연산자를 사용하면 오류가 일어난다.**

```java
// 문제를 수정한 비교자
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed; // 오토박싱
    return i < j ? -1 : (i == j ? 0 : 1);
};
```

## null 참조 예시
```java
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42)
            System.out.println("unbelievable");
    }
}
```
위 예제 코드는 "unbelievable"을 출력하지 않고 `NullPointerException`을 던진다.  
**원인은 i가 int가 아닌 Integer**이며, 다른 참조 타입 필드와 마찬가지로 i의 초깃값도 null이라는 데 있다. 즉 `i == 42`는 Integer와 int를 비교하는 것이다.

거의 예외 없이 **기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.** 그리고 null 참조를 언박싱하면 `NullPointerException`이 발생한다.

위 문제는 i를 int로 선언해주면 해결할 수 있다.

## 박싱과 언박싱의 속도 저하 문제
```java
// 굉장히 느리다
public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println();
}
```
위 예제 코드는 실수로 지역변수 sum을 박싱된 기본 타입으로 선언하여 느려졌다. 오류나 경고 없이 컴파일되지만, 박싱과 언박싱이 반복해서 일어나 체감될 정도로 성능이 느려진다.

## 박싱된 기본 타입을 사용하는 시기
1. 컬렉션의 원소, 키, 값으로 쓴다. 컬렉션은 기본 타입을 담을 수 없기 때문이다.
2. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다.  
Java 언어가 타입 매개변수로 기본 타입을 지원하지 않기 때문이다.  
ex) `ThreadLocal<Integer>`
3. 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.

## 핵심 정리
- 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라. 기본 타입은 간단하고 빠르다.
- 박싱된 기본 타입을 써야 한다면 주의를 기울이자.
- **오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.**
- 두 박싱된 기본 타입을 `==` 연산자로 비교한다면 식별성 비교가 이뤄지는데, 이는 우리가 원한게 아닐 가능성이 크다.
- 같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, **언박싱 과정에서 `NullPointerException`을 던질 수 있다.**
- 마지막으로, 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.