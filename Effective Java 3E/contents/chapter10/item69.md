# 아이템 69. 예외는 진짜 예외 상황에만 사용하라
```java
// 예외를 완전히 잘못 사용한 예시
try {
    int i = 0;
    while (true)
        range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```
위 코드는 배열의 원소를 순회하는데, 끔찍한 방식으로 하고 있다. 무한루프를 돌다가 배열의 끝에 도달해 `ArrayIndexOutOfBoundsException`이 발생하면 끝을 내는 것이다.

```java
// 표준적인 관용구로 작성했다면 이해하기 쉬운 코드였을 것이다.
for (Mountain m : range) {
    m.climb();
}
```
앞서 잘못된 코드에선 예외를 써서 루프를 종료한 이유는 도대체 뭘까? 이는 잘못된 추론을 근거로 성능을 높여보려 한 것이다. 3가지 잘못된 추론은 다음과 같다.

1. 예외는 예외 상황에서 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약하다. (최적화에 별로 신경 쓰지 않았을 가능성이 크다.)
2. 코드를 `try-catch` 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.
3. 배열을 순회하는 표준 관용구는 앞서 걱정한 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해 없애준다.

실상은 예외를 사용한 쪽이 표준 관용구보다 훨씬 느리다.

예외를 사용한 반복문의 해악은 코드를 헷갈리게 하고 성능을 떨어뜨리는데서 끝나지 않는다. 심지어 제대로 동작하지 않을 수도 있다. 반복문 안에 버그가 숨어 있다면 흐름 제어에 쓰인 예외가 이 버그를 숨겨 디버깅을 훨씬 어렵게 할 것이다. 반복문의 몸체에서 호출한 메서드가 내부에서 관련 없는 배열을 사용하다가 `ArrayIndexOutOfBoundsException`을 일으켰다면 표준 관용구였다면 이 버그는 예외를 잡지 않고 해당 스레드를 즉각 종료시킬 것이다. 반면 예외를 사용한 반복문은 버그 때문에 발생한 엉뚱한 예외를 정상적인 반복문 종료 상황으로 오해하고 넘어간다.

**예외는 (그 이름이 말해주듯) 오직 예외 상황에서만 써야한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다.**  
**잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.**

## 핵심 정리
- 예외는 예외 상황에서 쓸 의도로 설계되었다.
- 정상적인 제어 흐름에서 사용해서는 안 되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안 된다.