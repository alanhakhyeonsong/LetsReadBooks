# 아이템 28. 배열보다는 리스트를 사용하라

## 배열과 제네릭 타입의 두 가지 중요한 차이

### 1. 배열은 **공변**이고, 제네릭은 **불공변**이다.

```java
Object[] objectArr = new Object[3];
Long[] longArr = new Long[3];
```

공변이란, 위 배열 관계에서 Long 배열은 Object 배열의 하위 타입이 된다는 뜻이다.

```java
Object[] objectArr = new Long[3];
objectArr[0] = "타입때문에 넣을 수 없다." // 런타임 에러(ArrayStoreException)

List<Object> objectList = new ArrayList<String>(); // 컴파일 에러(호환되지 않는 타입이다.)
```

**위 처럼 배열에선 실수를 런타임에서야 알게 되지만, 리스트를 사용하면 컴파일할 때 바로 알 수 있다.**

### 2. 배열은 실체화되는 반면, 제네릭은 타입 정보가 런타임에는 소거된다.

소거는 제네릭이 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 메커니즘으로, Java 5가 제네릭으로 순조롭게 전환될 수 있도록 해주었다.(item 26)

## 제네릭 배열을 만들지 못하게 막은 이유?

**타입 안전하지 않기 때문이다.**

이를 허용한다면, 컴파일러가 자동 생성한 형변환 코드에서 런타임에 `ClassCastException`이 발생할 수 있다. 이는 런타임에 `ClassCastException`이 발생하는 일을 막아주겠다는 제네릭 타입 시스템의 취지에 어긋나는 것이다.

```java
// 제네릭 배열 생성을 허용하지 않는 이유: 컴파일 되지 않는다.
List<String>[] stringLists = new List<String>[1]; // (1)
List<Integer> intList = List.of(42); // (2)
Object[] objects = stringLists; // (3)
objects[0] = intList; // (4)
String s = stringLists[0].get(0); // (5)
```

제네릭 배열을 생성하는 (1)이 허용된다고 가정해보면,

- (2)는 원소가 하나인 `List<Integer>`를 생성한다. (3)은 (1)에서 생성한 `List<String>`의 배열을 Object 배열에 할당한다. 배열은 공변이니 아무 문제 없다.

- (4)는 (2)에서 생성한 `List<Integer>`의 인스턴스를 Object 배열의 첫 원소로 저장한다. 제네릭은 소거 방식으로 구현되어 이 역시 성공한다. 즉, 런타임에는 `List<Integer>` 인스턴스의 타입은 단순히 `List`가 되고, `List<Integer>[]` 인스턴스의 타입은 `List[]`가 된다. 따라서 (4)에서도 `ArrayStoreException`을 일으키지 않는다.

- `List<String>` 인스턴스만 담겠다고 선언한 `stringLists` 배열에서는 현재 `List<Integer>` 인스턴스가 저장돼 있다. (5)는 이 배열의 처음 리스트에서 첫 원소를 꺼내려한다. 컴파일러는 꺼낸 원소를 자동으로 `String`으로 형변환하는데, 이 원소는 `Integer`이므로 런타임에 `ClassCastException`이 발생한다.

## 배열은 실체화 가능 타입이고, 제네릭은 실체화 불가 타입이다.

1. 실체화 가능 타입은 런타임에도 타입 정보를 가지고 있다.
2. 제네릭은 런타임에 타입 정보를 가지고 있지 않다.
3. `new List[]`, `new E[]` 같은 제네릭을 배열로 만드는 행위가 불가능하다는 것이다.

정리하자면, 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입이 실체화 불가 타입이다. 소거 메커니즘 때문에 매개변수화 타입 가운데 실체화될 수 있는 타입은 `List<?>`와 `Map<?, ?>` 같은 비한정적 와일드카드 타입뿐이다.(item 26)

## 배열을 제네릭으로 만들 수 없어 발생하는 일들

제네릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는 게 보통은 불가능하다. (예외가 있긴 하다.)

제네릭 타입과 가변인수 메서드를 함께 쓰면 해석하기 어려운 경고 메시지를 받게 된다. 이는 `@SafeVarags` 애너테이션으로 대처할 수 있다.

배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우 대부분은 배열인 `E[]` 대신 컬렉션인 `List<E>`를 사용하면 해결된다. 코드가 조금 복잡해지고 성능이 살짝 나빠질 수도 있지만, 그 대신 타입 안전성과 상호운용성은 좋아진다.

## 핵심 정리

- 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다.
- 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거된다.
- 그 결과 배열은 런타임에는 타입 안전하지만, 컴파일타임에는 그렇지 않다. 제네릭은 반대다.
- 그래서 둘을 섞어 쓰기란 쉽지 않다. 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법을 적용해보자.
