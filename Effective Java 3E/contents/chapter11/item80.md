# 아이템 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라
## 실행자 서비스
동시성 작업을 할 때는 작업 큐를 직접 생성할수도 있겠지만 복잡한 작업들(안전실패, 응답불가 예방)이 필요하다.  
`java.util.concurrent` 패키지가 등장한 결과, 실행자 프레임워크(Executor Framework)라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 사용할 수 있게 되었다. 작업 큐를 직접 생성한 것 보다 모든 면에서 뛰어난 작업 큐를 다음 한 줄로 생성할 수 있게 되었다.

```java
ExecutorService exec = Executors.newSingleThreadExecutor();

// 실행자에 실행할 태스크를 넘긴다.
exec.execute(runnable);

// 실행자 종료 (이 작업이 실패하면 VM 자체가 종료되지 않을 것이다)
exec.shutdown();
```

실행자 서비스의 주요 기능들은 다음과 같다.
- 특정 태스크가 완료되기를 기다린다: `get()`
- 태스크 모음 중 아무것 하나(`invokeAny()`) 혹은 모든 태스크(`invokeAll()`)가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다: `awaitTermination()`
- 완료된 태스크들의 결과를 차례로 받는다: `ExecutorCompletionService` 사용
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다: `ScheduledThreadPoolExecutor` 사용

큐를 둘 이상의 스레드가 처리하게 하고 싶다면 간단히 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스(스레드 풀)를 생성하면 된다.  
스레드 풀의 스레드 개수는 고정할 수도 있고 필요에 따라 늘어나거나 줄어들게 설정할 수도 있다. 스레드 풀의 설정을 좀 더 견고하게 하고 싶다면 `ThreadPoolExecutor` 클래스를 직접 사용할 수 있다.

## 실행자 서비스를 사용하기에 까다로운 애플리케이션
`Executors.newCachedThreadPool`  
요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행된다. 가용한 스레드가 없다면 새로 하나를 생성한다. 서버가 아주 무겁다면 CPU 사용률이 100%로 치잗고, 새로운 태스크가 도착하는 족족 또 다른 스레드를 생성하며 상황을 더욱 악화시킨다. 이런 경우엔 적합하지 않은 방식이다.

무거운 프로덕션 서버에선 다음 두 가지를 고려하자.
- 스레드 개수를 고정한 `Executors.newFixedThreadPool` 선택
- 완전히 통제할 수 있는 `ThreadPoolExecutor`를 직접 사용

작업 큐를 손수 만드는 일은 삼가야 하고, 일반적으로 스레드를 직접 다루는 일도 삼가야 한다. 스레드를 직접 다루면 Thread가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 된다.  
반면, 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다.

작업 단위를 나타내는 핵심 추상 개념이 Task이다.  
ex) `Runnable`, `Callable`

## ForkJoin 태스크
Java 7부터 실행자 프레임워크는 포크-조인 태스크를 지원하도록 확장되었다. 포크-조인 태스크는 포크-조인 풀이라는 특별한 실행자 서비스가 실행해준다.

`ForkJoinTask`의 인스턴스는 작은 하위 태스크로 나뉠 수 있고, `ForkJoinPool`을 구성하는 스레드들이 이 태스크들을 처리하며, 일을 먼저 끝낸 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리할 수도 있다. 그 결과 CPU를 최대한 활용하면서 높은 처리량과 낮은 지연시간을 달성한다.

Java 8부터 나온 병렬스트림은 내부적으로 포크-조인 프레임워크를 사용한다.  
// [모던 자바 인 액션: Chapter 7 - 병렬 데이터 처리와 성능](https://github.com/alanhakhyeonsong/LetsReadBooks/blob/master/Modern%20Java%20In%20Action/contents/chapter07.md)