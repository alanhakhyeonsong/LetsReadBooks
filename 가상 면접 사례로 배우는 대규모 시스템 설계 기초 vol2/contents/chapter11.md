# 11장. 결제 시스템
결제 시스템이란?

> *결제 시스템은 금전적 가치의 이전을 통해 금융 거래를 정산하는 데 사용되는 모든 시스템이다. 여기에는 가치 교환을 가능하게 하는 제도, 도구, 사람, 규칙, 절차, 표준 및 기술이 포함된다.*

## 1단계: 문제 이해 및 설계 범위 확정
- 어떤 결제 시스템을? → 아마존닷컴과 같은 전자상거래 애플리케이션을 위한 결제 백엔드 구축.
- 어떤 결제 방법 지원? → 결제 시스템은 실생활에서 사용 가능한 모든 옵션을 지원해야 하지만, 신용 카드 결제에만 한정해보자.
- 신용 카드 결제 처리를 직접 해야 하는지? → 전문 결제 서비스 업체를 사용한다. (ex. Toss Payments)
- 신용 카드 데이터를 시스템에 저장해야 하는지? → 보안 및 법규 준수의 까다로운 문제로 카드 번호를 시스템에 직접 저장하지 않고 민감 데이터 처리는 결제 처리 업체에 의존한다.
- 글로벌 서비스를 지원하는지? → 하나의 통화만 사용한다 가정하자.
- 하루 100만 건의 거래가 이루어진다고 가정한다.
- 전자상거래 사이트에서 매월 판매자에게 대금을 지급하는 절차를 지원한다.
- 많은 내/외부 서비스와 연동하므로 한 서비스에 장애 발생 시 서비스 간 상태가 달라지는 일에 대한 조정 작업을 수행하고 불일치하는 부분이 발견되면 교정하는 작업을 필수로 처리한다.

정리하자면, 기능 요구사항은 다음과 같다.

- 대금 수신(pay-in) 흐름: 결제 시스템이 판매자를 대신하여 고객으로부터 대금을 수령한다.
- 대금 정산(pay-out) 흐름: 결제 시스템이 전 세계의 판매자에게 제품 판매 대금을 송금한다.

비기능 요구사항은 다음과 같다.
- 신뢰성 및 내결함성: 결제 실패는 신중하게 처리해야 한다.
- 내부 서비스와 외부 서비스 간의 조정 프로세스: 시스템 간의 결제 정보가 일치하는지 비동기적으로 확인한다.

#### 개략적인 규모 추정
하루 100만 건의 트랜잭션 처리 → 10TPS (초당 10건의 트랜잭션)

일반적인 데이터베이스로 별 문제 없이 처리 가능한 양이므로, 처리 대역폭 대신 결제 트랜잭션의 정확한 처리에 초점을 맞춰야 한다.

## 2단계: 개략적 설계안 제시 및 동의 구하기
결제 흐름은 자금의 흐름을 반영하기 위해 크게 두 단계로 세분화 된다.

- 대금 수신 흐름: 구매자가 주문을 하면 아마존의 은행 계좌로 돈이 들어오는 흐름. 이 돈은 아마존의 은행 계좌에 있지만 소유권이 전부 아마존에 있는 것은 아니다. 판매자가 상당 부분을 소유하며, 아마존은 수수료를 받고 자금 관리자 역할만 수행한다.
- 대금 정산 흐름: 제품이 배송되고 나면, 그때까지 계좌에 묶여 있던 판매 대금에서 수수료를 제외한 잔액이 판매자의 은행 계좌로 지급되는 흐름.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/52ddc23e-5616-4ce0-9c17-75b33a79aedd)

### 대금 수신 흐름
![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/fb0bb5f9-ebaa-4857-ad94-8dcc10ae9c87)

- 결제 서비스: 사용자로부터 결제 이벤트를 수락하고 결제 프로세스를 조율한다. 일반적으로 가장 먼저 하는 일은 AML/CFT와 같은 규정을 준수하는지, 자금 세탁이나 테러 자금 조달과 같은 범죄 행위의 증거가 있는지 평가하는 위험 점검이다. 이 점검을 통과한 결제만 처리한다. 보통 제3자 제공업체를 이용한다.
- 결제 실행자: 결제 서비스 공급자를 통해 결제 주문 하나를 실행한다. 하나의 결제 이벤트엔 여러 결제 주문이 포함될 수 있다.
- 결제 서비스 공급자: A 계정에서 B 계정으로 돈을 옮기는 역할을 담당한다. 구매자의 신용 카드 계좌에서 돈을 인출하는 역할.
- 카드 유형: Visa, Mastercard 등과 같은 카드 유형.
- 원장: 결제 트랜잭션에 대한 금융 기록이다. 전자상거래 웹사이트의 총 수익을 계산하거나 향후 수익을 예측하는 등, 결제 후 분석에서 매우 중요한 역할을 한다.
- 지갑: 판매자의 계정 잔액을 기록한다.

일반적인 결제 흐름은 다음과 같다.

1. 사용자가 '주문하기' 버튼 클릭 시 결제 이벤트가 생성되어 결제 서비스로 전송됨.
2. 결제 서비스는 결제 이벤트를 데이터베이스에 저장한다.
3. 단일 결제 이벤트에 여러 결제 주문이 포함될 수 있다. 한 결제를 여러 결제 주문으로 분할하는 경우, 결제 서비스는 결제 주문마다 결제 실행자를 호출한다.
4. 결제 실행자는 결제 주문을 데이터베이스에 저장한다.
5. 결제 실행자가 외부 PSP를 호출하여 신용 카드 결제를 처리한다.
6. 결제 실행자가 결제를 성공적으로 처리하고 나면 결제 서비스는 지갑을 갱신하여 특정 판매자의 잔고를 기록한다.
7. 지갑 서버는 갱신된 잔고 정보를 데이터베이스에 저장한다.
8. 지갑 서비스가 판매자 잔고를 성공적으로 갱신하면 결제 서비스는 원장을 호출한다.
9. 원장 서비스는 새 원장 정보를 데이터베이스에 추가한다.

### 결제 서비스 API
#### `POST /v1/payments`
- 결제 이벤트를 실행한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/1bdedafa-bbd9-44c8-9006-59a9937561f0)

`payment_orders`는 아래와 같다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/8b7ce3e3-9f9b-4d31-9ef7-0340d90ee6e9)

- 결제 실행자가 타사 PSP에 결제 요청을 전송할 때, PSP는 `payment_order_id`를 중복 제거 ID로 사용한다. 멱등 키라고도 한다.
- `amount` 필드의 데이터 유형이 `string`임에 유의하자. `double`이 바람직하지 않은 이유는 다음과 같다.
  - 프로토콜, 소프트웨어, 하드웨어에 따라 직렬화/역직렬화에 사용하는 숫자 정밀도가 다를 수 있다. 이러한 차이가 의도치 않은 반올림 오류를 유발할 수 있다.
  - 이 숫자는 매우 클 수도 있고, 매우 작을 수도 있다.
  - 전송 및 저장 시 숫자는 문자열로 보관하고, 표시하거나 계산에 쓸 때만 숫자로 변환한다.


#### `GET /v1/payments/{:id}`
- `payment_order_id`가 가리키는 단일 결제 주문의 실행 상태를 반환한다. 잘 알려진 일부 PSP의 API와 유사하다.

### 결제 서비스 데이터 모델
결제 이벤트와 결제 주문의 두 개 테이블이 필요하다. 결제 시스템용 저장소 솔루션을 고를 때 일반적으로 성능은 가장 중요한 고려사항은 아니다. 다음 사항에 중점을 둔다.

- 안정성이 검증되었는가?
- 모니터링 및 데이터 탐사에 필요한 도구가 풍부하게 지원되는가?
- 데이터베이스 관리자(DBA) 채용 시장이 성숙했는가?

일반적으론 NoSQL/NewSQL 보단 ACID 트랜잭션을 지원하는 전통적인 관계형 데이터베이스를 선호한다.

결제 이벤트 테이블에는 자세한 결제 이벤트 정보가 저장된다. 테이블 스키마는 다음과 같다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/d841adfc-645d-4e02-ab3d-758a95b503ae)

결제 주문 테이블엔 각 결제 주문의 실행 상태가 저장된다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/e0185d50-63ec-46ba-b7ea-4cfc2220c47f)

- `checkout_id`는 외래 키다. 한 번의 결제 행위는 하나의 결제 이벤트를 만들고, 하나의 결제 이벤트엔 여러 개의 결제 주문이 포함될 수 있다.
- 구매자의 신용 카드에서 금액을 공제하기 위해 타사 PSP를 호출하면 판매자 대신 전자상거래 웹사이트의 은행 계좌에 이체가 이루어지는데, 이 프로세스를 대금 수신(pay-in)이라 부른다. 제품이 배송되는 등 대금 정산 조건이 충족되면 해당 대금을 판매자에게 정산하는 절차를 시작한다. 그 결과로 전자상거래 웹사이트의 은행 계좌에서 판매자의 은행 계좌로 금액이 이체된다. 따라서 사용자의 결제를 처리하는 중에는 판매자의 은행 계좌가 아닌, 구매자의 카드 정보만 필요하다.

결제 주문의 실행 상태는 `NOT_STARTED`, `EXECUTING`, `SUCCESS`, `FAILED` 등의 열거 자료형으로 표현된다. 업데이트 로직은 다음과 같다.

- `payment_order_status`의 초깃값은 `NOT_STARTED`
- 결제 서비스는 결제 실행자에 주문을 전송하면 `payment_order_status`의 값을 `EXECUTING`으로 바꾼다.
- 결제 서비스는 결제 처리자의 응답에 따라 `payment_order_status`의 값을 `SUCCESS` 또는 `FAIL`로 변경한다.

이 값이 성공 상태로 결정되면 결제 서비스는 지갑 서비스를 호출하여 판매자 잔액을 업데이트하고 `wallet_updated` 필드의 값은 `TRUE`로 업데이트한다. 이 절차가 끝나고 나면 결제 서비스는 다음 단계로 원장 서비스를 호출하여 원장 데이터베이스의 `ledger_updated` 필드를 `TRUE`로 갱신한다.

동일한 `checkout_id` 아래의 모든 결제 주문이 성공적으로 처리되면 결제 서비스는 결제 이벤트 테이블의 `is_payment_done`을 `TRUE`로 업데이트한다. 일반적으로, 종결되지 않은 결제 주문을 모니터링 하기 위해 주기적으로 실행되는 작업을 마련해 둔다. 이 작업은 임계값 형태로 설정된 기간이 지나도록 완료되지 않은 결제 주문이 있을 경우 살펴보도록 엔지니어에게 경보를 보낸다.

### 복식부기 원장 시스템
원장 시스템에는 복식부기(double-entry)라는 아주 중요한 설계 원칙이 있다. 복식부기는 모든 결제 시스템에 필수 요소이며 정확한 기록을 남기는 데 핵심적 역할을 한다. 모든 결제 거래를 두 개의 별도 원장 계좌에 같은 금액으로 기록한다. 한 계좌에서는 차감이 이루어지고 다른 계좌에는 입금이 이루어진다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/81556acb-68e4-4f7b-84f0-a09933a619ba)

복식부기 시스템에서 모든 거래 항목의 합계는 0이어야 한다. 이 시스템을 활용하면 자금의 흐름을 시작부터 끝까지 추적할 수 있으며 결제 주기 전반에 걸쳐 일관성을 보장할 수 있다.

### 외부 결제 페이지
