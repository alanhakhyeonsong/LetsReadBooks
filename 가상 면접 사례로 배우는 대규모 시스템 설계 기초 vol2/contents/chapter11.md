# 11장. 결제 시스템
결제 시스템이란?

> *결제 시스템은 금전적 가치의 이전을 통해 금융 거래를 정산하는 데 사용되는 모든 시스템이다. 여기에는 가치 교환을 가능하게 하는 제도, 도구, 사람, 규칙, 절차, 표준 및 기술이 포함된다.*

## 1단계: 문제 이해 및 설계 범위 확정
- 어떤 결제 시스템을? → 아마존닷컴과 같은 전자상거래 애플리케이션을 위한 결제 백엔드 구축.
- 어떤 결제 방법 지원? → 결제 시스템은 실생활에서 사용 가능한 모든 옵션을 지원해야 하지만, 신용 카드 결제에만 한정해보자.
- 신용 카드 결제 처리를 직접 해야 하는지? → 전문 결제 서비스 업체를 사용한다. (ex. Toss Payments)
- 신용 카드 데이터를 시스템에 저장해야 하는지? → 보안 및 법규 준수의 까다로운 문제로 카드 번호를 시스템에 직접 저장하지 않고 민감 데이터 처리는 결제 처리 업체에 의존한다.
- 글로벌 서비스를 지원하는지? → 하나의 통화만 사용한다 가정하자.
- 하루 100만 건의 거래가 이루어진다고 가정한다.
- 전자상거래 사이트에서 매월 판매자에게 대금을 지급하는 절차를 지원한다.
- 많은 내/외부 서비스와 연동하므로 한 서비스에 장애 발생 시 서비스 간 상태가 달라지는 일에 대한 조정 작업을 수행하고 불일치하는 부분이 발견되면 교정하는 작업을 필수로 처리한다.

정리하자면, 기능 요구사항은 다음과 같다.

- 대금 수신(pay-in) 흐름: 결제 시스템이 판매자를 대신하여 고객으로부터 대금을 수령한다.
- 대금 정산(pay-out) 흐름: 결제 시스템이 전 세계의 판매자에게 제품 판매 대금을 송금한다.

비기능 요구사항은 다음과 같다.
- 신뢰성 및 내결함성: 결제 실패는 신중하게 처리해야 한다.
- 내부 서비스와 외부 서비스 간의 조정 프로세스: 시스템 간의 결제 정보가 일치하는지 비동기적으로 확인한다.

#### 개략적인 규모 추정
하루 100만 건의 트랜잭션 처리 → 10TPS (초당 10건의 트랜잭션)

일반적인 데이터베이스로 별 문제 없이 처리 가능한 양이므로, 처리 대역폭 대신 결제 트랜잭션의 정확한 처리에 초점을 맞춰야 한다.

## 2단계: 개략적 설계안 제시 및 동의 구하기
결제 흐름은 자금의 흐름을 반영하기 위해 크게 두 단계로 세분화 된다.

- 대금 수신 흐름: 구매자가 주문을 하면 아마존의 은행 계좌로 돈이 들어오는 흐름. 이 돈은 아마존의 은행 계좌에 있지만 소유권이 전부 아마존에 있는 것은 아니다. 판매자가 상당 부분을 소유하며, 아마존은 수수료를 받고 자금 관리자 역할만 수행한다.
- 대금 정산 흐름: 제품이 배송되고 나면, 그때까지 계좌에 묶여 있던 판매 대금에서 수수료를 제외한 잔액이 판매자의 은행 계좌로 지급되는 흐름.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/52ddc23e-5616-4ce0-9c17-75b33a79aedd)

### 대금 수신 흐름
![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/fb0bb5f9-ebaa-4857-ad94-8dcc10ae9c87)

- 결제 서비스: 사용자로부터 결제 이벤트를 수락하고 결제 프로세스를 조율한다. 일반적으로 가장 먼저 하는 일은 AML/CFT와 같은 규정을 준수하는지, 자금 세탁이나 테러 자금 조달과 같은 범죄 행위의 증거가 있는지 평가하는 위험 점검이다. 이 점검을 통과한 결제만 처리한다. 보통 제3자 제공업체를 이용한다.
- 결제 실행자: 결제 서비스 공급자를 통해 결제 주문 하나를 실행한다. 하나의 결제 이벤트엔 여러 결제 주문이 포함될 수 있다.
- 결제 서비스 공급자: A 계정에서 B 계정으로 돈을 옮기는 역할을 담당한다. 구매자의 신용 카드 계좌에서 돈을 인출하는 역할.
- 카드 유형: Visa, Mastercard 등과 같은 카드 유형.
- 원장: 결제 트랜잭션에 대한 금융 기록이다. 전자상거래 웹사이트의 총 수익을 계산하거나 향후 수익을 예측하는 등, 결제 후 분석에서 매우 중요한 역할을 한다.
- 지갑: 판매자의 계정 잔액을 기록한다.

일반적인 결제 흐름은 다음과 같다.

1. 사용자가 '주문하기' 버튼 클릭 시 결제 이벤트가 생성되어 결제 서비스로 전송됨.
2. 결제 서비스는 결제 이벤트를 데이터베이스에 저장한다.
3. 단일 결제 이벤트에 여러 결제 주문이 포함될 수 있다. 한 결제를 여러 결제 주문으로 분할하는 경우, 결제 서비스는 결제 주문마다 결제 실행자를 호출한다.
4. 결제 실행자는 결제 주문을 데이터베이스에 저장한다.
5. 결제 실행자가 외부 PSP를 호출하여 신용 카드 결제를 처리한다.
6. 결제 실행자가 결제를 성공적으로 처리하고 나면 결제 서비스는 지갑을 갱신하여 특정 판매자의 잔고를 기록한다.
7. 지갑 서버는 갱신된 잔고 정보를 데이터베이스에 저장한다.
8. 지갑 서비스가 판매자 잔고를 성공적으로 갱신하면 결제 서비스는 원장을 호출한다.
9. 원장 서비스는 새 원장 정보를 데이터베이스에 추가한다.

### 결제 서비스 API
#### `POST /v1/payments`
- 결제 이벤트를 실행한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/1bdedafa-bbd9-44c8-9006-59a9937561f0)

`payment_orders`는 아래와 같다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/8b7ce3e3-9f9b-4d31-9ef7-0340d90ee6e9)

- 결제 실행자가 타사 PSP에 결제 요청을 전송할 때, PSP는 `payment_order_id`를 중복 제거 ID로 사용한다. 멱등 키라고도 한다.
- `amount` 필드의 데이터 유형이 `string`임에 유의하자. `double`이 바람직하지 않은 이유는 다음과 같다.
  - 프로토콜, 소프트웨어, 하드웨어에 따라 직렬화/역직렬화에 사용하는 숫자 정밀도가 다를 수 있다. 이러한 차이가 의도치 않은 반올림 오류를 유발할 수 있다.
  - 이 숫자는 매우 클 수도 있고, 매우 작을 수도 있다.
  - 전송 및 저장 시 숫자는 문자열로 보관하고, 표시하거나 계산에 쓸 때만 숫자로 변환한다.


#### `GET /v1/payments/{:id}`
- `payment_order_id`가 가리키는 단일 결제 주문의 실행 상태를 반환한다. 잘 알려진 일부 PSP의 API와 유사하다.

### 결제 서비스 데이터 모델
결제 이벤트와 결제 주문의 두 개 테이블이 필요하다. 결제 시스템용 저장소 솔루션을 고를 때 일반적으로 성능은 가장 중요한 고려사항은 아니다. 다음 사항에 중점을 둔다.

- 안정성이 검증되었는가?
- 모니터링 및 데이터 탐사에 필요한 도구가 풍부하게 지원되는가?
- 데이터베이스 관리자(DBA) 채용 시장이 성숙했는가?

일반적으론 NoSQL/NewSQL 보단 ACID 트랜잭션을 지원하는 전통적인 관계형 데이터베이스를 선호한다.

결제 이벤트 테이블에는 자세한 결제 이벤트 정보가 저장된다. 테이블 스키마는 다음과 같다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/d841adfc-645d-4e02-ab3d-758a95b503ae)

결제 주문 테이블엔 각 결제 주문의 실행 상태가 저장된다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/e0185d50-63ec-46ba-b7ea-4cfc2220c47f)

- `checkout_id`는 외래 키다. 한 번의 결제 행위는 하나의 결제 이벤트를 만들고, 하나의 결제 이벤트엔 여러 개의 결제 주문이 포함될 수 있다.
- 구매자의 신용 카드에서 금액을 공제하기 위해 타사 PSP를 호출하면 판매자 대신 전자상거래 웹사이트의 은행 계좌에 이체가 이루어지는데, 이 프로세스를 대금 수신(pay-in)이라 부른다. 제품이 배송되는 등 대금 정산 조건이 충족되면 해당 대금을 판매자에게 정산하는 절차를 시작한다. 그 결과로 전자상거래 웹사이트의 은행 계좌에서 판매자의 은행 계좌로 금액이 이체된다. 따라서 사용자의 결제를 처리하는 중에는 판매자의 은행 계좌가 아닌, 구매자의 카드 정보만 필요하다.

결제 주문의 실행 상태는 `NOT_STARTED`, `EXECUTING`, `SUCCESS`, `FAILED` 등의 열거 자료형으로 표현된다. 업데이트 로직은 다음과 같다.

- `payment_order_status`의 초깃값은 `NOT_STARTED`
- 결제 서비스는 결제 실행자에 주문을 전송하면 `payment_order_status`의 값을 `EXECUTING`으로 바꾼다.
- 결제 서비스는 결제 처리자의 응답에 따라 `payment_order_status`의 값을 `SUCCESS` 또는 `FAIL`로 변경한다.

이 값이 성공 상태로 결정되면 결제 서비스는 지갑 서비스를 호출하여 판매자 잔액을 업데이트하고 `wallet_updated` 필드의 값은 `TRUE`로 업데이트한다. 이 절차가 끝나고 나면 결제 서비스는 다음 단계로 원장 서비스를 호출하여 원장 데이터베이스의 `ledger_updated` 필드를 `TRUE`로 갱신한다.

동일한 `checkout_id` 아래의 모든 결제 주문이 성공적으로 처리되면 결제 서비스는 결제 이벤트 테이블의 `is_payment_done`을 `TRUE`로 업데이트한다. 일반적으로, 종결되지 않은 결제 주문을 모니터링 하기 위해 주기적으로 실행되는 작업을 마련해 둔다. 이 작업은 임계값 형태로 설정된 기간이 지나도록 완료되지 않은 결제 주문이 있을 경우 살펴보도록 엔지니어에게 경보를 보낸다.

### 복식부기 원장 시스템
원장 시스템에는 복식부기(double-entry)라는 아주 중요한 설계 원칙이 있다. 복식부기는 모든 결제 시스템에 필수 요소이며 정확한 기록을 남기는 데 핵심적 역할을 한다. 모든 결제 거래를 두 개의 별도 원장 계좌에 같은 금액으로 기록한다. 한 계좌에서는 차감이 이루어지고 다른 계좌에는 입금이 이루어진다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/81556acb-68e4-4f7b-84f0-a09933a619ba)

복식부기 시스템에서 모든 거래 항목의 합계는 0이어야 한다. 이 시스템을 활용하면 자금의 흐름을 시작부터 끝까지 추적할 수 있으며 결제 주기 전반에 걸쳐 일관성을 보장할 수 있다.

### 외부 결제 페이지
규정 및 법규 준수를 위해 대부분의 기업은 신용 카드 정보를 내부에 저장하지 않는다. 신용 카드 정보를 취급하지 않기 위해 기업들은 PSP에서 제공하는 외부 신용 카드 페이지를 사용한다. 웹사이트의 경우 이 외부 신용 카드 페이지는 위젯 또는 iframe이며, 모바일 애플리케이션의 경우에는 결제 SDK에 포함된 사전에 구현된 페이지다.

중요한 점은 우리 결제 서비스가 아니라 PSP가 제공하는 외부 결제 페이지가 직접 고객 카드 정보를 수집한다는 것이다.

### 대금 정산 흐름
대금 정산(pay-out) 흐름의 구성 요소는 대금 수신 흐름과 아주 유사하다. 다만 PSP를 사용하여 구매자의 신용 카드에서 전자상거래 웹사이트 은행 계좌로 돈을 이체하는 대신, 정산 흐름에선 타사 정산 서비스를 사용하여 전자상거래 웹사이트 은행 계좌에서 판매자 은행 계좌로 돈을 이체한다는 점이다.

일반적으로 결제 시스템은 대금 정산을 위해 외상 매입금 지급 서비스 제공업체를 이용한다.

## 3단계: 상세 설계
### PSP 연동
결제 시스템이 은행이나 비자 또는 마스터카드와 같은 카드 시스템에 직접 연결할 수 있다면 PSP 없이도 결제할 수 있다. 하지만 그런 직접 연결은 아주 특수한 경우로 한정된다. 대부분의 회사는 다음 두 가지 방법 중 하나로 결제 시스템을 PSP와 연동한다.

- 회사가 민감한 결제 정보를 안전하게 저장할 수 있다면 API를 통해 PSP와 연동하는 방법을 택할 수 있다. 회사는 결제 웹페이지를 개발하고 민감한 결제 정보를 수집하며, PSP는 은행 연결, 다양한 카드 유형을 지원하는 역할을 한다.
- 복잡한 규정 및 보안 문제로 인해 민감한 결제 정보를 저장하지 않기로 결정한 경우, PSP는 카드 결제 세부 정보를 수집하여 PSP에 안전하게 저장할 수 있도록 외부 결제 페이지를 제공한다. 대부분의 기업이 택하는 접근법이다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/23a50399-b238-45bf-83bd-6c7a6cb5ed25)

결제 서비스가 전체 결제 프로세스를 조율한다.

1. 사용자가 클라이언트 브라우저에서 '결제' 버튼을 클릭한다. 클라이언트는 결제 주문 정보를 담아 결제 서비스를 호출한다.
2. 결제 주문 정보를 수신한 결제 서비스는 결제 등록 요청을 PSP로 전송한다. 이 등록 요청에는 결제 금액, 통화, 결제 요청 만료일, 리디렉션 URL 등의 결제 정보가 포함된다. 결제 주문이 정확히 한 번만 등록될 수 있도록 비중복 난수 필드를 둔다. 일반적으로 이 UUID는 결제 주문의 ID로 사용된다.
3. PSP는 결제 서비스에 토큰을 반환한다. 토큰은 등록된 결제 요청을 유일하게 식별하는 PSP가 발급한 UUID다. 이후에 이 토큰을 사용하여 결제 등록 및 결제 실행 상태를 확인할 수 있다.
4. 결제 서비스는 PSP가 제공하는 외부 결제 페이지를 호출하기 전에 토큰을 데이터베이스에 저장한다.
5. 토큰을 저장하고 나면 클라이언트는 PSP가 제공하는 외부 결제 페이지를 표시한다.
  - PSP가 제공하는 라이브러리에는 결제 UI를 표시하고, 민감한 결제 정보를 수집하고, 결제를 완료하는 등의 작업을 위해 PSP를 직접 호출하는 로직이 포함되어 있다.
  - 민감 결제 정보는 우리 시스템으론 절대로 넘어오지 않는다.
  - 4단계에서 받은 토큰: PSP의 JS 코드는 이 토큰을 사용하여 PSP의 백엔드 결제 요청에 대한 상세 정보를 검색한다. 이 과정을 통해 알아내야 하는 중요 정보 하나는 사용자에게서 받을 금액이다.
  - 리디렉션 URL: 결제가 완료되면 호출될 웹 페이지 URL이다. PSP의 JS는 결제가 완료되면 브라우저를 리디렉션 URL로 돌려보낸다.
6. 사용자는 신용 카드 번호, 소유자 이름, 카드 유효기간 등의 결제 세부 정보를 PSP의 웹 페이지에 입력한 다음 결제 버튼을 클릭한다. PSP가 결제 처리를 시작한다.
7. PSP가 결제 상태를 반환한다.
8. 이제 사용자는 리디렉션 URL이 가리키는 웹 페이지로 보내진다. 이때 보통 7단계에서 수신된 결제 상태가 URL에 추가된다.
9. 비동기적으로 PSP는 웹훅을 통해 결제 상태와 함께 결제 서비스를 호출한다. 웹훅은 결제 시스템 측에서 PSP를 처음 설정할 때 등록한 URL이다. 결제 시스템이 웹훅을 통해 결제 이벤트를 다시 수신하면 결제 상태를 추출하여 결제 주문 데이터베이스 테이블의 `payment_order_status` 필드를 최신 상태로 업데이트한다.

실제론 위 아홉 단계 각각이 네트워크 문제로 실패할 수 있다. 실제 장애가 발생할 때 체계적으로 처리할 수 있는 방법은 조정(reconciliation)이다.

### 조정
시스템 구성 요소가 비동기적으로 통신하는 경우 메시지가 전달되거나 응답이 반환된다는 보장이 없다. 이는 시스템 성능을 높이기 위해 비동기 통신을 자주 사용하는 결제 관련 사업에 일반적인 문제다. PSP나 은행 같은 외부 시스템도 비동기 통신을 선호한다. 정확성을 보장하는 방법은 조정이다.

관련 서비스 간의 상태를 주기적으로 비교하여 일치하는지 확인한다. 매일 밤 PSP나 은행은 고객에게 정산 파일을 보낸다. 정산 파일에는 은행 계좌의 잔액과 하루 동안 해당 계좌에서 발생한 모든 거래 내역이 기재되어 있다. 조정 시스템은 정산 파일의 세부 정보를 읽어 원장 시스템과 비교한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/0de31bb7-3845-4530-a034-da576da854bb)

조정은 결제 시스템 내부 일관성을 확인할 때도 사용된다. 예를 들어, 원장과 지갑의 상태가 같은지 확인할 수 있다. 조정 중 발견된 차이는 일반적으로 재무팀에 의뢰하여 수동으로 고친다. 발생 가능한 불일치 문제 및 해결 방안은 다음 세 가지 범주로 나눌 수 있다.

1. 어떤 유형의 문제인지 알고 있으며 문제 해결 절차를 자동화할 수 있는 경우: 원인과 해결 방법을 알고 있으며, 자동화 프로그램을 작성하는 것이 비용 효율적인 경우다. 엔지니어는 발생한 불일치 문제의 분류와 조정 작업을 모두 자동화할 수 있다.
2. 어떤 유형의 문제인지는 알고 있지만 문제 해결 절차를 자동화할 수는 없는 경우: 불일치의 원인과 해결 방법을 알고는 있지만 자동 조정 프로그램의 작성 비용이 너무 높다. 발생한 불일치 문제는 작업 대기열에 넣고 재무팀에서 수동으로 수정하도록 한다.
3. 분류할 수 없는 유형의 문제인 경우: 불일치가 어떻게 발생하였는지 알지 못하는 경우다. 이런 불일치 문제는 특별 작업 대기열에 넣고 재무팀에서 조사하도록 한다.

### 결제 지연 처리
대부분의 경우 결제 요청은 몇 초 만에 처리되지만, 완료되거나 거부되기까지 몇 시간 또는 며칠이 걸리는 경우도 있다. 다음은 결제 요청이 평소보다 오래 걸리게 되는 몇 가지 케이스다.

- PSP가 해당 결제 요청의 위험성이 높다고 보고 담당자 검토를 요구하는 경우
- 신용 카드사가 구매 확인 용도로 카드 소유자의 추가 정보를 요청하는 3D 보안 인증 같은 추가 보호 장치를 요구하는 경우

결제 서비스는 처리하는 데 시간이 오래 걸리는 이런 요청도 처리할 수 있어야 한다. 아주 일반적인 관행인 구매 페이지가 외부 PSP에 호스팅 되는 경우 PSP는 다음과 같이 처리한다.

- PSP는 결제가 대기 상태임을 알리는 상태 정보를 클라이언트에 반환하고, 클라이언트는 이를 사용자에게 표시한다. 클라이언트는 또한 고객이 현재 결제 상태를 확인할 수 있는 페이지도 제공한다.
- PSP는 우리 회사를 대신하여 대기 중인 결제의 진행 상황을 추적하고, 상태가 바뀌면 PSP에 등록된 웹훅을 통해 결제 서비스에 알린다.

결제 요청이 최종적으로 완료되면 PSP는 방금 언급한 사전에 등록된 웹훅을 호출한다. 결제 서비스는 내부 시스템에 기록된 정보를 업데이트하고 고객에게 배송을 완료한다. 어떤 PSP는 웹훅을 통해 결제 서비스에 결제 상태 변경을 알리는 대신, 결제 서비스로 하여금 대기 중인 결제 요청의 상태를 주기적으로 확인하도록 하기도 한다.

### 내부 서비스 간 커뮤니케이션
#### 동기식 통신
HTTP와 같은 동기적 통신은 소규모 시스템에서는 잘 작동하지만 규모가 커지면 단점이 분명해진다. 동기식 통신에서 한 요청에 응답을 만드는 처리 주기는 관련된 서비스가 많을수록 길어진다. 단점은 다음과 같다.

- 성능 저하: 요청 처리에 관계된 서비스 가운데 하나에 발생한 성능 문제가 전체 시스템의 성능에 영향을 끼친다.
- 장애 격리 곤란: PSP 등의 서비스에 장애가 발생하면 클라이언트는 더 이상 응답을 받지 못한다.
- 높은 결합도: 요청 발신자는 수신자를 알아야만 한다.
- 낮은 확장성: 큐를 버퍼로 사용하지 않고서는 갑작스러운 트래픽 증가에 대응할 수 있도록 시스템을 확장하기 어렵다.

#### 비동기 통신
- 단일 수신자: 각 요청(메시지)은 하나의 수신자 또는 서비스가 처리한다. 일반적으로 공유 메시지 큐를 사용해 구현한다. 큐에는 복수의 구독자가 있을 수 있으나 처리된 메시지는 큐에서 바로 제거된다. 서비스 A와 서비스 B는 모두 같은 메시지 큐를 구독한다. 각각 메시지를 처리하면 두 메시지는 모두 큐에서 사라진다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/4076cca6-d44e-4f0f-bb69-37dac1aac83e)

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/f32d73fc-0c82-4063-aaa8-735cfe4adce2)

- 다중 수신자: 각 요청은 여러 수신자 또는 서버가 처리한다. Kafka는 이런 시나리오를 잘 처리할 수 있다. 소비자가 수신한 메시지는 Kafka에서 바로 사라지지 않는다. 따라서 동일한 메시지를 여러 서비스가 받아 처리할 수 있다. 따라서 동일한 메시지를 여러 서비스가 받아 처리할 수 있다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/223cb332-4f99-41b5-a96b-8f71edeb35bd)

일반적으로 보자면 동기식 통신은 설계하긴 쉽지만 서비스의 자율성을 높이기엔 적합하지 않다. 의존성 그래프가 커지면 전반적 성능은 낮아진다. 비동기 통신은 설계의 단순성과 데이터 일관성을 시스템 확장성 및 장애 감내 능력과 맞바꾼 결과다. 비즈니스 로직이 복잡하고 타사 서비스 의존성이 높은 대규모 결제 시스템에는 비동기 통신이 더 나은 선택이다.

### 결제 실패 처리
안정성 및 결함 내성은 결제 시스템의 핵심적 요구사항이다.

#### 결제 상태 추적
결제 주기의 모든 단계에서 결제 상태를 정확하게 유지하는 것은 매우 중요하다. 실패가 일어날 때마다 결제 거래의 현재 상태를 파악하고 재시도 또는 환불이 필요한지 여부를 결정한다. 결제 상태는 데이터 추가만 가능한 데이터베이스 테이블에 보관한다.

#### 재시도 큐 및 실패 메시지 큐
실패를 우아하게 처리하기 위해선 다음과 같이 재시도 큐(retry queue), 실패 메시지 큐(dead letter queue)를 두는 것이 바람직하다.

- 재시도 큐: 일시적 오류 같은 재시도 가능 오류는 재시도 큐에 보낸다.
- 실패 메시지 큐: 반복적으로 처리에 실패한 메시지는 결국엔 실패 메시지 큐로 보낸다. 이 큐는 문제가 있는 메시지를 디버깅하고 격리하여 성공적으로 처리되지 않은 이유를 파악하기 위한 검사에 유용하다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/6071885c-adde-42f3-a7dc-473962b93c65)

실무에서 이런 큐가 어떻게 쓰이는지 궁금하다면 [Uber에서 Kafka를 활용해 결제 시스템 안정성과 결함 내성 요건을 어떻게 충족하고 있는지](https://www.youtube.com/watch?v=5TD8m7w1xE0) 살펴보자.

### 정확히 한 번 전달
결제 시스템에 발생 가능한 가장 심각한 문제 중 하나는 고객에게 이중으로 청구하는 것이다. 결제 주문이 정확히 한 번만 실행되도록 결제 시스템을 설계하는 것이 중요하다.

문제를 두 부분으로 나누면 쉽게 해결할 수 있다. 수학적으로 다음 요건이 충족되면 주어진 연산은 정확히 한 번 실행된다.

- 최소 한 번은 실행된다.
- 최대 한 번 실행된다.

#### 재시도
간혹 네트워크 오류나 시간 초과로 인해 결제 거래를 다시 시도해야 하는 경우 재시도 메커니즘을 활용하면 어떤 결제가 최소 한 번은 실행되도록 보장 가능하다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/8f5bc6a8-44e2-46d6-b81c-c066a612d3d3)

재시도 메커니즘을 도입할 땐 얼마나 간격을 두고 재시도할지 정하는 것이 중요하다. 일반적으로 사용되는 전략은 다음과 같다.

- 즉시 재시도: 클라이언트는 즉시 요청을 다시 보낸다.
- 고정 간격: 재시도 전에 일정 시간 기다리는 방안.
- 증분 간격: 재시도 전에 기다리는 시간을 특정한 양 만큼 점진적으로 늘려 나가는 방안.
- 지수적 백오프: 재시도 전에 기다리는 시간을 직전 재시도 대비 두 배씩 늘려 나가는 방안.
- 취소: 요청을 철회하는 방안. 실패가 영구적이거나 재시도를 하더라도 성공 가능성이 낮은 경우 흔히 사용되는 방안이다.

일반적으로 적용 가능한 지침은, 지수적 백오프를 사용하라는 것이다. 에러 코드를 반환할 때는 `Retry-After` 헤더를 같이 붙여 보내는 것이 바람직하다.

재시도 시 발생할 수 있는 잠재적 문제는 이중 결제다.

- 시나리오 1: 결제 시스템이 외부 결제 페이지를 통해 PSP와 연동하는 환경에서 클라이언트가 결제 버튼을 두 번 중복 클릭한다.
- 시나리오 2: PSP가 결제를 성공적으로 하였으나 네트워크 오류로 인해 응답이 결제 시스템에 도달하지 못했다. 사용자가 '결제' 버튼을 다시 클릭하거나 클라이언트가 결제를 다시 시도한다.

이중 결제를 방지하려면 결제는 '최대 한 번' 이루어져야 한다. 이는 다른 말로 멱등성이라고도 부른다.

#### 멱등성
클라이언트와 서버 간의 통신을 위해선 일반적으로 클라이언트가 생성하고 일정 시간이 지나면 만료되는 고유한 값을 멱등 키로 사용한다. 스트라이프, 페이팔 같은 많은 기술 회사가 UUID를 멱등 키로 권장하며 실제로 널리 쓰인다. 결제 요청의 멱등성을 보장하기 위해 HTTP 헤더에 `<멱등 키: 값>`의 형태로 멱등 키를 추가하면 된다.

첫 번째 시나리오를 해결해보자.

사용자가 '결제' 클릭 시 멱등 키가 HTTP 요청의 일부로 결제 시스템에 전송된다. 일반적으로 결제가 이루어지기 직전의 장바구니 ID다. 결제 시스템은 두 번째 요청을 재시도로 처리하는데, 요청에 포함된 멱등 키를 이전에 받은 적이 있기 때문이다. 그 경우 결제 시스템은 이전 결제 요청의 가장 최근 상태를 반환한다.

![image](https://github.com/alanhakhyeonsong/LetsReadBooks/assets/60968342/83275115-1978-4108-839f-a7c382ded77b)

동일한 멱등 키로 동시에 많은 요청을 받으면 결제 서비스는 그 가운데 하나만 처리하고 나머지에 대해선 `429 Too Many Requests` 상태 코드를 반환한다.

멱등성을 지원하는 한 가지 방법은 데이터베이스의 고유 키 제약 조건을 활용하는 것이다.

- 결제 시스템은 결제 요청을 받으면 데이터베이스 테이블에 새 레코드를 넣으려 시도한다.
- 새 레코드 추가에 성공했다는 것은 이전에 처리한 적이 없는 결제 요청이라는 뜻이다.
- 새 레코드 추가에 실패했다는 것은 이전에 받은 적이 있는 결제 요청이라는 뜻이다. 그런 중복 요청은 처리하지 않는다.

두 번째 시나리오를 해결해보자.

앞선 그림과 같이 결제 서비스는 PSP에 비중복 난수를 전송하고 PSP는 해당 난수에 대응되는 토큰을 반환한다. 이 난수는 결제 주문을 유일하게 식별하는 구실을 하며, 해당 토큰은 그 난수에 일대일로 대응된다. 따라서 토큰 또한 결제 주문을 유일하게 식별 가능하다.

사용자가 '결제' 버튼을 다시 누른다 해도 결제 주문이 같으니 PSP로 전성되는 토큰도 같다. PSP는 이 토큰을 멱등 키로 사용하므로, 이중 결제로 판단하고 종전 실행 결과를 반환한다.

### 일관성
결제 실행 과정에서 상태 정보를 유지 관리하는 여러 서비스가 호출된다.

1. 결제 서비스는 비중복 난수, 토큰, 결제 주문, 실행 상태 등의 결제 관련 데이터를 유지 관리한다.
2. 원장은 모든 회계 데이터를 보관한다.
3. 지갑은 판매자의 계정 잔액을 유지한다.
4. PSP는 결제 실행 상태를 유지한다.
5. 데이터는 안정성을 높이기 위해 여러 데이터베이스 사본에 복제될 수 있다.

분산 환경에선 서비스 간 통신 실패로 데이터 불일치가 발생할 수 있다. 이를 해결하는 기법들을 살펴보자.

- 내부 서비스 간 데이터 일관성을 유지하려면 요청이 '정확히 한 번 처리'되도록 보장하는 것이 아주 중요하다.
- 내부 서비스와 외부 서비스 간의 데이터 일관성 유지를 위해선 일반적으로 멱등성과 조정 프로세스를 활용한다.
- 외부 서비스가 멱등성을 지원하는 경우, 결제를 재시도할 때는 같은 멱등 키를 사용해야 한다. 그러나 외부 서비스가 멱등 API를 지원하더라도 외부 시스템이 항상 옳다고 가정할 수는 없으므로, 조정 절차를 생략할 수는 없다.
- 데이터를 다중화하는 경우 복제 지연으로 인해 기본 데이터베이스와 사본 데이터가 불일치하는 일이 생길 수 있다.
  - 주 DB에서만 읽기와 쓰기 연산을 처리한다. 이는 설정하긴 쉽지만 규모 확장성이 떨어진다는 단점이 있다. 사본은 데이터 안정성 보장에만 활용되고 트래픽은 처리하지 않는다. 따라서 자원이 낭비된다.
  - 모든 사본이 항상 동기화되도록 한다. 합의 알고리즘을 사용하거나, 합의 기반 분산 DB를 사용한다.

### 결제 보안
사이버 공격과 카드 도난에 대응하기 위한 몇 가지 기술을 간략하게 살펴보자.

|문제|해결책|
|--|--|
|요청/응답 도청|HTTPS 사용|
|데이터 변조|암호화 및 무결성 강화 모니터링|
|중간자 공격|인증서 고정과 함께 SSL 사용|
|데이터 손실|여러 지역에 걸쳐 데이터베이스 복제 및 스냅숏 생성|
|분산 서비스 거부 공격|처리율 제한 및 방화벽|
|카드 도난|토큰화. 실제 카드 번호를 사용하는 대신 토큰을 저장하고 결제에 사용|
|PCI 규정 준수|PCI DSS는 브랜드 신용 카드를 처리하는 조직을 위한 정보 보안 표준이다.|
|사기|주소 확인, 카드 확인번호(CVV), 사용자 행동 분석 등|

## 4단계: 마무리
결제 시스템은 아주 복잡하다. 더 고려해볼 주제는 다음과 같다.

- 모니터링
- 경보
- 디버깅 도구: 엔지니어와 고객 지원팀이 더 쉽게 디버깅할 수 있도록 결제 거래의 상태, 처리 서버 기록, PSP 기록 등을 검토할 수 있는 도구를 개발하는 것이 중요하다.
- 환율
- 지역: 지역마다 가용한 결제 수단이 완전히 달라질 수 있다.
- 현금 결제: 인도, 브라질 등의 국가에서 일반적인 방식이다.
- 구글/애플 페이 연동