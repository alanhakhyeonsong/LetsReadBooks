# 3장. 생애주기를 갖는 객체 - 엔티티
도메인 주도 개발에서 말하는 엔티티는 **도메인 모델을 구현한 도메인 객체를 의미**한다. 값 객체도 도메인 모델을 구현한 도메인 객체를 의미한다. 이 두 가지 객체의 차이는 **동일성을 통해 식별이 가능한지 아닌지에 있다.**

- 값 객체: 이름, 학년 등의 특정 성질을 띄는 값을 캡슐화 → 변하지 않는 값
- 엔티티: 회원 → 수정 가능하다. 또한 속성이 같아도 다른 엔티티일 수 있는데 예시로 이름이 같더라도 다른 사람일 수 있는 것과 같다.

## 엔티티의 성질
**엔티티는 속성이 아닌 동일성으로 식별되는 객체**다.

엔티티와 값 객체는 모두 도메인 모델을 구현한 도메인 객체라는 점에서 비슷하지만, 성질에 차이가 있다. 엔티티의 성질은 다음과 같다.
- 가변이다.
- 속성이 같아도 구분할 수 있다.
- 동일성을 통해 구별된다.

```java
@Getter
@Entity
@NoArgsConstructor(AccessLevel.PROTECTED)
public class Member {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;
    private String password;

    public void changeName(String name) {
        if (name == null) throw new IllegalArgumentException("name이 null 입니다.");

        this.name = name;
    }
}
```
위 예제 코드는 JPA 엔티티 클래스이다. `changeName`이라는 메소드를 따로 두었기 때문에 가변 객체가 된 것이다. `@Getter`를 통해 접근자는 허용하였으나 무분별한 수정을 막기 위해 `@Setter`를 주지 않고 필요시 개별 속성에 메서드를 두어 수정하도록 하였고, 유효성 검사 또한 두어 방어 코드를 추가하였다.  
모든 속성이 반드시 가변일 필요는 없다. 엔티티는 필요에 따라 속성을 가변으로 만들 수 있는 객체일 뿐이다. 가변 객체는 기본적으로 다루기 까다로운 존재다. **가능한 한 객체는 불변으로 남겨두는 습관을 들이는 것이 좋다.**

값 객체는 속성이 같다면 같은 것으로 취급됐지만, 엔티티는 속성이 같아도 두 엔티티를 서로 다른 것으로 취급한다. JPA에서 위 예제 코드를 가지고 `em.persist()` 등을 실행하여 결과를 확인해보자. 해당 객체가 영속성 컨텍스트(`EntityManager`)의 범위 내에 있는지 준영속 상태인지에 따라 결과는 다르겠지만, 식별자(identity)로 결국 구분짓게 된다.

// 참고: [JPA 영속성 컨텍스트](https://velog.io/@songs4805/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B82)

## 생애주기와 연속성
생애주기를 갖지 않거나 생애주기를 나타내는 것이 무의미한 개념이라면 우선 **값 객체**로 다루는 것이 좋다. 생애주기를 갖는 객체는 태어나서 죽을 때까지 변화를 겪을 수 있다. 정확함이 필요한 소프트웨어를 만들고자 할 때 가변 객체는 신중히 다뤄야 할 성가신 존재다. **불변으로 남겨둘 수 있는 것은 최대한 불변 객체로 남겨둬야 시스템을 단순하게 유지할 수 있다.**

예를 들어, 사용자의 이름 값 객체는 생성된 이후 유지~소멸의 과정이 딱히 의미를 갖진 않는다.  
하지만, 사용자는 한 번 생성되면 DB에 저장되어 서비스가 종료되기 전까지 꾸준히 관리되어야 한다. 이런 의미에서 사용자는 엔티티라고 볼 수 있다.  
이런 엔티티는 가변 객체이므로, 불필요한 변경에 유의해야 한다. 이를 위해 필요 없는 `setter`를 제한하고 팩토리 메소드를 사용하는 등 각별한 유의가 필요하다.

## 도메인 객체를 정의할 때의 장점
도메인 객체를 정의할 때의 장점은 다음과 같다.
- 자기 서술적인 코드가 된다.
- 도메인에 변경사항이 있을 시 코드에 반영하기 쉽다.

이 장점은 최초 개발 시점보단 개발 완료 후 **유지보수 시점에 빛을 발한다.**