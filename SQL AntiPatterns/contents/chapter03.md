# 3장. 순진한 트리
### 목표: 계층구조 저장 및 조회하기
데이터가 재귀적 관계를 갖는 것은 흔하다. 데이터는 트리나 계층적 구조가 될 수 있다.
- 개별 항목을 조회하는 경우
- 전체 중 관련된 부분만 포함한 부분집합만 조회하는 경우
- 데이터 전체를 조회하는 경우

예시
- 조직도
- 글타래

### 안티패턴: 항상 부모에 의존하기
흔히 나오는 방법은 `parent_id` 칼럼을 추가하는 것이다.

```sql
CREATE TABLE Comments (
  comment_id    SERIAL PRIMARY KEY,
  parent_id     BIGINT UNSIGNED,
  bug_id        BIGINT UNSIGNED NOT NULL,
  author        BIGINT UNSIGNED NOT NULL,
  comment_date  DATETIME NOT NULL,
  comment       TEXT NOT NULL,
  FOREIGN KEY (parent_id) REFERENCES Comments(comment_id),
  FOREIGN KEY (bug_id)    REFERENCES Bugs(bug_id),
  FOREIGN KEY (author)    REFERENCES Accounts(account_id),
)
```

위 설계는 인접 목록이라 불린다. 단점은 다음과 같다.
- 조회 쿼리 시 깊이가 확장될 수 있음에 대응하기 복잡해지고 비효율적이다.
- 노드 추가는 간단하지만, 삭제 처리는 bottom-up 방식으로 처리해야 하므로 복잡하다.
- 중간 depth에 있는 항목들을 삭제할 경우 부모에 이어붙이는 작업이 복잡하다.

### 안티패턴 인식 방법
- 트리에서 얼마나 깊은 단계를 지원해야 하지?
  - 재귀적 쿼리를 사용하지 않고 어떤 노드의 모든 후손 또는 모든 조상을 얻기 위해 노력하고 있는 것이다.
  - 트리를 제한된 깊이까지만 지원하는 것으로 타엽할 수도 있겠지만, 어느 정도의 깊이까지 지원해야 할까라는 질문도 뻔하다.
- 트리 데이터 구조를 관리하는 코드는 건드리는 게 겁나
  - 좀 더 정교한 해법 중 하나를 채용했지만, 트레이드 오프를 잘 따지지 못함.
- 트리에서 고아 노드를 정리하기 위해 주기적으로 스크립트를 돌려야 해.
  - 애플리케이션이 트리에서 자식이 있는 노드를 삭제하면서 연결이 끊긴 노드가 생긴 것이다.
  - 복잡한 데이터 구조를 DB에 저장할 땐, 변경을 한 후에도 일관성 있는 유효한 상태로 데이터 구조를 유지해야 한다.

### 안티패턴 사용이 합당한 경우
- 한 단계의 부모-자식 구조라면 충분하다.

### 해법: 대안 트리 모델 사용
- 경로 열거
- 중첩 집합
- 클로저 테이블

|모델|테이블|자식 조회|트리 조회|삽입|삭제|참조 정합성|
|--|--|--|--|--|--|--|
|인접 목록|1|쉽다|어렵다|쉽다|쉽다|가능|
|재귀적 쿼리|1|쉽다|쉽다|쉽다|쉽다|가능|
|경로 열거|1|쉽다|쉽다|쉽다|쉽다|불가능|
|중첩 집합|1|어렵다|쉽다|어렵다|어렵다|불가능|
|클로저 테이블|2|쉽다|쉽다|쉽다|쉽다|가능|

계층구조에는 항목과 관계가 있다. 작업에 맞도록 이 둘을 모두 모델링해야 한다.