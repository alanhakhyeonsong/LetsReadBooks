# 13장. 인덱스 샷건
### 목표: 성능 최적화
DB 성능을 향상시키는 가장 좋은 방법은 인덱스를 잘 활용하는 것이다. DB가 사용하는 데이터 구조로, 값과 이 값을 가지는 행을 서로 관련시켜 놓은 것이다.

### 안티패턴: 무계획하게 인덱스 사용하기
추측으로 인덱스를 선정하면 결국 잘못된 선택을 하게 마련이다. 언제 사용해야 하는지에 대해 오해하면 다음 셋 중 하나의 실수를 하게 된다.

- 인덱스를 불충분하게 정의하거나 또는 아예 정의하지 않는다.
  - 일반적인 애플리케이션이라면 테이블을 한 번 업데이트할 때 조회는 백 번한다. 인덱스로 인한 CUD 작업의 오버헤드가 무작정 낭비가 아니다.
  - `UPDATE`, `DELETE` 시에도 인덱스가 도움이 될 수 있다.
- 너무 많은 인덱스를 정의하거나 도움이 되지 않는 인덱스를 정의한다.
  - DB에 따라 PK에 대해 자동으로 인덱스가 생성되는데 다른 인덱스를 정의하면 중복이다.
  - 긴 문자열 타입에 대한 인덱스는 작은 데이터 타입에 대한 인덱스보다 크다.
  - 특정 값으로 검색할 일이 없는 컬럼에 대해 인덱스 지정은 불필요하다.
  - 복합 인덱스에선 컬럼 순서가 중요하다. 검색 조건, 조인 조건 또는 정렬 순서에 맞춰 왼쪽에서 오른쪽으로 순서를 맞춰야 한다.
  - 테이블의 모든 컬럼에 인덱스를 만들거나 모든 조합으로 인덱스를 만드는 미친 짓을 하지 말자.
- 어떤 인덱스도 도움이 될 수 없는 쿼리를 실행한다.
  - `LIKE` 쿼리의 패턴은 문자열의 어디서든 나올 수 있으므로, 정렬된 인덱스 데이터 구조로 도움을 줄 수 있는 방법이 없다.

```sql
-- last_name, first_name 순으로 복합 인덱스가 걸려있는 상태.
SELECT * FROM Bugs
WHERE last_name = 'Charles' OR first_name = 'Charles';

-- 위 쿼리와 다음 쿼리는 동일하게 동작한다. -> 인덱스가 무의미함.
SELECT * FROM Bugs WHERE last_name = 'Charles'
UNION
SELECT * FROM Bugs WHERE first_name = 'Charles';
```

### 안티패턴 인식 방법
- "이게 내 쿼리인데, 어떻게 빠르게 할 수 있을까?"
  - 테이블에 대한 설명, 인덱스, 데이터 크기, 성능 측정, 최적화에 대한 자세한 내용이 없다면 모든게 추측이다.
- "모든 필드에 인덱스를 걸었는데, 왜 빠르지 않은 거지?"
- "인덱스가 DB를 느리게 만든다는 걸 들었어. 그래서 나는 인덱스를 사용하지 않지."

### 안티패턴 사용이 합당한 경우
- 어떤 쿼리를 최적화하는 것이 중요한지 알지 못하는 상태에서 일반적인 사용을 위해 데이터베이스를 설계해야 한다면, 인덱스를 어떻게 잡아야 최적인지도 확신할 수 없다.
- 많이 놓치거나 실수하더라도, 가능한 최적의 추측이 필요하다.

### 해법: 인덱스를 MENTOR하라
- Measure
  - slow query log를 확인해서 이 쿼리부터 최적화 한다.
  - 특히 자주 실행되는 쿼리가 우선 순위다.
  - 쿼리 성능 측정시엔 쿼리 결과 캐싱 기능을 비활성화시켜야 한다.
- Explain
- Nominate
- Test
  - 인덱스 생성 후, 쿼리를 다시 프로파일링해야 한다. 이 작업이 제일 중요하다.
- Optimize
  - DB 서버는 시스템 메모리의 일정량을 캐싱에 할당하도록 설정할 수 있다. 가용한 시스템 메모리양과 DB의 크기를 고려하여 활용하자.
  - 인덱스를 캐시 메모리에 미리 로딩해 놓고 이득을 얻을 수 있다.
    - ex) MySQL의 `LOAD INDEX INTO CACHE`문
- Rebuild
  - 인덱스는 균형이 잡혀있을 때 가장 효율이 좋다.
  - 데이터를 업데이트, 삭제하면 할수록 인덱스의 균형이 잃어간다.
  - 주기적인 인덱스 정비 역시 필요하다. 재정비 빈도는 상황에 따라 다르니 성능 향상과 재구성을 위한 시간의 비율을 잘 판단하자.