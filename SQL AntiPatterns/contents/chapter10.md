# 10장. 반올림 오류
### 목표: 정수 대신 소수 사용
- 정수가 아닌 수를 저장하고 이를 산술 연산에 사용한다.
- 산술 연산의 결과가 정확해야 한다.

### 안티패턴: FLOAT 데이터 타입 사용
#### 필요에 의한 반올림
부동 소수점 수의 특성인 십진수로 표현된 모든 수를 이진수로 표현할 수 없다는 사실을 기억해야 한다. 다시 말해, 어떤 수는 사용자의 필요와 관계없이 가까운 다른 수로 반올림되어야 한다.

```
1/3   + 1/3   + 1/3   = 1.000
0.333 + 0.333 + 0.333 = 0.999
```

#### SQL에서 FLOAT 사용
```sql
SELECT hourly_rate FROM Accounts WHERE account_id = 123;
-- 결과: 59.95
```

`FLOAT`에 실제로 저장되어 있는 값은 59.95와 정확하게 같지는 않다. 이는 IEEE 754의 이진 형식에 따라 유한 정도로 표현 가능한 값으로 반올림되었음을 나타낸다. 오차범위는 천만분의 일 수준이지만, 동등 비교에 `FLOAT`을 사용하는 경우엔 문제가 생길 수 있다.

```sql
SELECT * FROM Accounts WHERE hourly_rate = 59.95;
-- 결과: 없음
```

금융 애플리케이션에서의 복리 계산은 연속한 곱을 적용하는 좋은 예시다. 부정확한 부동 소수점 수를 사용하면 처음엔 오차가 아주 작지만, 계산을 반복할수록 오차가 누적되고 문제가 커지게 된다. 따라서 이런 애플리케이션에선 정확한 값을 사용하는 것이 중요하다.

### 안티패턴 인식 방법
`FLOAT`, `REAL`, `DOUBLE PRECISION` 데이터 타입이 사용되는 곳이면 어디든 의심이 간다.

### 안티패턴 사용이 합당한 경우
- `INTEGER`나 `NUMERIC` 타입이 지원하는 것보다 큰 범위의 실수 값을 사용해야 하는 경우.
  - 과학계산용 애플리케이션

### 해법: NUMERIC 데이터 타입 사용
고정 소수점 수에는 `FLOAT`나 이와 비슷한 타입이 아닌 `NUMERIC` 또는 `DECIMAL` 타입을 사용해야 한다.

```sql
-- 1234567.89 저장 가능.
-- 123456.789 12345678.91 저장 불가
ALTER TABLE Accounts ADD COLUMN hourly_rate NUMERIC(9,2);
```

- `NUMERIC`과 `DECIMAL`의 장점은 유리수가 `FLOAT` 타입에서와 같이 반올림 되지 않고 저장된다는 것이다.
  - 정확한 동등 비교가 가능하다.