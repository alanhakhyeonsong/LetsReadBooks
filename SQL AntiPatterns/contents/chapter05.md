# 5장. 키가 없는 엔트리
### 목표: 데이터베이스 아키텍처 단순화
관계형 데이터베이스 설계는 각 테이블 자체에 대한 것이기도 하고 테이블간의 관계에 대한 것이기도 하다. 참조 정합성은 데이터베이스를 적절히 설계하고 운영하는 데 있어 중요한 부분이다.

FK를 간혹 무시하라는 이유가 있는데 다음과 같은 것들이 포함되어 있다.

- 데이터 업데이트 시 제약조건과 충돌할 수 있다.
- 참조 정합성 제약조건을 지원할 수 없는 매우 융통성 있는 데이터베이스 설계를 사용하고 있다.
- FK에 데이터베이스가 자동 생성하는 인덱스 때문에 성능에 영향을 받는다고 믿는다.
- FK를 지원하지 않는 데이터베이스를 사용하고 있다.
- FK 선언을 위해 문법을 찾아봐야 한다.

### 안티패턴: 제약조건 무시
FK 제약조건을 생략하는 것이 처음엔 DB 설계를 단순하고 유연하고 빠르게 하는 것처럼 보이겠지만, 다른 방식으로 대가를 치러야 한다. 참조 정합성을 보장하기 위한 코드를 직접 작성해야 하는 책임을 떠안아야 하기 때문이다.

- 무결점 코드
  - 변경 전 별도의 select 쿼리를 실행해 해당 변경이 참조 정합성을 깨뜨리지 않는지 확인해야 함.
- 오류 확인
  - 불필요한 스크립트 반복
- 진퇴양난 업데이트

### 안티패턴 인식 방법
다음 사항들은 키가 없는 엔트리 안티패턴을 사용하고 있을 것이다.

- 어떤 값이 한 테이블엔 있고 다른 테이블엔 없는지 확인하려면 쿼리를 어떻게 작성해야 하지?
  - 이는 보통 부모가 업데이트되거나 삭제되어 고아가 된 자식 행을 찾으려는 것이다.
- 테이블에 삽입하면서 다른 테이블에 어떤 값이 있는지를 확인하는 빠른 방법이 없을까?
  - 부모행이 존재하는지를 확인하려는 것이다. FK가 이를 자동으로 확인해주며, 효율적으로 확인하기 위해 부모 테이블의 인덱스를 활용한다.
- FK는 데이터베이스를 느리게 만들기 때문에 사용하지 말라고 들었는데?
  - FK를 사용하지 않는 것을 간단하게 합리화하기 위해 성능 문제를 말하지만, FK를 사용하지 않으면 성능 문제를 포함해 문제가 해결되기보단 늘어난다.

### 안티패턴 사용이 합당한 경우
- FK 제약조건을 지원하지 않는 데이터베이스를 사용할 수 밖에 없는 경우

### 해법: 제약조건 선언하기
- 여러 테이블 변경 지원
  - `ON UPDATE CASCADE`, `ON DELETE RESTRICT`, ...
- 오버헤드?
  - `INSERT, UPDATE, DELETE` 전에 데이터를 확인하기 위해 `SELECT` 쿼리를 실행할 필요가 없다.
  - 여러 테이블을 변경하기 위해 테이블 잠금을 사용할 필요가 없다.
  - 불가피하게 생기는 고아 데이터를 정정하기 위해 품질 제어 스크립트를 주기적으로 돌릴 필요가 없다.