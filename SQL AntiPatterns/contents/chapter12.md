# 12장. 유령 파일
### 목표: 이미지 또는 벌크 미디어 저장
- 이미지를 저장하고 이를 사용자 계정이나 버그와 같은 데이터베이스 엔티티와 연관을 갖게 한다.
- DB에서 이런 엔티티를 쿼리할 때 관련 이미지도 함께 얻을 수 있어야 한다.

### 안티패턴: 파일을 사용해야 한다고 가정한다
1. `BLOB` 데이터 타입에 이미지의 바이너리 데이터를 저장
2. 이미지를 파일 시스템에 파일로 저장하고 파일에 대한 경로만 `VARCHAR`로 DB에 저장

위 두 가지 방법이 있지만, 파일을 별도로 저장하는 방식에는 아래와 같은 위험이 있다.

#### DELETE 문제
가비지 컬렉션과 관련된 문제다.

```sql
DELETE FROM Screenshots WHERE bug_id = 1234 and image_id = 1;
```

행을 삭제할 때, 해당 행이 가리키는 경로의 파일을 자동으로 삭제하는 방법이 없다. 이는 애플리케이션적으로 설계하지 않으면 고아가 된 이미지 파일이 계속 쌓일 것이다.

#### 트랜잭션 문제
보통은 데이털르 업데이트 혹은 삭제할 때, `COMMIT`으로 트랜잭션을 끝내기 전까지는 변경 사항이 다른 클라이언트에 보이지 않는다. 그러나 외부에 있는 파일을 변경할 때는 이런 식으로 동작하지 않는다.

#### ROLLBACK 문제
에러가 발생한 경우 또는 애플리케이션 로직이 변경사항을 취소해야 하는 경우, 트랜잭션을 롤백하는 것이 보통이다.  
어떤 로직에 대해 롤백하면, 데이터베이스에서 삭제가 취소되어 행이 되살아나지만, 지워진 파일은 되살아나지 않는다.

#### 백업 문제
DB 백업 시 외부 파일을 포함시켰다 하더라도, 파일을 복사한 것과 DB 백업이 잘 동기화된 상태인진 단정하기 어렵다. DB 백업을 시작한 직후에도 애플리케이션에서 어느 때고 이미지 파일을 추가하거나 변경할 수 있기 때문이다.

#### SQL 접근 권한 문제
외부 파일은 `GRANT`나 `REVOKE` 같은 SQL문으로 할당한 접근권한을 우회한다.

#### SQL 데이터 타입 문제
`screenshot_path`에 저장된 경로는 문자열일 뿐이다. DB는 문자열이 유효한 경로이름인지 검증하지 않고, 해당 경로가 실제로 존재하는지도 검증할 수 없다.

### 안티패턴 인식 방법
- 데이터 백업과 복원 절차는 어떻게 되는가? 백업을 어떻게 검증할 수 있는가? 백업을 만든 서버 이외의 다른 서버에서 데이터 복원 테스트를 해본 적이 있는가?
- 이미지가 계속 쌓이는가, 아니면 더 이상 필요하지 않으면 시스템에서 삭제되는가? 이미지를 삭제하는 절차는 어떻게 되는가? 자동화된 절차인가, 수작업 절차인가?
- 애플리케이션의 어떤 사용자가 이미지를 볼 수 있는 권한이 있는가? 권한은 어떻게 확인하는가? 권한이 없는 이미지를 요청하면 사용자가 뭘 보게 되는가?
- 이미지에 대한 변경을 취소할 수 있는가? 그렇다면, 애플리케이션이 이전 상태의 이미지로 복원해야 하는가?

프로젝트에서 이런 질문에 대해 생각해보지 않았다면 이 안티패턴에 대해 유죄다.

### 안티패턴 사용이 합당한 경우
- 이미지가 없다면 데이터베이스가 훨씬 가벼워진다.
- 이미지를 제외하면 데이터베이스 백업이 빨라지고 결과도 작다. 별도의 백업 단계를 통해 파일 시스템의 이미지를 복사해야 하지만, 엄청나게 큰 데이터베이스를 백업하는 것보다는 이게 쉬울 수 있다.
- 이미지가 데이터베이스 외부의 파일로 되어 있으면, 일반적인 이미지 미리보기나 편집이 쉽다.
  - 모든 이미지에 대해 배치 편집을 적용해야 한다면, 이미지를 데이터베이스 밖에 보관하는 것이 좋다.

이미지를 파일로 저장할 때 이런 장점이 중요하고 앞서 제기된 문제가 덜 중요하다면, 해당 프로젝트에선 이미지를 DB 밖에 저장하는 것이 올바르다 결정할 수 있다.

> 내가 생각하기엔, 글로벌 서비스를 고려한다면 CDN + Object Storage(or S3)으로 관리하는게 이미지나 미디어 파일을 불러오는 속도가 빠를 것 같다. 게다가 요즘엔 클라우드 상품에서 지원하는 영역이 크다보니 문제점이 오히려 덜할 수도 있다. (뭐... 책에선 제대로 알고 결정하라고 하니)

### 해법: 필요한 경우에는 BLOB 데이터 타입을 사용하라
- 이미지 데이터가 DB에 저장된다. 이미지를 로드하기 위한 별도 단계가 필요하지 않다. 파일 경로가 잘못될 위험도 없다.
- 행을 삭제하면 이미지도 자동으로 삭제된다.
- 커밋하기 전까지는 이미지 변경이 다른 클라이언트에 보이지 않는다.
- 트랜잭션을 롤백하면 이미지도 이전 상태로 복원한다.
- 행을 업데이트할 때 해당 행에 잠금이 설정되므로 다른 클라이언트는 동일한 이미지를 동시에 업데이트할 수 없다.
- 데이터베이스 백업에 모든 이미지가 포함된다.
- SQL 권한은 행뿐 아니라 이미지에 대한 접근도 제어한다.

`BLOB` 타입의 최대 크기는 DB마다 다르니 확인이 필요하다.